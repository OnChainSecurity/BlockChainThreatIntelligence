{
    "threat_intelligence": {
        "url": "https://metaschool.so/articles/what-is-a-reentrancy-attack/",
        "timestamp": "2016-04-30 00:00:00",
        "original_content": "\n\nA reentrancy attack is a specific type of vulnerability in smart contracts in which an external malicious contract exploits a vulnerability in another contract by repeatedly calling back into the vulnerable contract before a particular function finishes its execution. Let\u2019s try to understand what exactly it means with an example.\n\n\nExample of a vulnerable contract\n\n\nBelow is a simple solidity code which has a reentrancy vulnerability. Let\u2019s understand how the attacker can exploit this contract \u2013\n\n\ncontract Vault {\n    mapping(address => uint) public balances;\n    /// @dev Store ETH in the contract.\n    function store() public payable {\n        balances[msg.sender]+=msg.value;\n    }\n    /// @dev Redeem your ETH.\n    function redeem() public {\n        msg.sender.call{ value: balances[msg.sender] }(\"\");\n        balances[msg.sender]=0;\n    }\n}\n\n\n\nTake a close look at the \nreedem\n function in the above example. Here, the balance is updated after the funds are sent to the user. An attacker can use this function to exploit the smart contract by calling the same function (\nreedem\n here) multiple times before the balance gets updated and he could eventually even drain the balance of the whole contract. This is the most classic case scenario of a reentrancy attack vulnerability.\n Check this course out:\u00a0\nBuild a One Piece Personality dApp With Solidity\n\n\nHow to prevent Reentrancy attack\n\n\nThere are several ways to prevent reentrancy attacks in a smart contract. Let\u2019s take a look at them\n\n\nChecks-Effects-Interactions Pattern\n\n\nThe Checks-Effects-Interactions pattern is a best practice in smart contract development that helps prevent vulnerabilities like reentrancy attacks. This pattern defines a structured way to organize the code within a function to ensure than a certain checks and state changes are performed before interacting with external contracts or executing complex logic.\n\n\nThis ensures that the function checks for preconditions or requirements that must be met before proceeding with the execution and the state is updated when the conditions are met and then the transaction is executed.\n\n\nThe Check-Effects-Interaction pattern in the above example would change our code to the one shown below which eliminates the reentrancy attack.\n\n\ncontract Vault {\n    mapping(address => uint) public balances;\n    /// @dev Store ETH in the contract.\n    function store() public payable {\n        balances[msg.sender]+=msg.value;\n    }\n    /// @dev Redeem your ETH.\n    function redeem() public {\n        balances[msg.sender]=0;\n        msg.sender.call{ value: balances[msg.sender] }(\"\");\n    }\n}\n\n\n\nUsing Reentrancy Guard Contract\n\n\nYou can use a simple reentrancy guard contract like below in order to prevent your smart contract from vulnerability:\n\n\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    modifier nonReentrant() {\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n}\n\n\n\nUsing the nonReentrant modifier, you can check if the function has been called once and prevent executing it again and again multiple times to exploit the contract.\n\n\nReal-World Impact of Reentrancy Attacks\n\n\nSeveral high-profile incidents have highlighted the devastating consequences these vulnerabilities can have. Here are a few examples:\n\n\nThe DAO Hack (2016):\n This infamous attack targeted The DAO, a decentralized autonomous organization built on the Ethereum blockchain. The DAO leveraged smart contracts to manage its funds. Hackers exploited a reentrancy vulnerability in the DAO\u2019s contract, allowing them to siphon off over $60 million worth of Ether (ETH). This event significantly impacted the Ethereum ecosystem and led to a hard fork to recover the stolen funds.\nLendf.Me\n Exploit (2020):\n \nLendf.Me\n, a decentralized lending protocol, fell victim to a reentrancy attack in April 2020. The attacker leveraged a vulnerability in the way ERC-777 tokens (a type of Ethereum token with additional functionalities) were handled. This resulted in the loss of over $25 million worth of cryptocurrency.\nCream Finance Attack (2021):\n Cream Finance, a DeFi (decentralized finance) platform, suffered a series of attacks throughout 2021. One of these attacks, in September 2021, exploited a reentrancy vulnerability, leading to the theft of approximately $18.8 million in various cryptocurrencies.\n\n\nConclusion\n\n\nReentrancy attack has been a reason for exploitation of a huge amount of crypto and is the most common vulnerability in smart contracts. But this common vulnerability still exists in smart contracts and needs to be taken care of before the contract is deployed. There are inbuilt contracts from Openzepplin which exists today to help prevent these vulnerabilities. But as a solidity developer, you should be aware of common vulnerabilities.\n\n\nTry it out, ask us questions, and tell us how it went by tagging Metaschool on Social Media.\n\n\nFollow us on\n\u00a0\u2013\n\n\nTwitter \u2013\u00a0\nhttps://twitter.com/0xmetaschool\n\n\nLinkedIn \u2013\u00a0\nhttps://www.linkedin.com/company/0xmetaschool/\n\n"
    }
}