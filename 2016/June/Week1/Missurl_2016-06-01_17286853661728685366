{
    "threat_intelligence": {
        "url": "https://hackernoon.com/smart-contract-security-part-1-reentrancy-attacks-ddb3b2429302",
        "timestamp": "2016-06-01 00:00:00",
        "original_content": "Ethereum is one of the two largest cryptocurrencies right now, with a market cap of more than 60B dollars, processing 600K+ transactions per day. Using its Turing-Complete high-level programming language, Solidity, people are building smart contracts daily. There is already a large amount of applications running on the main network, from Token systems to wallets, hedging contracts, lotteries etc. Where there is money involved there are malicious actors.\n\n\n\n\nWhen a smart contract is deployed on the blockchain, it can never be altered again. This is why they are called \u201cimmutable\u201d. It is therefore extremely important to follow some basic security guidelines, do tons of testing before deploying and keeping the code as simple as possible.\n\n\nIn this series of articles I will try to explain some of the common vulnerabilities as I understand them and provide material, written by experts, for further studying.\n\n\nLet\u2019s first explain shortly how the \ncall\n function works. It is used to invoke a function, of another or the same contract, and transfer data and/or ether to it. It does not throw in case of an exception, it just returns \nfalse -\n otherwise returns \ntrue\n. \nCall\n triggers code execution and spends all the available gas for this purpose. This is where the problems begin as you will see later. Lets see how this works in practice\n\n\nI will use this simple Logger contract that contains a \nlogNum\n function which can be called by anyone. It takes an integer as an argument and maps/logs that number to your address using the \n_myNum\n mapping.\n\n\n\n\nNow suppose, that inside another contract I am building, I want to call this \nlogNum\n function and pass the number 10 to it. The syntax, using \ncall\n is:\n\n\naddressOfLogger.call(bytes4(sha3(\"logNum(uint256)\")), 10);\n\n\nThe 4 bytes inside the call method are used as a \nhash signature\n, which is used to point to the function we want to invoke. Practically, the first 4 bytes of the \nlogNum\n\u2019s hash match the hash of the call method and this function is called with the value 10 as an argument.\n\n\nYou can also send ether using the \ncall\n method. Lets use this simple Test contract to understand how. This one consists of two functions. The \nbuy\n function that is payable(accepts wei) and the \nfallback\n method.\n\n\n\n\nYou can interact with the \nbuy\n function from your own contract and transfer money to it, using the \ncall\n method, in almost the identical way we used it above. You just need to know the address of the Test contract. In this case you write:\n\n\naddressOfTest.call.value(amount)(bytes4(sha3(\"buy()\")));\n\n\nIf you wanted to transfer the ether to the \nfallback\n method you would write:\n\n\naddressOfTest.call.value(amount)(); //the parenthesis is empty\n\n\nThe fact that the \ncall\n method triggers code execution without a gas limit, \nunless you set one manually\n, makes it \nvulnerable to reentrancy attacks\n. This has led to huge financial losses in the past(DAO hack~70M $/ June 2016).\n\n\n\n\nReentrancy Attack\n\n\nThe following contract will be used to analyse this attack in detail. Imagine that it represents a wallet contract. You can send ether and store it there. The mapping balanceOf maps your address to the amount of ether you have stored in this wallet(in wei). The withdrawEquity function allows anyone using the wallet to withdraw their balance. This is where the \nBAD\n stuff happens.\n\n\n\n\nAs we saw earlier the \ncall\n statement inside \nwithdrawEquity\n invokes the \nmsg.sender\u2019s\n fallback function in order to send wei to him. The thing is\u2026it has no gas limitation, so any code inside this fallback function will be executed(as long as there is remaining gas for this purpose). Now a malicious actor can deploy a smart contract looking like this:\n\n\n\n\nLets examine this one. There is a private address \n_owner\n initialised inside the constructor. It is initiated inside the constructor and indicates who the owner of the contract is/who deployed it. The other address is the address of the vulnerable wallet(here for simplicity I used 0x0). Then, an instance of that contract is created and we are almost done.\n\n\nIf the bad guy sent wei, from the Malicious contract to the wallet and then called his \nfallback\n function, strange things would happen. When he calls the function, the \nwithdrawEquity\n function is invoked(line15).\n\n\nInside the withdrawEquity, into the require statement the \ncall\n method contains an empty signature with no gas limitations\n\n\nmsg.sender.call.value(x)()\n\n\nso it invokes the fallback method of the Malicious contract\n unless it fails(in case of failure the transaction is reverted).\n\n\nvul.withdrawEquity();\n\n\nThis is a call to the withdrawEquity function \nagain\n. Practically the bad guy\u2019s contract receives the ether and then calls the withdrawEquity() again. Since the state of the first contract has not changed (the attacker\u2019s balance is not set to zero yet) he gets paid again. And again, and again\u2026 until the execution runs out of gas or the call stack limit is reached.\n\n\n\n\nSo if the withdrawEquity gets called lets say 10 times, only the last one will fail because call doesn\u2019t propagate an exception only true/false, so only the executions of the last call will be reverted. This means that the malicious guy got paid x9 times rather than 1. To put this into perspective someone could initially store 2 ether and get 18 ether back. Then do the same with the 18 ether and so on\u2026\n\n\nHow to avoid\u00a0This\n\n\n\n\ntransfer()\n and \nsend()\n are safe against reentrancy attacks since they limit the code execution to 2300 gas, currently enough to log and event.\n\n\nIf you can\u2019t avoid using \ncall()\n always do the internal work (eg change balances) before using the external call.\n\n\nIn general, keep in mind that any function running external code is a threat.\n\n\n\n\nDocumentation and sources for further\u00a0Studying\n\n\n\n\nSolidity Documentation\n\n\nConsensys Best Practices for Smart Contract Security\n\n\nVitalik on security\n\n\nA survey of attacks on Ethereum smart contracts\n\n\nHow to write Safe Smart Contracts-chriseth\n\n\nPrivacy-Preserving Smart Contracts\n\n"
    }
}