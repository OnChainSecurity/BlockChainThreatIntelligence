{
    "threat_intelligence": {
        "url": "https://www.makeuseof.com/what-is-reentrancy-attack/",
        "timestamp": "2016-06-17 00:00:00",
        "original_content": "\n\nSome of the biggest hacks in the blockchain industry, where millions of dollars worth of cryptocurrency tokens got stolen, resulted from reentrancy attacks. While these hacks have becomes less common in recent years, they still pose a significant threat to blockchain applications and users.\n\n\nSo what precisely are reentrancy attacks? How are they deployed? And are there any measures developers can take to prevent them from happening?\n \n\n                        What Is a Reentrancy Attack?\n               \n\n\nA reentrancy attack occurs when \na vulnerable smart contract function\n makes an external call to a malicious contract, temporarily giving up control of the transaction flow. The malicious contract then repeatedly calls the original smart contract function before it finishes executing while draining its funds.\n\n\nEssentially, a withdrawal transaction on the Ethereum blockchain follows a three-step cycle: balance confirmation, remittance, and balance update. If a cybercriminal can hijack the cycle before the balance update, they can repeatedly withdraw funds until a wallet is drained.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImage Credit: \nEtherscan\n\n\n\n\n\n\n\n\nOne of the most infamous blockchain hacks, the Ethereum DAO hack, as covered by \nCoindesk\n, was a reentrancy attack that led to a loss of over $60 million worth of eth and fundamentally changed the course of the second largest cryptocurrency.\n \n\n                        How Does a Reentrancy Attack Work?\n               \n\n\nImagine a bank in your hometown where virtuous locals keep their money; its total liquidity is $1 million. However, the bank has a flawed accounting system\u2014staffers wait until the evening to update bank balances.\n\n\nYour investor friend visits the town and discovers the accounting flaw. He creates an account and deposits $100,000. A day later, he withdraws $100,000. After one hour, he makes another attempt of withdrawing $100,000. Since the bank has not updated his balance, it still reads $100,000. So he gets the money. He does this repeatedly until there's no money left. Staffers only realize there's no money when they balance the books in the evening.\n\n\nIn the context of a smart contract, the process goes as follows:\n \n\n\n\n                                        A cybercriminal identifies a smart contract \"X\" with a vulnerability.\n                        \n\n\n\n                                        The attacker initiates a legitimate transaction to the target contract, X, to send funds to a malicious contract, \"Y.\" During execution, Y calls the vulnerable function in X.\n                        \n\n\n\n                                        X's contract execution is paused or delayed as the contract waits for interaction with the external event\n                        \n\n\n\n                                        While the execution is paused, the attacker repeatedly calls the same vulnerable function in X, again triggering its execution as many times as possible\n                        \n\n\n\n                                        With each reentry, the contract's state is manipulated, allowing the attacker to drain funds from X to Y\n                        \n\n\n\n                                        Once funds have been exhausted, reentry stops, X's delayed execution finally completes, and the contract's state is updated based on the last reentry.\n                        \n\n\n\n\nGenerally, the attacker successfully exploits the reentrancy vulnerability to their advantage, stealing funds from the contract.\n \n\n                        An Example of a Reentrancy Attack\n               \n\n\nSo how exactly might a reentrancy attack technically occur when deployed? Here's a hypothetical smart contract with a reentrancy gateway. We'll use axiomatic naming to make it easier to follow along.\n \n        \npragma\n\u00a0\nsolidity\n ^0\n.8\n.0\n;\ncontract VulnerableContract {\n\u00a0\u00a0\u00a0\u00a0mapping(\naddress\n =>\n uint256) private balances;\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\ndeposit\n(\n) \npublic\n\u00a0\npayable\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0balances[msg.sender] += msg.value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nwithdraw\n(\nuint256 amount\n) \npublic\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(amount <= balances[msg.sender], \n\"Insufficient balance\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(bool success, ) = msg.sender.call{\nvalue\n: amount}(\n\"\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(success, \n\"Transfer failed\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0balances[msg.sender] -= amount;\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n    \n\n\nThe \nVulnerableContract\n lets users deposit eth into the contract using the \ndeposit\n function. Users can then withdraw their deposited eth using the \nwithdraw\n function. However, there's a reentrancy vulnerability in the \nwithdraw\n function. When a user withdraws, the contract transfers the requested amount to the user's address before updating the balance, creating an opportunity for an attacker to exploit.\n\n\nNow, here's what an attacker's smart contract would look like.\n \n        \npragma\n\u00a0\nsolidity\n ^0\n.8\n.0\n;\ninterface\n\u00a0\nVulnerableContractInterface\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nwithdraw\n(uint256 amount)\n\u00a0\nexternal\n;\n}\ncontract AttackerContract {\n\u00a0\u00a0\u00a0\u00a0VulnerableContractInterface \nprivate\n vulnerableContract;\n\u00a0\u00a0\u00a0\u00a0address \nprivate\n targetAddress;\n\u00a0\u00a0\u00a0\u00a0\nconstructor\n(address _vulnerableContractAddress) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vulnerableContract = VulnerableContractInterface(_vulnerableContractAddress);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetAddress = msg.sender;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nattack\n(\n) \npublic\n\u00a0\npayable\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nvulnerableContract\n.deposit\n{\nvalue\n: msg.value}();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nvulnerableContract\n.withdraw\n(\nmsg\n.value\n);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0receive() external payable {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (address(vulnerableContract).balance >= 1 ether) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nvulnerableContract\n.withdraw\n(1 \nether\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nwithdrawStolenFunds\n(\n) \npublic\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(msg.sender == targetAddress, \n\"Unauthorized\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(bool success, ) = targetAddress.call{\nvalue\n: address(this).balance}(\n\"\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(success, \n\"Transfer failed\"\n);\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n    \n\n\nWhen the attack is launched:\n \n\n\n\n                                        The \nAttackerContract\n takes the address of the \nVulnerableContract\n in its constructor and stores it in the \nvulnerableContract\n variable.\n                        \n\n\n\n                                        The \nattack\n function is called by the attacker, depositing some eth into the \nVulnerableContract\n using the \ndeposit\n function and then immediately calling the \nwithdraw\n function of the \nVulnerableContract\n.\n                        \n\n\n\n                                        The \nwithdraw\n function in the \nVulnerableContract\n transfers the requested amount of eth to the attacker's \nAttackerContract\n before updating the balance, but since the attacker's contract is paused during the external call, the function is not yet complete.\n                        \n\n\n\n                                        The \nreceive\n function in the \nAttackerContract\n is triggered because the \nVulnerableContract\n sent eth to this contract during the external call.\n                        \n\n\n\n                                        The receive function checks if the \nAttackerContract\n balance is at least 1 ether (the amount to withdraw), then it reenters the \nVulnerableContract\n by calling its \nwithdraw\n function again.\n                        \n\n\n\n                                        Steps three to five repeat until the \nVulnerableContract\n runs out of funds and the attacker's contract accumulates a substantial amount of eth.\n                        \n\n\n\n                                        Finally, the attacker can call the \nwithdrawStolenFunds\n function in the \nAttackerContract\n to steal all the funds accumulated in their contract.\n                        \n\n\n\n\nThe attack can happen very fast, depending on the network's performance. When involving complex smart contracts such as the DAO Hack, which led to the hard fork of Ethereum into \nEthereum and Ethereum Classic\n, the attack happens over several hours.\n \n\n                        How to Prevent a Reentrancy Attack\n               \n\n\nTo prevent a reentrancy attack, we need to modify the vulnerable smart contract to follow the best practices for secure smart contract development. In this case, we should implement the \"checks-effects-interactions\" pattern as in the code below.\n \n        \npragma\n\u00a0\nsolidity\n ^0\n.8\n.0\n;\ncontract SecureContract {\n\u00a0\u00a0\u00a0\u00a0mapping(\naddress\n =>\n uint256) private balances;\n\u00a0\u00a0\u00a0\u00a0mapping(\naddress\n =>\n bool) private isLocked;\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\ndeposit\n(\n) \npublic\n\u00a0\npayable\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0balances[msg.sender] += msg.value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nwithdraw\n(\nuint256 amount\n) \npublic\n\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(amount <= balances[msg.sender], \n\"Insufficient balance\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(!isLocked[msg.sender], \n\"Withdrawal in progress\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isLocked[msg.sender] = \ntrue\n;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0balances[msg.sender] -= amount;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Interact \nwith\n the \nexternal\n contract \nafter\n the state \nchange\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(bool success, ) = msg.sender.call{\nvalue\n: amount}(\n\"\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(success, \n\"Transfer failed\"\n);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isLocked[msg.sender] = \nfalse\n;\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n    \n\n\nIn this fixed version, we've introduced an \nisLocked\n mapping to track whether a particular account is in the process of a withdrawal. When a user initiates a withdrawal, the contract checks if their account is locked (\n!isLocked[msg.sender]\n), indicating that no other withdrawal from the same account is currently in progress.\n\n\nIf the account isn't locked, the contract continues with the state change and external interaction. After the state change and external interaction, the account is unlocked again, allowing future withdrawals.\n \n\n                        Types of Reentrancy Attacks\n               \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImage Credit: Ivan Radic/\nFlickr\n\n\n\n\n\n\n\n\nGenerally, there are three main types of reentrancy attacks based on their nature of exploitation.\n \n\n\n\n\nSingle reentrancy attack:\n In this case, the vulnerable function that the attacker repeatedly calls is the same one that's susceptible to the reentrancy gateway. The attack above is an example of a single reentrancy attack, which can be easily prevented by implementing proper checks and locks in code.\n                        \n\n\n\n\nCross-function attack:\n In this scenario, an attacker leverages a vulnerable function to call a different function within the same contract that shares a state with the vulnerable one. The second function, called by the attacker, has some desirable effect, making it more attractive for exploitation. This attack is more complex and harder to detect, so strict checks and locks across interconnected functions are needed to mitigate it.\n                        \n\n\n\n\nCross-contract attack:\n This attack occurs when an external contract interacts with a vulnerable contract. During this interaction, the vulnerable contract's state is called in the external contract before it's fully updated. It usually happens when multiple contracts share the same variable and some update the shared variable insecurely. Secure communication protocols between contracts and periodic \nsmart contract audits\n must be implemented to mitigate this attack.\n                        \n\n\n\n\nReentrancy attacks can manifest in different forms and so require specific measures to prevent each.\n \n\n                        Staying Safe From Reentrancy Attacks\n               \n\n\nReentrancy attacks have caused substantial financial losses and undermined trust in blockchain applications. To protect contracts, developers must adopt best practices diligently to avoid reentrancy vulnerabilities.\n\n\nThey should also implement secure withdrawal patterns, use trusted libraries, and conduct thorough audits to fortify the smart contract's defense further. Of course, staying informed about emerging threats and being proactive with security efforts can ensure they uphold blockchain ecosystems' integrity too.\n "
    }
}