{
    "threat_intelligence": {
        "url": "https://dl.acm.org/doi/fullHtml/10.1145/3407230",
        "timestamp": "2016-06-17 00:00:00",
        "original_content": "\n\n\n\nBlockchains are relatively new [\n13\n, \n36\n] and there are countless [\n12\n, \n67\n] news stories of people losing money through compromises in the components of blockchain ecosystems. Blockchain technologies are not invulnerable and have actually many known vulnerabilities [\n10\n, \n49\n, \n50\n], just as with any software. This article describes the most common components of a blockchain ecosystem and the vulnerabilities that they can contain. The greater number of features a blockchain offers, the larger the attack surface becomes.\n\n\nEthereum [\n11\n], for example, has a virtual machine called the EVM, which executes EVM bytecode. This virtual machine executes smart contracts in a sandboxed environment. The EVM specification defines over 140 different instructions that smart contract programmers can use. EtherVM [\n63\n] provides a reference for these instructions. There have been many real-world cases of decentralized applications, also known as DApps [\n39\n], leveraging vulnerable smart contracts that resulted in stolen funds [\n66\n]. It is also worth noting that vulnerabilities can exist in any component of a blockchain ecosystem, not just smart contracts.\n\n\n\n\n\n\nA blockchain ecosystem contains multiple components. There is usually a \ncore blockchain\n software that consists of client software such as Go Ethereum [\n4\n] or Parity [\n59\n] in the case of Ethereum.\n\n\nEach peer participating in a given blockchain network runs this client software, and is sometimes called a node. Blockchain systems usually contain a \nwallet\n, which can be implemented in software or hardware. A node and software wallet may be bundled together in the same software. Notable hardware wallets include the Ledger Nano X [\n33\n] and the Trezor Model T [\n62\n].\n\n\n \nCryptocurrency exchanges\n are composed of web applications and public REST APIs that can be used to programatically exchange one cryptocurrency for another. A cryptocurrency is a digital currency that is secured by cryptography. Exchanges can use hardware security modules to secure private keys. These exchanges frequently support over a hundred different cryptocurrencies. An exchange requires at least one blockchain node for each supported cryptocurrency. These nodes allow the exchange to perform transactions across various cryptocurrencies, and monitor transactions done on the blockchain to know when it has received cryptocurrencies.\n\n\nSome blockchains support \nsmart contracts\n: arbitrary code run by multiple nodes of a blockchain network. These contracts are a basic building block for creating decentralized applications. DApps are usually composed of a frontend application, which can be a web application, a desktop application or a mobile application and one or more smart contracts. These smart contracts contain methods that the frontend application can call\u2014 by sending a transaction to the contract's address\u2014 to perform actions such as reading or writing data to the blockchain.\n\n\nLast, \ne-commerce websites\n that want to accept cryptocurrency payments\u2014for example, in Bitcoin [\n36\n]\u2014also need a solution that provides this feature. They can either use existing solutions [\n7\n, \n19\n] or make their own. In either case, such a solution requires the use of a blockchain node for each cryptocurrency to accept payments properly. All these components present in a blockchain ecosystem can add up and create a large attack surface.\n\n\n\n\n\n\nThere are many known vulnerabilities in blockchain ecosystems. This field note focuses on smart contracts and core blockchain vulnerabilities.\n\n\n\n\n\n\n \n3.1.1\n \nConsensus Mechanism Manipulation.\n Blockchain consensus mechanisms such as proof-of-work or proof-of-stake have been subject to attacks [\n38\n]. The 51% attack is a well-known attack on proof-of-work blockchains whereby an attacker who controls the majority of the network's computing resources is able to discard blocks mined by anyone else, giving priority to his own blocks. Note that this attack does not allow an attacker to craft fake transactions or create money out of thin air. It will, however let them perform double spending. In practice, such attacks are extremely costly on blockchain networks with high hashing rates [\n23\n], such as Bitcoin, and therefore, quite rare. One possible prevention technique is to perform formal verification [\n61\n] of the consensus mechanism.\n\n\n\n\n\n\n \n3.1.2\n \nUnderlying Cryptosystem Vulnerabilities.\n Blockchain wallets usually work with a public and private key pair for signature and are as secure as the underlying cryptosystem they use. The public-key algorithm (ECDSA [\n32\n], EdDSA [\n6\n], Schnorr [\n48\n], ElGamal [\n24\n]) used for these keys have known attacks [\n8\n, \n27\n, \n29\n, \n35\n, \n45\n, \n47\n] that might be applied in some cases. There are real-world use cases [\n10\n, \n22\n]. To reduce the attack surface, it is necessary to use a library that implements the required cryptosystem with side-channel attack protections. One example is the mbedTLS [\n34\n] library, which includes side-channel attack protections for deterministic ECDSA signatures.\n\n\n\n\n\n\n \n3.1.3\n \nImproper Blockchain Magic Validation.\n Some blockchains have multiple forks, such as a main network and one or more test networks. A blockchain's magic value is used to uniquely identify a chain, thus binding transactions to a specific chain. Node software must check whether received transactions have the expected magic value, attributable to the current chain. If there is no such check, then an attacker can replay a transaction originally performed on another chain, thus creating transactions meant for another chain.\n\n\n\n\n\n\n \n3.1.4\n \nImproper Transaction Nonce Validation.\n Each transaction must be unique within a given blockchain. A transaction nonce is used by node implementations to enforce uniqueness. Poor node implementations might allow transactions to be replayed on the same chain. Such a vulnerable implementation may be exploited by an attacker that receives a transaction of amount \nN\nN\n, which can be replayed over and over until the source wallet does not have enough funds to perform the transaction anymore. A mitigation is to verify the uniqueness of all received transactions.\n\n\n\n\n\n\n \n3.1.5\n \nDenial of Service.\n Proof-of-work blockchains with a block target [\n60\n] that automatically adjusts, may be vulnerable to a denial of service attack. Indeed, if no minimum target is defined, an uncaught floating-point underflow may occur and the block target may be rounded to zero, thus making new blocks impossible to mine and rendering the blockchain useless. Some DApps may become so popular [\n65\n] that congestion may happen on the underlying blockchain. One way to avoid network congestion, is to use a smart contract platform that features high throughput [\n68\n].\n\n\n\n\n\n\n \n3.1.6\n \nPublic-key and Address Mismatch.\n A blockchain wallet's public key can usually be derived from the wallet's address. However, some implementations [\n3\n] truncate the public key to derive the address. If addresses are not bound to a specific key pair, then this can become a problem, because multiple key pairs exist with the same wallet address. In this case, it may be possible to brute force and find another key pair that controls a target wallet in a reasonable amount of time depending on the address length. To prevent such attacks, one should ensure that each unique wallet address is bound to a single key-pair.\n\n\n\n\n\n\n\n\nAs of July 2020, Ethereum is still considered the most popular DApp platform [\n56\n]. Most DApps use Ethereum and the platform has the highest number of daily active users and of smart contracts. After Ethereum, EOSIO [\n25\n] and Steem [\n58\n] are the most widely used. Ethereum's popularity most likely comes from the fact that it was the first blockchain to offer quasi-Turing complete (except for the gas limit) smart contracts with a low enough latency (sustained 13 s average block time) acceptable for most decentralized applications. Ethereum smart contracts are usually written in a high-level language such as Solidity [\n55\n] or Vyper [\n64\n]. Both languages are compiled to EVM bytecode. There are multiple other blockchains [\n1\n, \n14\n, \n25\n, \n31\n, \n37\n, \n57\n] supporting smart contracts nowadays. The rest of this section enumerates known smart contract vulnerabilities that may appear in any of the aforementioned smart contract platforms, but uses Ethereum to provide examples [\n20\n, \n28\n, \n54\n].\n\n\n\n\n \n3.2.1\n \nReentrancy.\n A reentrancy vulnerability [\n12\n] can be exploited when a contract function \nF\n whose purpose is to withdraw funds, synchronously calls another untrusted contract's default function \nD\n. Indeed, D can call F again before F updates its state. If F does not update its state before performing the external call to D, then it may be vulnerable (Listing \n1\n). Indeed, a malicious external contract may call the withdraw() function, which will call the malicious contract's default function, which can call the withdraw() function again before the balance is updated, thus withdrawing more funds than it should be able to.\n\n\n \n \n\n\n \nListing 1. Reentrancy vulnerable withdraw() function. Lines 3 and 4 should be swapped to fix the vulnerability.\nListing 1. Reentrancy vulnerable withdraw() function. Lines 3 and 4 should be swapped to fix the vulnerability.\n \n\n\nIn 2016, a smart contract part of the DAO [\n12\n] was found to be vulnerable to reentrancy and was subject to an attack that led to the loss of 3.6 million ETH or about \n$\n50 million USD at the time. This very event caused an Ethereum hard fork. The original Ethereum chain was renamed to Ethereum Classic [\n18\n], and the new fork took the original name of Ethereum.\n\n\n\n\n\n\n \n3.2.2\n \nArithmetic Issues.\n The Solidity smart contract language does not catch integer overflows by default. If uncaught, then overflows can lead to unexpected behavior (Listing \n2\n). Unsigned integers are represented with 256 bits in Solidity. Therefore, an arithmetic operation on an unsigned integer that causes the result to be greater than \n2\n256\n\u2212\n1\n2\n256\n\u2212\n1\n or less than 0 may be exploited [\n5\n, \n42\n, \n43\n].\n\n\n \n \n\n\n \nListing 2. Integer overflow vulnerable withdraw() function. What happens if x is large?\nListing 2. Integer overflow vulnerable withdraw() function. What happens if x is large?\n \n\n\nOne solution to this problem is to use secure functions provided by an external smart contract library such as OpenZeppelin [\n40\n]\u2019s SafeMath functions or to use a language that has a built-in protection against overflows such as Vyper [\n64\n].\n\n\n\n\n\n\n \n3.2.3\n \nUnprotected SELFDESTRUCT.\n The SELFDESTRUCT EVM instruction makes a smart contract unusable and sends the contract's balance to the address given in parameter. If a contract has a self-destruction functionality, then it must be protected with care [\n67\n], and it must be ensured that only authorized users can call the code. As a general rule, the use of \nselfdestruct\n should be avoided if possible. If it cannot be avoided, then it must be used with extreme care.\n\n\n\n\n\n\n \n3.2.4\n \nVisibility Issues.\n It is a best practice to explicitly mark function visibility for all functions and variables. The default visibility is public for functions in Solidity. If a function's visibility is not explicitly marked, then a developer can easily conclude that the function is private while it is actually public, causing unexpected behavior such as letting an attacker call supposedly private code.\n\n\nSimilarly, any data that is written to the EVM storage area is visible by anyone, because it is stored on the blockchain. Any call to another contract, including function arguments, is publicly visible as well, because it creates a transaction. Secrets should not be stored in clear text in the EVM storage.\n\n\n\n\n\n\n \n3.2.5\n \nWeak Randomness.\n Generating random numbers in smart contracts is a hard problem [\n30\n, \n44\n]. Smart contract developers who need random numbers may be tempted to use predictable chain data as a source of randomness. Such chain data include the block number, the block hash and the block timestamp. All of these values can actually be manipulated by block miners and should not be used for generating random numbers. The SmartBillions [\n53\n] contract is a famous example of poor block hash usage, which allowed attackers to exploit the contract and withdraw all the lottery money. One possible solution is to use a secure random number generator for smart contracts such as RANDAO [\n44\n] or RBGC [\n16\n].\n\n\n\n\n\n\n \n3.2.6\n \nTransaction Order Dependence (Front Running).\n Transaction order dependence may lead to unfair remuneration [\n9\n, \n52\n] in the case of smart contracts. Imagine that a smart contract implements a quiz that asks players to solve a problem. The first player that sends the correct solution to the problem can claim the prize (the contract's balance). Now let us say Alice worked day and night for a month and finally finds the solution to the problem. She makes a transaction to send her solution. An attacker sees Alice's solution in the transaction pool and immediately sends the same solution but with higher transaction fees. The attacker's transaction is selected first by miners because of the higher fees paid by the attacker, and that transaction gets inserted in a block before Alice's. The attacker is, therefore, the first to solve the problem and can claim the prize instead of Alice. To prevent this attack, it is possible to use a commit-reveal commitment scheme [\n26\n] that allows players to securely disclose the solution to the problem.\n\n\n\n\n\n\n\n\nThere are many blockchain security education tools. FumbleChain [\n51\n] contains tutorials and challenges based on a purposefully vulnerable blockchain written in Python, allowing developers to learn about base blockchain security. Ethernaut [\n41\n] is a wargame focused on Ethereum smart contract vulnerabilities in Solidity. There are several good articles discussing blockchain security [\n2\n, \n17\n, \n46\n] as well.\n\n\n\n\n\n\n\n\nSelected vulnerabilities associated with core blockchain and smart contracts were detailed. The way these vulnerabilities can be exploited and mitigation techniques to prevent such attacks were presented. Blockchains are not invulnerable, and one should use a mix of dedicated tools [\n15\n, \n21\n] for smart contracts and general software analysis tools, such as static code analyzers for core blockchain, to automatically detect simple issues. Good practices, such as software testing, also apply to blockchain development. Thorough code reviews or third party security audits should be performed to maximize detection of more complex vulnerabilities.\n\n\n\n\n\n\n\n\nPublication History: Received December 2019; revised January 2020; accepted June 2020\n\n\n\n"
    }
}