{
    "threat_intelligence": {
        "url": "https://www.apriorit.com/dev-blog/562-suspicious-ethereum-transactions",
        "timestamp": "2018-07-09 00:00:00",
        "original_content": "\n\nThe more popular cryptocurrency and blockchain technology become, the more they draw the attention of hackers. According to recent \nresearch by Carbon Black\n, a total of $1.1 billion in cryptocurrencies was stolen in the first half of 2018. In approximately 35 percent of cases, the main targets of hackers were regular users and private businesses. And a significant part of these attacks were related to hacking smart contracts or stealing private keys from user accounts.\n\n\nOnce attackers get ahold of a legitimate user account\u2019s private keys or hack a smart contract, they can get access to all the funds that the compromised account has access to. In this post, we take a detailed look at how to track suspicious transactions on the blockchain and prevent hackers from stealing your funds. To make this overview more informative, we\u2019ll focus on detecting suspicious activity on the Ethereum blockchain.\n\n\nProtecting your cryptocurrency\n\n\nThere are different \ntypes of attacks in blockchain\n\u00a0on different networks and digital currency exchanges, which became common these days. The majority of cryptocurrency-related attacks proceed in a similar manner, illustrated in Figure 1 below.\n\n\n \n\u00a0\n \nFigure 1. The scheme of a typical cryptocurrency-related attack\n \n\n\nThe process usually consists of three steps:\n\n\n\n\nA hacker finds a vulnerability in a victim\u2019s computer system or in one of their smart contracts and exploits it.\n\n\nAfter exploiting the vulnerability, the hacker gets access to all the victim\u2019s funds.\n\n\nThe hacker takes the money and disappears.\n\n\n\n\nThere are a couple of ways to prevent steps 1 and 2 from happening. First, you should follow commonly used security best practices when developing a smart contract. Second, you should keep the majority of your funds in a secure offline storage device, like a cold wallet.\n\n\nWhile these preventive measures may lessen the chances of hackers getting ahold of your cryptocurrency, they can\u2019t guarantee a high level of security for at least three reasons:\n\n\n\n\nYou can\u2019t permanently store all of your cryptocurrency in offline storage. At least some part of your funds (the part that\u2019s actively used for trading) needs to be available online and accessed quickly.\n\n\nAny smart contract can have zero-day vulnerabilities that haven\u2019t been fixed yet and, therefore, may be exploited by hackers.\n\n\nSometimes, tools like digital wallets or blockchain clients may introduce accidental vulnerabilities in software updates. Theoretically, these vulnerabilities can also be exploited by hackers.\n\n\n\n\nIt\u2019s nearly impossible to fully protect your cryptocurrency from theft and prevent hackers from getting access to your funds. The good news is that there might be an effective way to not let the attackers leave with your money.\n\n\nTracking suspicious transactions to catch a thief\n\n\nAs you probably know, one of the signature features of the majority of blockchain networks is the full publicity and transparency of every single transaction. This means that even if hackers manage to get access to your account, you can find the details of every single transaction they make in the blockchain. This gives you a chance to track suspicious transactions and catch the thieves before they get away with your money.\n\n\nFurthermore, it\u2019s just as trivial to monitor new transactions as they appear and detect any suspicious activity related to your funds. So even if a hack happens, you can track the culprit\u2019s every move and action while also working with the community to prevent the laundering of any stolen currency.\n\n\nSometimes, if a smart contract allows it, you can simply block all of your stolen tokens and stop the attack altogether. Earlier in 2018, Bancor used this opportunity when their BNT tokens \ngot hacked\n.\n\n\n\n\nHere is the latest update on the recent security breach: \npic.twitter.com/JroypFvBri\n\n\n\u2014 Bancor (@Bancor) \nJuly 9, 2018\n\n\n\n\nGenerally, there are two ways you can monitor transactions on a blockchain:\n\n\n\n\nManually, by looking at particular transactions\n\n\nAutomatically, by using the blockchain network\u2019s APIs\n\n\n\n\nNext, we take a more detailed look at each of these approaches.\n\n\nManual transaction monitoring\n\n\nIf you wanted to read several particular transactions from a personal wallet or a small-scale contract, the easiest way would be to do it manually. Just remember that in order to convert block data to a human-readable format, you need to use a special tool called a block explorer.\n\n\nA block explorer allows you to explore the details of each transaction and follow any transfers of any currency. Note that there are specific block explorers for every major cryptocurrency. Here are some examples for \nBitcoin Core\n, \nEthereum\n, \nRipple\n, \nBitcoin Cash\n, \nLitecoin\n, and \nEOS\n. It\u2019s also noteworthy that the Ethereum block explorer supports ERC20 tokens as well.\n\n\nWhile this approach works well for monitoring personal wallets and small-scale smart contracts from time to time, it\u2019s not suitable for full-scale 24/7 monitoring. If you need to monitor a large number of wallets and smart contracts on a regular basis, then it\u2019s better to use automatic monitoring.\n\n\nAutomatic transaction monitoring\n\n\nTo access transaction data automatically, you need to use a network\u2019s Application Programming Interface, or API. Every network has its own API for accessing blockchain data. Since our focus in this article is on the Ethereum network, we\u2019ll describe how to work with this network\u2019s API in particular.\n\n\nFor accessing transaction data, Ethereum uses an API called web3. As of today, there are two officially supported implementations of the web3 API: in JavaScript and in Python. Let\u2019s look closer at each of these implementations.\n\n\nJavaScript web3 API implementation\n\n\nThe JavaScript implementation of the web3 API works best for creating web applications that use blockchain technology. We can start with a simple JavaScript command that lists transactions in a given block. You can follow along with any JavaScript sandbox, such as \njsfiddle\n. You\u2019ll also need the \nMetamask\n extension installed and enabled in your browser in order to have access to web3 functions. No existing Ethereum account is required, as Metamask can create one for you, and you don\u2019t need any ether either. Each of the following examples uses the main Ethereum network.\n\n\nHere\u2019s a \nfunction\n that can be used to get a single transaction:\n\n\nJavaScript\nweb3\n.\neth\n.\ngetTransactionFromBlock\n(\nblockHashStringOrNumber\n, \ntransactionIndexNumberInBlock\n[, \ncallbackFunction\n])\n\n\nThis function contains two special values that can be used instead of the block number in the first parameter: \nlatest\n and \npending\n. The \nlatest\n block refers to the most recently mined block. The \npending\n block contains every transaction that hasn\u2019t been confirmed yet (e.g. is waiting to be mined). To list all transactions from a block, you need to loop over the index of each transaction.\n\n\nThere\u2019s another \nfunction\n that allows you to get the total number of transactions in any given block:\n\n\nJavaScript\nvar\n \ntransactionCount\n \n=\n \nweb3\n.\neth\n.\ngetBlockTransactionCount\n(\nblockHashStringOrNumber\n[, \ncallbackFunction\n])\n\n\nNote that the Metamask extension doesn\u2019t support synchronous requests, so in both of these functions you\u2019ll have to provide the callback function to retrieve data asynchronously.\n\n\nHere\u2019s a sample script that lists every transaction in the latest block: (\ntry it in jsfiddle\n)\n\n\nJavaScript\nvar\n \ntxCount\n \n=\n \nweb3\n.\neth\n.\ngetBlockTransactionCount\n(\n'latest'\n, \nfunction\n(\nerror\n, \ntxCount\n) {\n\n\n    \nif\n (\n!\nerror\n) {\n\n\n      \nconsole\n.\nlog\n(\n'Latest block contains '\n \n+\n \ntxCount\n \n+\n \n' transactions:'\n);\n\n\n      \nfor\n (\nvar\n \ni\n \n=\n \n0\n; \ni\n \n<\n \ntxCount\n; \ni\n++\n) {\n\n\n        \nweb3\n.\neth\n.\ngetTransactionFromBlock\n(\n'latest'\n, \ni\n, \nfunction\n(\nerr\n, \ntransaction\n) {\n\n\n          \nif\n (\n!\nerr\n) {\n\n\n            \nconsole\n.\nlog\n(\ntransaction\n);\n\n\n          } \nelse\n {\n\n\n            \nconsole\n.\nerror\n(\nerr\n);\n<\nbr\n>\n\n\n          }\n\n\n        });\n\n\n      }\n\n\n    } \nelse\n {\n\n\n      \nconsole\n.\nerror\n(\nerror\n);\n\n\n    }\n\n\n  });\n\n\nWhat we actually need to do, however, is to monitor transactions live and without the need to constantly execute a specific command. There\u2019s a separate function in web3 for this:\n\n\nJavaScript\nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\nfilterString\n);\n\n\n// OR\n\n\nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\nfilterOptions\n);\n\n\nDepending on the parameters used, this function can enable several filtering scenarios:\n\n\n\n\nFiltering of the most recent blocks (if the filterString is \nlatest\n)\n\n\nFiltering of the most recent pending transaction (if the filterString is \npending\n)\n\n\nFiltering of the event logs from processed transactions on the blockchain (if the filterOptions object is specified)\n\n\n\n\nMore details about this function and its parameters can be found on \nGitHub\n.\n\n\nThis function allows you to receive notifications for every new transaction created on the blockchain network. However, in order to get these notifications, you need to add a callback function to the filter:\n\n\nJavaScript\nfilter\n.\nwatch\n(\ncallbackFunction\n);\n\n\nAt this point, we can come up with a simple script that will list every new transaction to or from an address in the console: (\ntry it in jsfiddle\n)\n\n\nJavaScript\nvar\n \nwatchContract\n \n=\n \n\"0xDd9fd6b6F8f7ea932997992bbE67EabB3e316f3C\"\n.\ntoLowerCase\n();\n\n\n  \nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\n'pending'\n); \n//set up the filter\n\n\n    \n\n\n  \n//a helper function to write transaction data to the console\n\n\n  \nfunction\n \nlogTransaction\n(\ntransaction\n) {\n\n\n    \nvar\n \nlogString\n \n=\n \n\"Transaction detected\n\\n\n\"\n \n+\n\n\n      \n\"TxHash: \"\n \n+\n \ntransaction\n.\nhash\n \n+\n \n\"\n\\n\n\"\n \n+\n\n\n      \n\"From: \"\n \n+\n \ntransaction\n.\nfrom\n \n+\n \n\"\n\\n\n\"\n \n+\n\n\n      \n\"To: \"\n \n+\n \ntransaction\n.\nto\n \n+\n \n\"\n\\n\n\"\n \n+\n\n\n      \n\"Value: \"\n \n+\n \ntransaction\n.\nvalue\n \n+\n \n\"\n\\n\n\"\n \n+\n\n\n      \n\"Data: \n\\n\n\"\n \n+\n \ntransaction\n.\ninput\n \n+\n \n\"\n\\n\n\"\n;\n\n\n    \nconsole\n.\nlog\n(\nlogString\n);\n\n\n  }\n\n\n    \n\n\n  \n//a helper function to handle a transaction\n\n\n  \nfunction\n \nhandleTransaction\n(\ntransaction\n) {\n\n\n    \nif\n (\ntransaction\n.\nfrom\n \n==\n \nwatchContract\n \n||\n (\ntransaction\n.\nto\n \n!=\n \nnull\n \n&&\n \ntransaction\n.\nto\n \n==\n \nwatchContract\n)) { \n//check if the transaction is related to our contract (Note: 'to' is null for a contract creation)\n\n\n      \nlogTransaction\n(\ntransaction\n); \n//this transaction relates to our contract, so add it to the log\n\n\n    }\n\n\n    \n//ignore the rest of the transactions\n\n\n  }\n\n\n    \n\n\n  \n//subscribe to the filter\n\n\n  \nfilter\n.\nwatch\n(\nfunction\n(\nerr\n, \npendingTx\n) {\n\n\n    \nif\n (\n!\nerr\n) {\n\n\n      \nweb3\n.\neth\n.\ngetTransaction\n(\npendingTx\n, \nfunction\n(\nerr\n, \ntransaction\n) { \n//get the transaction\n\n\n        \nif\n (\n!\nerr\n \n&&\n \ntransaction\n) {\n\n\n          \nhandleTransaction\n(\ntransaction\n); \n//pass the transaction into the helper function to perform necessary checks and log events\n\n\n        }\n\n\n      });\n\n\n    } \nelse\n {\n\n\n      \nconsole\n.\nerror\n(\nerr\n); \n//in case any error happens, log the error\n\n\n    }\n\n\n  });\n\n\nWhile successfully accomplishing the main task \u2014 listing every new transaction on the blockchain \u2014 this script has several drawbacks:\n\n\n\n\nIt\u2019s difficult to run outside of a web browser\n\n\nIt doesn\u2019t capture smart contract function call data\n\n\nIt may skip internal function calls and transfers if they\u2019re made from a different smart contract\n\n\n\n\nFortunately, these problems can also be addressed with the help of JavaScript. For instance, you can use \nNode.js\n to run the script in a console. You can also write a parser for the call data or you can use the beta web3 1.0 functions like \nabi.decode\n and \neth.subscribe\n to parse the call data. Just remember that web3 1.0 is still in development and is poorly supported.\n\n\nAs for internal transactions, they aren\u2019t recorded on the blockchain. So the only way to capture internal transactions is to run a modified version of the Ethereum Virtual Machine (EVM). Modifying the EVM, however, is out of the scope of this post.\n\n\nThe other way you can tell if a function has been executed internally is by using transaction logs. Any events that were fired during a transaction are recorded on the blockchain. The only requirement for this method is that the events actually were fired from the contract. Fortunately, this is considered the best practice for smart contracts.\n\n\nPython web3 API implementation\n\n\nIn contrast to the JavaScript implementation of the web3 API, its Python implementation is more portable so it can be easily deployed even without a web server. Using the Python API, we managed to implement a better transaction monitoring script for Ethereum. The Python API fully supports the web3 API, except for the 1.0 beta version, and has several specific additions including some for controlling Ethereum nodes (admin API, miner API, and so on). The Python API filtering functions are somewhat different from the JavaScript functions too.\n\n\nThe block, pending transaction, and event filters in the Python API are just the same as in the JavaScript API. However, there\u2019s \nanother type\n of event filter that can be created right from a contract object.\n\n\nThe contract event filter provides event logs in an accessible manner so that you don\u2019t need to parse anything. For example, this function allows you to detect transfer events from an ECR20 token:\n\n\nJavaScript\nevent_filter\n \n=\n \ntokenContract\n.\nevents\n.\nTransfer\n.\ncreateFilter\n(\nfromBlock\n=\n\"latest\"\n)\n\n\nThis function will filter all Transfer events and their parameters. Then you can add some simple filtering to detect any suspicious transactions. The final script for the transaction monitoring will look something like this:\n\n\nPython\nfrom\n web3.auto \nimport\n w3\n\n\n  \nfrom\n web3.contract \nimport\n ContractEvents\n\n\n  \nfrom\n web3.contract \nimport\n ContractEvent\n\n\n  \nimport\n time\n\n\n  \nimport\n sys\n\n\n  \nimport\n json\n\n\n    \n\n\n  \ndef\n \nprint_log_entry\n(\nlog_entry\n):\n\n\n      \nprint\n(\n'Event: '\n, log_entry[\n'event'\n])\n\n\n      \nfor\n arg, value \nin\n log_entry[\n'args'\n].\nitems\n():\n\n\n          \nprint\n(arg, \n': '\n, value)\n\n\n    \n\n\n  \ndef\n \ncheck_suspicious_event\n(\ntx_hash\n, \nlogs\n):\n\n\n      \n# check if transferred value was too large\n\n\n      \nfor\n log \nin\n logs:\n\n\n          \nfor\n log_entry \nin\n log:\n\n\n              \nif\n (log_entry[\n'event'\n] \n==\n \n\"Transfer\"\n):\n\n\n                  \nreturn\n log_entry[\n'args'\n][\n'amount'\n] \n>=\n \n1000\n \n*\n \n10\n \n**\n \n18\n \n# let's consider transactions of more than 1000 full tokens as suspicious (assuming that our token has 18 decimal places)\n\n\n      \nreturn\n false\n\n\n    \n\n\n  \ndef\n \nhandle_event\n(\nevent_data\n, \ncontract\n):\n\n\n      \n#get info about the transaction from the blockchain\n\n\n      tx_hash \n=\n event_data[\n'transactionHash'\n].\nhex\n()\n\n\n      receipt \n=\n w3.eth.\ngetTransactionReceipt\n(tx_hash)\n\n\n      events \n=\n [event[\n'name'\n] \nfor\n event \nin\n contract.events._events] \n#workaround for contract.events lacking an iterator, get the list of events\n\n\n      logs \n=\n [ contract.events.\n__dict__\n[event_name]().\nprocessReceipt\n(receipt) \nfor\n event_name \nin\n events ] \n# loop through contract.events attributes\n\n\n      \n#at this point you can add any conditions to log only suspicious transactions (e.g. the withdrawn value was too large)\n\n\n      \nif\n (\ncheck_suspicious_event\n(tx_hash, logs)):\n\n\n          \nprint\n(\n'Warning: a suspicious transaction has been detected!'\n)\n\n\n          \nprint\n(\n'TxHash: \n{}\n'\n.\nformat\n(tx_hash))\n\n\n          \nfor\n log \nin\n logs:\n\n\n              \nfor\n log_entry \nin\n log:\n\n\n                      \nprint_log_entry\n(log_entry)\n\n\n    \n\n\n  \ndef\n \nlog_loop\n(\nevent_filter\n, \nfilterContract\n, \npoll_interval\n):\n\n\n      \nprint\n(\n'Listening to transactions...'\n)\n\n\n      \nwhile\n \nTrue\n: \n#keep logging indefinitely\n\n\n          \nfor\n event \nin\n event_filter.\nget_new_entries\n(): \n#get every new event\n\n\n              \nhandle_event\n(event, filterContract) \n#handle each event\n\n\n          time.\nsleep\n(poll_interval) \n#prevent from spamming requests too much\n\n\n    \n\n\n  \ndef\n \nmain\n():\n\n\n      \nif\n (\nlen\n(sys.argv) \n<\n \n2\n):\n\n\n          \nprint\n(\n'Usage: \n{}\n <address> <path_to_abi_file> [poll_interval]'\n.\nformat\n(sys.argv[\n0\n]))\n\n\n          \nreturn\n\n\n      \n#read arguments\n\n\n      [address, abi_file] \n=\n sys.argv[\n1\n:\n3\n]\n\n\n      poll_interval \n=\n \n5\n\n\n      \nif\n (\nlen\n(sys.argv) \n>\n \n3\n):\n\n\n          poll_interval \n=\n \nint\n(sys.argv[\n3\n])\n\n\n      \n#load and parse abi file\n\n\n      \nwith\n \nopen\n(abi_file) \nas\n f:\n\n\n          abi_data \n=\n json.\nload\n(f)\n\n\n          filterContract \n=\n w3.eth.\ncontract\n(\nabi\n=\nabi_data, \naddress\n=\naddress) \n#create the contract object\n\n\n          \nfilter\n \n=\n w3.eth.\nfilter\n({\n'fromBlock'\n: \n'latest'\n, \n'toBlock'\n: \n'latest'\n, \n'address'\n: address}) \n#create the filter\n\n\n          \nlog_loop\n(\nfilter\n, filterContract, poll_interval) \n#start polling for new events\n\n\n    \n\n\n  \nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n\n      \nmain\n()\n\n\nIn this script, we set up a filter based on the contract\u2019s address and keep polling the network for new events. A JSON file with the contract\u2019s application binary interface (ABI) is used to parse all of the event data in the \nhandle_event\n function. The parsed data is passed into the \ncheck_suspicious_event\n function, which can perform any necessary checks to validate the transaction. If the transaction is suspicious, the function will return true and the script will log event details. The example checks if a Transfer event (from the ERC20 standard) was emitted and if the transferred number of tokens was greater than 1000 full tokens.\n\n\nYou can easily use any other criteria for detecting potentially suspicious transactions.\n\n\n\n\nRecording the receiver address and frequency of payments\n \u2014 This way you can detect siphoning of tokens. Small but frequent payments may slip under the radar and allow an attacker to get away.\n\n\nCompare a transaction destination address with the contract address\n \u2014 This way you can figure out if a real person executed the contract. Automatic execution of a contract could be an attempt to exploit a reentrancy vulnerability.\n\n\n\n\nThe script above can monitor any contract as long as it emits events or is called directly via the fallback function.\n\n\nNote that for running this script, you need Python 3.5 or higher and the web3 library has to be installed using the following function:\n\n\nShellScript\npip\n \ninstall\n \nweb3\n\n\nAlso, just like with JavaScript and Metamask, the Python API needs a web3 provider. You can use a locally running node or a wallet connected to the Ethereum network for this purpose and the API will try to detect a provider automatically. For more information on how to set up the Python web3 API, visit the \nWeb3.py website\n.\n\n\nAfter all of the dependencies are installed, you can run the script by providing an address of a contract and its ABI (created during contract compilation):\n\n\nShellScript\npython\n \nmonitorScript.py\n <\ncontract\n \naddres\ns> <\ncontract\n \nabi\n \nfil\ne> [poll \ninterval]\n\n\nOf course, all these approaches are just some basic ways to monitor Ethereum transactions. There are lots of other ways of interacting with the blockchain, from browsing blocks in a block explorer to studying the blockchain using neural networks and machine learning. And, to monitor suspicious Bitcoin mempool activity, for instance, you\u2019ll need to use a different approach.\n\n\nYou can choose the approach that best suits your needs and security standards. Regardless of the approach you decide to use, you should definitely look into monitoring blockchain data as a way to protect your digital assets.\n\n\nConclusion\n\n\nTransaction monitoring is one of the most effective tools you can use for preventing and detecting criminal activity in cryptocurrencies. Depending on your scope of work, you can monitor and read blockchain transactions either manually, using a block explorer, or automatically, with the help of scripts.\n\n\nManual monitoring works best for cases when you need to check only a limited number of transactions executed from a personal wallet or a small-scale smart contract. Automatic monitoring is more suitable for handling a large number of transactions on a regular basis. In the case of Ethereum, you can use either JavaScript (for creating web applications) or Python (for a portable implementation of the web3 API).\n\n\nAt Apriorit, we have a team of experienced professionals whose field of interest is the fascinating world of blockchain technology. Our developers have a high level of expertise in \ncybersecurity and data encryption\n, so we can assist you in developing and securing your blockchain-based solution.\n\n\n\n"
    }
}