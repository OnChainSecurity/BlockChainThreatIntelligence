{
    "threat_intelligence": {
        "url": "https://medium.com/@borisdinkevich/hacking-an-ethereum-contract-3181cd93589f",
        "timestamp": "2018-02-05 00:00:00",
        "original_content": "Do it yourself - reconstruct the $1,000,000 hack!\nWith all the stories running around about hackers stealing millions left and right, I thought it might be the time to take a closer look at one of the latest heists. And not just a look - we\u2019ll trace through it together and do the hack ourselves , step by step.\n\nThe following requires some basic knowledge of Solidity (the most common Ethereum smart contract language) and basic tech chops.\n\nThe back story\nThe recently launched PoWHCoin (cached version before the hack) was based on the the premise of a true pyramid scheme, but with a twist: You earn even when it goes down, in the form of dividends that you can cash out when the pyramid goes back up.\n\nIn the first few days interest spiked, with the contract hovering at around $1,000,000 (that\u2019s a million real US dollars, in ether).\n\nAnd then: Death. 866 ether gone in a quick, simple hack.\n\nSo how did so many experts miss such a glaring hole in such a short contract? And more importantly, how can we run the hack ourselves?\n\nThe tools\nTo keep things simple, we will be using the online Solidity IDE , Remix . Go ahead, click the link and open it up in your browser.\n\n\nWeb based Solidity IDE - Remix\nThe IDE is pretty simple:\n\nTop left - our code\nBottom left - debug area\nRight - command area\nThe original contract\nYou can\u2019t hide on the chain\n\nThe original contract is still there on the blockchain, ready for review and studying. You can check out all the transactions and code here.\n\n\nThe original contract\nThe important bit for us is the \"Contract Source\" tab, where we can find the original Solidity code for the contract. (Debugging directly from the Ethereum Virtual Machine would have been much harder, yet not impossible.)\n\nLet\u2019s start off by taking all the contract code (here is a cleaned-up version) and copying it into Remix , replacing the demo \"Ballot\" code you probably have there by default.\n\nPrepare for Deploy\nTo make things simple, we will do all our \"hacking\" in private. Then, once we are ready, we can send the real transactions at once and not waste time (and risk being detected!).\n\nWith the contract copied over, at the top right, select the \"Run\" menu.\n\n\nFirst let\u2019s select the environment. Since we don\u2019t have a local Ethereum node running and we don\u2019t want to connect to any test nets (private, yea?), we can just select \"JavaScript VM\" from the \"Environment\" drop-down.\n\n\nYou might notice the \"Account\" drop-down. The test environment automatically created a few accounts for us with 100 ether each (if only we could cash out\u2026).\n\nDeploy time\nOur contract drop-down will only contain one option, \"PonziTokenV3\" - which is exactly what we want to deploy. And right below it is an inviting pink button, \"Create.\"\n\nClick \"Create\" now.\n\n\nAs our contract is created, Remix automatically reads the ABI and lets us easily access the read-only parts of the contract or run generic transactions.\n\nBeing a hacker and all, this is a great time to click around on those \"sellPrice\", \"name\", \"totalSupply\", and other function names, and see how Remix shows us their values. (These are real values read from the contract already deployed on our test blockchain.)\n\nCalling a read-only function in Ethereum does not issue a transaction or cost wei.\n\nSimulate suckers\nTime to simulate suckers putting money into the contract, moments before we hack it all to heck.\n\nRemember how at the top right, under the \"JavaScript VM\" environment we selected, there was an \"Account\" drop-down? Let\u2019s pick the first account and use it as our \"greedy ol\u2019 user.\"\n\nWe are going to send 50 ether to the contract, so fill in 50 in the \"Value\" input and DON\u2019T FORGET to change the currency from \"wei\" to \"ether.\"\n\n\nNow scroll all the way down and click \"fund\".\n\nWhat just happened is that we ran a real transaction. The function was \"fund\" and we sent 50 ether to the contract.\n\nAt the bottom left, you can see the debug log and even click \"Details\" to see what happened.\n\n\nNote that the addresses in this tutorial and your run will be different.\n\nIf you take a peek at the \"Account\" drop-down at the top right now, you will notice that the account has only 49.999999 ether.\n\nWhy? We sent 50 ether to the contract, so what happened to the 0.000001? It\u2019s payment for transaction costs to the miners (that\u2019s all the \"gas\" stuff you see there in the table).\n\nHax0r time\nSo let\u2019s see what our hacker did (and we can, since it\u2019s all on the blockchain - forever). The address from which everything was run is here.\n\nStep #1 - Join the game\nIt starts with innocently joining the Ponzi scheme. Let\u2019s choose the second account and use it to fund 1 ether.\n\n\nStep #2 - Send to someone else?\nNow the tricky part - we are going to send ONE of the cool tokens we got to \"a friend.\" To do so, we need a friend.\n\nOur friend is going to be account #3 in the list of accounts. The nice thing about Remix is that once you select account #3, on the right you will see a small \"Copy\" icon - that copies the public address into your clipboard.\n\n\nWe always need to remember which account we are sending the transaction FROM. So, as soon as you copy the account #3 address, switch back to account #2.\n\nLet\u2019s do this. Scroll down all the way to \"approve\". This function allows one account to send coins to another account. This is done semi-directly. We basically move the coins to the contract and allow the target account to \"withdraw\" them later. (This is the safe and recommended way to move coins around.)\n\nfunction approve(address _spender, uint256 _value) public { ... }\nUnfortunately, Remix is a bit ugly in the way we pass parameters to functions. We can write parameters in the input box to the right of the function in the following format:\n\nX,Y,Z\u2026\n\nWhere X can be:\n\nA number - e.g., 100\nA string in double quotes - e.g., \"hi\"\nA hex in double quotes prepended by \"0x\" - e.g., \"0xDEADBEAF\"\nSince we want to transfer coins from our account #2 (which we selected in the drop-down) to account #3 (whose public key we copied to the clipboard), and we want to send 2 coins, we will put in the parameters box:\n\n\"0x0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db\",2\n\nPlease note again that your addresses will be different.\n\nOnce you\u2019ve done that, click \"approve\" and let the transaction run.\n\nStep 3 - The hack\nFirst let\u2019s check the balance for account #3.\n\nPaste the public key you copied before into the input field to the right of \"balanceOfOld\" (don\u2019t forget the double quotes and \"0x\"). Running it should read your entry from the array of balances.\n\n\n// amount of shares for each address (scaled number)\nmapping (address => uint256) public balanceOfOld;\nSince we didn\u2019t yet \"pull\" the 2 coins sent to us from account #2, it makes sense that we have 0 coins.\n\nNow the hacker used another feature of the contract: It allows you to transfer coins from one account to another (for preapproved sums, of course).\n\nSince we had account #2 preapprove the transfer of 2 coins, we can move that sum now. The trick here is a bug in the contract. We are going to send the 1 coin given to us to the address of the contract itself!\n\nfunction transferFrom(address _from, address _to, uint256 _value) public { ... }\nThe params are:\n\nPublic address of account #2 (copied from the \"Account\" drop-down)\nPublic address of our contract (copied from the contract drop-down)\nAmount - 1\n\nWhere to copy the address of the contract itself\nWhere to copy the address of the contract itself\n\nThe result will look something like this:\n\n\"0x14723a09acff6d2a60dcdf7aa4aff308fddc160c\",\"0x692a70d2e424a56d2c6c27aa97d1a86395877b3a\",2\n\nDon\u2019t forget, we MUST run this as account #3!\n\nOnce you\u2019ve selected account #3 from the \"Account\" drop-down and copied over the params, hit \"transferFrom\".\n\n\nBefore we dive into the code, copy the address for account #3 and try it out in the \"balanceOfOld\" function.\n\nNo, you are not dreaming. Our 0 became\u2026\n\n115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,935\n\nOr in hex: 0xFFFFF\u2026..\u2026..FFFFFF.\n\nWhat happened?\nLets trace the call to \"transferFrom\":\n\nfunction transferFrom(address _from, address _to, uint256 _value) public {\n  var _allowance = allowance[_from][msg.sender];\n  \n  if (_allowance < _value) revert();\n  \n  allowance[_from][msg.sender] = _allowance - _value;\n  transferTokens(_from, _to, _value);\n}\nThe code in \"transferFrom\" checks that we have enough coins in our allowance (1) and proceeds to call another function, \"transferTokens()\":\n\nfunction transferTokens(address _from, address _to, uint256 _value) internal {\n  if (balanceOfOld[_from] < _value) revert();\n  if (_to == address(this)) {\n    sell(_value);\n  }\n...\n}\nWe know account #2 has enough for our 1-coin withdrawal, so the first check passes.\n\nThe second check sees that the TO address is the address of the contract itself. So, a call to \"sell\" is done:\n\nfunction sell(uint256 amount) internal {\n  var numEthers = getEtherForTokens(amount);\n  // remove tokens\n  totalSupply -= amount;\n  balanceOfOld[msg.sender] -= amount;\n\n  // fix payouts and put the ethers in payout\n  var payoutDiff = (int256) (earningsPerShare * amount + (numEthers * PRECISION));\n  payouts[msg.sender] -= payoutDiff;\n  totalPayouts -= payoutDiff;\n}\nAnd here is where everything goes wrong. The \"sell\" function doesn\u2019t receive the \"from\" or \"to\" parameters from before. It assumes everything was checked before and goes ahead to deduct the amount being sent from \"balanceOfOld[]\".\n\nBut from which account? Well, it assumes that the account that initiated the transaction is the seller\u2019s account - something that is not true in our case. Since we ran \"transferFrom\" using account #3 to send coins from account #2 to the address of the contract, our \"msg.sender\" is account #3.\n\nAnd what was the balance of that account? That\u2019s right - ZERO.\n\nWhen you take an unsigned number like uint256 and do 0 minus 1, you get the dreaded Integer Underflow.\n\nbalanceOfOld[Account #2] -= 1 // Regular positive value\nbalanceOfOld[Account #3] -= 1 // 0xFFF\u2026FFF\n\nWe have the largest integer value possible of coins\n\n- we are rich!\n\nGetting the money out\nNow that we have this huge balance on our hands, let\u2019s empty the cash register.\n\nThe first order of business is to transfer some of our endless balance to the contract address.\n\nAs account #3, we will call the \"transfer\" function and give it the address of the contract and the sum to transfer - in our case, 50 ether (or 50,000,000,000,000,000,000 wei).\n\nThe params will look something like this:\n\n\"0x692a70d2e424a56d2c6c27aa97d1a86395877b3a\",\"0x2B5E3AF16B1880000\"\n\nGo ahead, hit \"transfer\".\n\nNow the ether\nInternal transfers approved (we sent the coins back to the contract), let\u2019s get the ether itself.\n\nWe do this by calling \"withdraw\" (the parameter doesn\u2019t matter).\n\nMake sure you are still account #3, and hit \"withdraw\".\n\nVerify\nNow scroll to the top and check the \"Account\" drop-down. Almost 150 Ether? Woohoo!\n\n\nSummary\nWriting contracts in Solidity is hard. In fact, it\u2019s super hard and very dangerous. This simple tale of a $1,000,000 contract being live for days without anyone finding a tiny bug (until the hacker did!) is a serious lesson to us Solidity writers everywhere.\n\nAs a developer it\u2019s easy to imagine the flow of this contract being developed, the assumptions assumed, and the bug going unnoticed.\n\nKeep safe and prosper\n\n@BorisDinkevich @ 500Tech.com"
    }
}