{
    "threat_intelligence": {
        "url": "https://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25",
        "timestamp": "2018-08-19 00:00:00",
        "original_content": "Replay Attack Vulnerability in Ethereum Smart Contracts Introduced by transferProxy()\nJay | Human Being\nCypher Core\nJay | Human Being\n\n\u00b7\nFollow\n\nPublished in\nCypher Core\n\n\u00b7\n4 min read\n\u00b7\nAug 19, 2018\n160\n\n\n1\n\n\n\n\n\ntransferProxy() a.k.a Proxy Transfer is a newly proposed EIP where the users can pay transaction fees in tokens, as opposed to paying only in ether in tradition ERC20 contracts. Proxy Transfer aims to solve the problem where the users can\u2019t freely transfer their tokens unless they hold enough ether to pay for the transaction fees. While the EIP is still being reviewed, many projects have jumped on the gun and incorporated Proxy Transfer into their own smart contracts. Not long after Proxy Transfer was implemented in actual DApps projects, an overflow bug in transferProxy() was exploited on SmartMesh (SMT) where an equivalent of over $5 octodecillion worth of SMT counterfeit tokens were generated. A technical breakdown of this incident can be found down below:\n\nInteger Overflow (i.e., proxyOverflow Bug) Found in Multiple ERC20 Smart Contracts (CVE-2018-10376)\nOn 4/24/2018, 01:17:50 p.m. UTC, PeckShield, a blockchain security startup, detected an unusual MESH token transaction\u2026\nmedium.com\n\nIn this article, we will be focusing on a replay attack exploit recently discovered by the researchers at 360 Security Research Innovation Alliance. Before diving into the code, we need to first understand how such replay attacks work at a high level. For demonstration purposes, we will use the classic placeholder names, Alice and Bob for representing the sender and the recipient respectively.\n\nAttack Workflow\n\n\u2460 Alice (sender) initiates a transaction in which 100 Token 1s will be sent to Bob (recipient) and 3 Token 1s will be paid to Proxy as service fee. Alice then signs the transaction with her signature \u2192 sig(A,B,100,3).\n\n\u2461 Transaction gets carried out by Proxy. Bob gets 100 Token 1s from Alice.\n\n\u2462 Bob replays Alice\u2019s signature in a new transaction \u2192 transferProxy(A,B,100,3,sig) \u2192 sig(A,B,100,3).\n\n\u2463 New transaction gets carried out by Proxy. Bob gets 100 Token 2s from Alice without her authorization.\n\nNote 1: many smart contracts on Ethereum share the same way of verifying signatures. Some even share the exact same signature contents.\n\nNote 2: here we assume the starting nonce is 1.\n\nProxy Transfer Contract\n\nTwo functions worth noting here:\n\nkeccak256(): KECCAK-256 is a cryptographic hash function used in Ethereum. Being an alias to SHA-3, KECCAK-256 is often wrongly referred to as SHA-3. In reality, KECCAK-256 does not follow the SHA-3 Standard and was already used in the Ethereum project before the SHA-3 Standard was finalized in August 2015.\necrecover(): \"a function to recover the address associated with the public key from elliptic curve signature or return zero on error\" (Ethereum, 2018).\nSigning and Signature Verification\n\nNote that the sender and the recipient need to agree on nonce and_fee before transacting.\n\nAttack in Action\nHere we will demonstrate an attack verification experiment performed by the 360 Security Research Innovation Alliance.\n\nAlice sends Bob 3 MTC tokens\nSender Alice\u2019s wallet address\nRecipient Bob\u2019s wallet address\nTransaction hash\n\n\nTransaction input data\nFunction: transferProxy(address _from, address _to, uint256 _value, uint256 _fee, uint8 _v, bytes32 _r, bytes32 _s)\nMethodID: 0xeb502d45\n[0]:  0000000000000000000000008e65d5349ab0833cd76d336d380144294417249e\n[1]:  000000000000000000000000185ca9b6da95beba43f3763b8e4cf3a0252cc241\n[2]:  00000000000000000000000000000000000000000000000029a2241af62c0000\n[3]:  0000000000000000000000000000000000000000000000000000000000000000\n[4]:  000000000000000000000000000000000000000000000000000000000000001c\n[5]:  c6074323c4606c141739966b594d451add5411400b936d2ab8fd2338fc1a6263\n[6]:  0b139672753d1ce31ed68bf3d49b9502aab5b919fa6cba34f3c4ff37edaa63ff\n2. Bob extracts data [0] - [6] from the input data shown above, and uses it to make another transaction in the MTC smart contracts.\n\n\n3. Along with the 3 MCT tokens Alice sent, Bob also received 3 UGT tokens from Alice without her permission. In other words, Bob \"stole\" 3 UGT tokens from Alice.\n\nTransaction hash\n\n\nHow to Prevent Such Attacks\nThere certainly are many possible ways to prevent such replay attacks, here are some of my ideas:\n\nAvoid using transferProxy() completely\nMake nonce start at a higher count than 0\nAdd chainID, name of the public chain in smart contracts\nAdd address(this) in keccak256()\nReferences\n[1] SmartMesh. (2018, April 25). SmartMesh Announcement on Ethereum Smart Contract Overflow Vulnerability. Retrieved August 19, 2018, from https://medium.com/smartmesh/smartmesh-announcement-on-ethereum-smart-contract-overflow-vulnerability-f1ded8777720\n\n[2] N. (2018, August 15). Replay Attacks on Ethereum Smart Contracts. Retrieved August 19, 2018, from https://github.com/nkbai/defcon26/blob/master/docs/Replay Attacks on Ethereum Smart Contracts.md\n\n[3] Ethereum. (n.d.). Units and Globally Available Variables. Retrieved August 19, 2018, from https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions"
    }
}