{
    "threat_intelligence": {
        "url": "https://consensys.io/diligence/blog/2019/02/poison-block-explorer-byte-code/",
        "timestamp": "2019-02-11 00:00:00",
        "original_content": "Poison Block Explorer Byte Code\nFebruary 11, 2019 by Daniel Luca\n\nYou will understand how to trick a block explorer into displaying different byte code of your choosing, other than the one deployed on the chain.\n\nThis is important because a user can be tricked by a hacker to think they interact with a good contract, when actually the user interacts with malicious contract. It is indeed the same contract address, but the byte code is not the one reported by the block explorer.\n\nThe problem\nThe core technical issue is how block explorers handle transactions that create contracts and are then reverted. I found two explorers, BlockChair and BlockScout, that incorrectly store byte code from the reverted transaction. (See the Disclosure section for the current status.)\n\nThe setup\nTo make this work we need 3 things:\n\na trustworthy contract that a user wants to interact with;\nanother contract that is malicious, that the user does not want to interact with;\na factory contract that pretends to deploy the trustworthy contract and actually deploys the malicious one.\nTrustworthy contract\nBelow is a simple contract that acts like a safe. A user can store funds and retrieve those funds at a later date:\n\ncontract Safe {\n    mapping(address => uint256) ledger;\n\n    function() external payable {\n        ledger[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 balance = ledger[msg.sender];\n        ledger[msg.sender] = 0;\n        msg.sender.transfer(balance);\n    }\n}\nIf the user wants to store some funds, they can just send them to the contract. In the future the user can call the withdraw() method to retrieve all of their stored funds.\n\nMalicious contract\nBelow is a malicious contract that accepts funds but does not return them. Instead, it allows the contract\u2019s owner to steal all the collected funds:\n\ncontract MaliciousContract {\n    address payable owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function() external payable {\n        // Accepts ether\n    }\n\n    function steal() external {\n        selfdestruct(owner);\n    }\n}\nFactory contract\nBelow is the factory contract:\n\ncontract Deployer {\n    function createGood() **external** {\n        // Pretend to deploy the contract and revert\n        new Safe();\n        revert();\n    }\n\n    function createMalicious() external {\n        MaliciousContract newContract = new MaliciousContract();\n\n        emit Deployed(address(newContract));\n    }\n\n    event Deployed(address safe);\n}\nThe method createGood() pretends to deploy the good contract, but in the end it reverts the transaction. Trying to deploy the good contract means that it creates a message that is picked up by the block explorer, which contains the byte code and the new contract address. Reverting the transaction means no new contract is deployed and that the contract\u2019s nonce is not changed.\n\nThe address for an Ethereum contract is deterministically computed from the address of its creator and the creator\u2019s nonce. We can define it like this without going into detail:\n\n\n\nThe method createGood() does not increase the contract\u2019s nonce because it reverts. This means that calling createMalicous() will generate the same address for the newly deployed contract and this time it will not revert but it will have a different byte code.\n\nThis is exactly what the Deployer contract exploits.\n\nTricking the block explorer\nTo trick the block explorer you need 2 actions:\n\nThe hacker first calls createGood() which will appear to the block explorer to deploy a new contract with the Safe contract\u2019s byte code. If the block explorer does not handle the revert() properly, the byte code will be associated with the new contract address.\nThe hacker then calls createMalicious(), which creates a contract with the MaliciousContract byte code at the same contract address as previously recorded.\nThe block explorer must handle the errors properly and only save the byte code when the contract message succeeds. Otherwise it will associate an incorrect byte code with a contract address.\n\nThe users checking the contract will see an incorrect byte code on the website. They will think they interact with a good contract when actually they interact with a malicious one.\n\nResult\nWhen I tried this, some block explorers reported incorrect byte code. This happened because we first pretend to deploy a contract and then revert. The block explorer observes the pretend deployment and saves the byte code as the one deployed. When we actually deploy a new contract with different byte code, the explorer does not overwrite the previously saved byte code.\n\nIn the end the reported byte code is not the one on the chain.\n\nDisclosure\nI wanted to see if any explorers had this bug, and this was the result:\n\nDeployer contract instance 0x2d07e106b5d280e4ccc2d10deee62441c91d4340\nGood Contract / Malicious Contract 0xf4a5afe28b91cf928c2568805cfbb36d477f0b75\nTransaction that pretends to deploy the good contract 0x9f4be1e7dac38999bf54af767983c9bf7e5f328d257883abbcd029e4989ccc69\nTransaction that deploys the malicious contract 0x3d1acd9ae5e9594b93d6529ac77c39bc4f570b360c4778350e5851460489ce65\nI am in the process of contacting the explorers that have this problem to help them fix the issue.\n\nExplorers that handle it correctly:\n\nEtherscan\nEthStats\nAmberdata - Does not display any code, even after the second deploy.\nEtherChain\nEthOrbit\nExplorers with this bug:\n\nBlockChair\n\n2019-02-12: Discussed with the lead developer and outlined the issue. They fixed the issue really quickly in just a few hours.\n\nBlockScout\n\n2019-02-12: Contacted the people in charge and created an issue on their GitHub.\n\n2019-02-14: There is a 300 DAI bounty to fix the bug.\n\nOther block explorers that display too little information or do not display the contract code:\n\nEthPlorer\nBloxy\nTrivial\nWatchEthereum\nA big thank you to Jules for seeding the initial idea, M H Swende for making me think more about this and Steve for all the support provided."
    }
}