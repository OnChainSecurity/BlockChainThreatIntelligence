{
    "threat_intelligence": {
        "url": "https://medium.com/agoric/preventing-reentrancy-attacks-in-smart-contracts-3899bf837f23",
        "timestamp": "2019-01-15 00:00:00",
        "original_content": "Preventing Reentrancy Attacks in Smart Contracts\nTLDR: Reentrancy attacks can be entirely prevented with eventual-sends. \nEventual-sends (think JavaScript promises \u2014 promises actually come from eventual-sends!) allow you to call a function asynchronously and receive a promise, even if the function is on another machine, another blockchain, or another shard, making sharding and cross-chain contract communication much easier.\nPhoto by \nTim Gouw\n on \nUnsplash\nOn January 15th, \na group of key stakeholders chose to halt the Ethereum \u201cConstantinople\u201d upgrade\n. It was only a day before Constantinople was supposed to take effect, but Chain Security had released a \nblog post\n that pointed out that the new reduced gas costs would bypass some previously \u201creliable\u201d defenses against reentrancy attacks. The Ethereum community worked quickly and transparently to postpone the upgrade so that more investigation could be done.\nWe wanted to take this opportunity to bring attention to the \nclass of problems \nthat reentrancy attacks are part of, and how certain designs can \neliminate\n the entire class of problems altogether.\nInterleaving Hazards\nEthereum\u2019s reentrancy attacks are just one part of a larger class of problems, called \ninterleaving hazards\n. We might think that because Ethereum runs sequentially, it can\u2019t possibly have interleaving hazards. But surprisingly, \neven entirely sequential programs can have interleaving hazards\n.\nHere\u2019s \nan example\n[1] that is entirely synchronous and sequential, but has a major interleaving hazard. In this example, we have a bank account that we can deposit to and withdraw from:\nWhenever we do something that changes the balance, we want to update the state with our new balance and notify our listeners. We do this with a stateHolder:\nLet\u2019s say we have two listeners. One is a financial application that deposits to our account if our balance drops below a certain level:\nThe other listener just displays our account balance on our dashboard webpage (we\u2019ll simulate this with a console.log ):\nNothing to worry about here, right? Let\u2019s see what happens when we execute it. We add the listeners and withdraw $100 from our account:\nOur bank account starts off with a balance of $4000. Withdrawing $100 updates the balance to be $3900, and we notify our listeners of the new balance. The financeListener deposits $1000 in reaction to the news, making the balance $4,900. But, our website shows a balance of $3,900, the wrong balance! \nWhy does this happen? Here\u2019s the sequence of events:\nfinanceListener gets notified that the balance is $3,900 and deposits $1,000 in response.\nThe deposit triggers a state change and starts the notification process again. Note that the webpageListener is still waiting to be notified about the first balance change from $4000 to $3900.\nfinanceListener gets notified that the balance is $4,900 and does nothing because the balance is over $4,000.\nwebpageListener gets notified that the balance is $4,900, and displays $4,900.\nwebpageListener finally gets notified that the balance is $3,900 and updates the webpage to display $3,900 \u2014 the wrong balance.\nWe\u2019ve just shown that\n even entirely synchronous programs \u2014 programs that have nothing to do with smart contracts or cryptocurrencies \u2014 can still have major interleaving hazards.\nHow can we eliminate interleaving hazards?\nA number of people have proposed solutions for interleaving hazards, but many of the proposed solutions have the following flaws:\nThe solution is not robust (the solution fails if conditions change slightly)\nThe solution doesn\u2019t solve all interleaving hazards\nThe solution restricts functionality in a major way\nLet\u2019s look at what people have proposed for Ethereum.\nResource constraints as a defense against interleaving hazards\nConsensys\u2019 \n\u201cRecommendations for Smart Contract Security in Solidity\u201d\n states the following:\nsomeAddress.send()and someAddress.transfer() are \nconsidered safe against reentrancy\n. While these methods still trigger code execution, the called contract is only given a stipend of 2,300 gas which is currently only enough to log an event\u2026 Using send() or transfer() will prevent reentrancy but it does so at the cost of being incompatible with any contract whose fallback function requires more than 2,300 gas.\nAs we saw in the Constantinople upgrade, this defense fails if the gas required to change state is less than 2,300 gas. Over time, we would expect the required gas to change, as it did with the Constantinople update, so this is not a robust approach (flaw #1).\nCall external functions last, after any changes to state variables in your contract\nSolidity\u2019s documentation recommends\n the following:\n\u201cWrite your functions in a way that, for example, calls to external functions happen after any changes to state variables in your contract so your contract is not vulnerable to a reentrancy exploit.\u201d\nHowever, in the example above, all of the calls to the external listener functions in withdraw and deposit happen after the state change. Yet, there is still an interleaving hazard (flaw #2). Furthermore, we might want to call multiple external functions, which would be then be vulnerable to each other, making reasoning about vulnerabilities a huge mess.\nDon\u2019t Call Other Contracts\nEmin G\u00fcn Sirer\n suggests\n:\ndo not perform external calls in contracts. If you do, ensure that they are the very last thing you do. If that\u2019s not possible, use mutexes to guard against reentrant calls. And use the mutexes in all of your functions, not just the ones that perform an external call.\nThis is obviously a major restriction in functionality (flaw #3). If we can\u2019t call other contracts, we can\u2019t actually have composability. Furthermore, mutexes can result in deadlock and are not easily composable themselves."
    }
}