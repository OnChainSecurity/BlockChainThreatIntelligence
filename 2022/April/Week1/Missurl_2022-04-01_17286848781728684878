{
    "threat_intelligence": {
        "url": "https://www.immunebytes.com/blog/reentrancy-attack/",
        "timestamp": "2022-04-01 00:00:00",
        "original_content": "\n\nIf you are an old player in the crypto industry, then the infamous \nDAO hack\n must have been on your radar. The DAO hack of 2016 was probably one of the most severe attacks in blockchain history caused by \nReentrancy\n.\u00a0\n\n\nIn fact, in April 2022, OLA finance powering Voltage finance experienced exploitation for over $4.67mn in a Re-entrancy attack. The attacker used a re-entrant vulnerability in the ERC677 token standard to commit financial fraud.\u00a0\n\n\nAn attack committed by a smart contract over another led to an additional scam to the list of crypto-heists taking over the blockchain space for some time now.\u00a0\n\n\nThis article will discuss the Re-entrancy attack, including its working, type, and ways of saving your smart contract from them.\u00a0\u00a0\n\n\nAdditional Resource: \nWhat is Dao\n?\n\n\nWhat is a Reentrancy \nA\nttack?\n\n\nRe-entrancy\n or an unsafe external call happens when Contract X calls Contract Y. A vice-versa call occurred before Contract X could update the first call on its state, leading to unexpected behavior.\u00a0\u00a0\n\n\nWe know this might be a little confusing so let\u2019s look through an example:\u00a0\n\n\nConsider two functions in a smart contract- deposit and withdrawal\n\n\nThe deposit function shoots up the user account on receiving crypto\nOn the other hand, the Withdrawal function performs three tasks in a row, including:\u00a0\u00a0\n\n\nChecking the user balance\nSend funds\nUpdates the balance sheet\n\n\nConsider the following schematic explaining the scenario mentioned above:\u00a0\n\n\n\n\nHow Does Reentrancy Attack Work?\n\n\nTo explain the working of a reentrancy attack, let us take you through an example of hacking a Solidity contract using the same vulnerability.\u00a0\n\n\nConsider a contract X, calling Contract Y. Now reentrancy occurs when contract Y calls X while X is still executing its call to Y.\u00a0\nContract X keeps a record of how much it owes to other contracts, and it has a record of the balance it owes to contract Y.\u00a0\n\n\nLook at the diagram below to understand how the transaction occurs in this case.\u00a0\n\n\n\n\nLook at step 3 of contract X\u2019s withdrawal function. Before step 3 gets executed, the fallback function of Y makes another call to the withdrawal function of X.\u00a0\nThis could keep on iterating until the contract X balance comes to Zero. It eventually leads to contract Y draining all the Ether from contract X.\u00a0\nOne of the significant challenges of calling external contracts is that they may take over the control flow and change the data that the calling function wasn\u2019t expecting. The reentrancy vulnerability had functions calling themselves repeatedly before ending the first call.\n\n\nNow that we know what reentrancy is and how it is executed, let\u2019s look at the different types of the same.\u00a0\n\n\nMust Read: \nRE-ENTRANCY REAL USE CASE\n\n\nTypes of Reentrancy Attack\n\n\nReentrancy attacks are classified into two types: single-function and cross-function reentrancy.\n\n\nAttack on Single Function Reentrancy\n\n\nThe most basic and easily preventable \nsmart contract attack\n happens when the vulnerable function is the same one the attacker recursively attempts to call. The scenario explained above is an example of a single-function reentrancy attack.\n\n\nAttack on Cross-Functional Reentry\n\n\nThese attacks are harder to detect. A cross-function reentrancy attack is possible when a vulnerable function shares a state with another function that has a desirable effect for the attacker.\n\n\n\n\nAt this instant, execution of the attacker\u2019s code on the external call to withdraw balance calls transfer() function. Since their balance is not yet reset to zero, they can transfer the tokens despite receiving the withdrawal amount.\n\n\nHow can a Reentrancy Attack Harm Smart Contracts?\n\n\nReentrancy is one of the most devastating attacks with the potential to drain off your smart contract financially. It exploits Vulnerable patterns of calling external contracts and can be particularly damaging, draining all of the funds in your contract if not appropriately handled. Also, it is one of the primary reasons for the crypto-heists happening for some time now.\u00a0\u00a0\u00a0\n\n\nReentrancy is a loophole the attacker exploits through another smart contract by repeatedly calling a vulnerable function. All this happens before the vulnerable smart contract can update its state variables.\u00a0\u00a0\n\n\nRecommended: \nSmart Contract Audit Company\n\n\nHow to Protect Smart Contracts from a Reentrancy Attack?\n\n\nThere are a few steps that you can take to prevent your smart contract from \nreentrancy attack:\n\n\nObserve the examples given above. Here the balance updating step happens after sending Ether to another contract Y. Swapping the execution of these functions, i.e., updating balance before transferring. Also, implement checks-effects-interactions patterns.\nGet your \nsmart contract audited\n before deploying it on the mainnet. A smart contract audit provides an additional layer of security to your code, considerably reducing the chances of hacking.\u00a0 \u00a0\nAnother way of saving your smart contract from reentrants is a reentrancy guard. Look at the next section to know what a reentrancy guard is.\u00a0\n\n\nWhat is a \nR\neentrancy Guard?\n\n\nA reentrancy guard is a modifier that can be applied to the withdrawal function. Locking the contract prevents the execution of more than one function simultaneously.\n\n\n\n\nYou can eliminate the risk of recursive calls made at your withdrawal function using the reentrancy guard approach.\u00a0\u00a0\n\n\nIt\u2019s crucial to exercise caution while making calls to\n external smart contracts.\n This is due to the possibility that they could end up running malicious code in the original contract.\n\n\nReentrancy Guard is OpenZeppelin\u2019s \nway of implementing the mutex or the lock function. Mutex locks the contract against the cross-function reentrancy to prevent the exploitation of the withdrawal function using a recursive call.\u00a0\n\n\nReentrancy guard is the modifier provided by the openzeppelin\u2019s library, applying to a function called reentrant that guards function with a mutex.\n\n\nWrapping up\n\n\nInvoking external contracts always introduces security risks. But in \nreentrancy\n, the real issue is updating the global state following an external call.\u00a0\n\n\nThe attacker can call the withdraw function recursively, draining the entire contract by transferring funds before updating the balance.\u00a0\n\n\nReentrancy is not new and probably the most exploited bug by Web3.0 hackers. \nSmart contract Auditing\n is one way to prevent yourself from missing out on the reentrant vulnerability. A thorough review from \nWeb3 security experts\n can provide a security shield to your code, preventing it from being susceptible to hackers.?\n\n\n\n\n\n\n\n"
    }
}