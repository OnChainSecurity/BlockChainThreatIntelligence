{
    "threat_intelligence": {
        "url": "https://ethereum.org/en/developers/tutorials/erc20-with-safety-rails/",
        "timestamp": "2022-08-15 00:00:00",
        "original_content": "ERC-20 with Safety Rails\nOri Pomerantz\n August 15, 2022\n8 minute read minute read\nIntroduction\nOne of the great things about Ethereum is that there is no central authority that can modify or undo your transactions. One of the great problems with Ethereum is that there is no central authority with the power to undo user mistakes or illicit transactions. In this article you learn about some of the common mistakes that users commit with \nERC-20\n tokens, as well as how to create ERC-20 contracts that help users to avoid those mistakes, or that give a central authority some power (for example to freeze accounts).\nNote that while we will use the \nOpenZeppelin ERC-20 token contract\n(opens in a new tab)\n, this article does not explain it in great details. You can find this information \nhere\n.\nIf you want to see the complete source code:\nOpen the \nRemix IDE\n(opens in a new tab)\n.\nClick the clone github icon (\n).\nClone the github repository \nhttps://github.com/qbzzt/20220815-erc20-safety-rails\n.\nOpen \ncontracts > erc20-safety-rails.sol\n.\nCreating an ERC-20 contract\nBefore we can add the safety rail functionality we need an ERC-20 contract. In this article we'll use \nthe OpenZeppelin Contracts Wizard\n(opens in a new tab)\n. Open it in another browser and follow these instructions:\nSelect \nERC20\n.\nEnter these settings:\nParameter\nValue\nName\nSafetyRailsToken\nSymbol\nSAFE\nPremint\n1000\nFeatures\nNone\nAccess Control\nOwnable\nUpgradability\nNone\nScroll up and click \nOpen in Remix\n (for Remix) or \nDownload\n to use a different environment. I'm going to assume you're using Remix, if you use something else just make the appropriate changes.\nWe now have a fully functional ERC-20 contract. You can expand \n.deps\n > \nnpm\n to see the imported code.\nCompile, deploy, and play with the contract to see that it functions as an ERC-20 contract. If you need to learn how to use Remix, \nuse this tutorial\n(opens in a new tab)\n.\nCommon mistakes\nThe mistakes\nUsers sometimes send tokens to the wrong address. While we cannot read their minds to know what they meant to do, there are two error types that happen a lot and are easy to detect:\nSending the tokens to the contract's own address. For example, \nOptimism's OP token\n(opens in a new tab)\n managed to accumulate \nover 120,000\n(opens in a new tab)\n OP tokens in less than two months. This represents a significant amount of wealth that presumably people just lost.\nSending the tokens to an empty address, one that doesn't correspond to an \nexternally owned account\n or a \nsmart contract\n. While I don't have statistics on how often this happens, \none incident could have cost 20,000,000 tokens\n(opens in a new tab)\n.\nPreventing transfers\nThe OpenZeppelin ERC-20 contract includes \na hook, \n_beforeTokenTransfer\n(opens in a new tab)\n, that is called before a token is transferred. By default this hook does not do anything, but we can hang our own functionality on it, such as checks that revert if there's a problem.\nTo use the hook, add this function after the constructor:\nSome parts of this function may be new if you aren't very familiar with Solidity:\nThe \nvirtual\n keyword means that just as we inherited functionality from \nERC20\n and overrode this function, other contracts can inherit from us and override this function.\nWe have to specify explicitly that we're \noverriding\n(opens in a new tab)\n the ERC20 token definition of \n_beforeTokenTransfer\n. In general, explicit definitions are a lot better, from the security standpoint, than implicit ones - you cannot forget that you've done something if it's right in front of you. That is also the reason we need to specify which superclass's \n_beforeTokenTransfer\n we are overriding.\nThis line calls the \n_beforeTokenTransfer\n function of the contract or contracts from which we inherited which have it. In this case, that is only \nERC20\n, \nOwnable\n does not have this hook. Even though currently \nERC20._beforeTokenTransfer\n doesn't do anything, we call it in case functionality is added in the future (and we then decide to redeploy the contract, because contracts don't change after deployment).\nCoding the requirements\nWe want to add these requirements to the function:\nThe \nto\n address cannot equal \naddress(this)\n, the address of the ERC-20 contract itself.\nThe \nto\n address cannot be empty, it has to be either:\nAn externally owned account (EOA). We can't check if an address is an EOA directly, but we can check an address's ETH balance. EOAs almost always have a balance, even if they are no longer used - it's difficult to clear them to the last wei.\nA smart contract. Testing if an address is a smart contract is a bit harder. There is an opcode that checks the external code length, called \nEXTCODESIZE\n(opens in a new tab)\n, but it is not available directly in Solidity. We have to use \nYul\n(opens in a new tab)\n, which is EVM assembly, for it. There are other values we could use from Solidity (\n<address>.code\n and \n<address>.codehash\n(opens in a new tab)\n), but they cost more.\nLets go over the new code line by line:\nThis is the first requirement, check that \nto\n and \nthis(address)\n are not the same thing.\nThis is how we check if an address is a contract. We cannot receive output directly from Yul, so instead we define a variable to hold the result (\nisToContract\n in this case). The way Yul works is that every opcode is considered a function. So first we call \nEXTCODESIZE\n(opens in a new tab)\n to get the contract size, and then use \nGT\n(opens in a new tab)\n to check it is not zero (we are dealing with unsigned integers, so of course it can't be negative). We then write the result to \nisToContract\n.\nAnd finally, we have the actual check for empty addresses.\nAdministrative access\nSometimes it is useful to have an administrator that can undo mistakes. To reduce the potential for abuse, this administrator can be a \nmultisig\n(opens in a new tab)\n so multiple people have to agree on an action. In this article we'll have two administrative features:\nFreezing and unfreezing accounts. This can be useful, for example, when an account might be compromised.\nAsset cleanup.\nSometimes frauds send fraudulent tokens to the real token's contract to gain legitimacy. For example, \nsee here\n(opens in a new tab)\n. The legitimate ERC-20 contract is \n0x4200....0042\n(opens in a new tab)\n. The scam that pretends to be it is \n0x234....bbe\n(opens in a new tab)\n.\nIt is also possible that people send legitimate ERC-20 tokens to our contract by mistake, which is another reason to want to have a way to get them out.\nOpenZeppelin provides two mechanisms to enable administrative access:\nFor the sake of simplicity, in this article we use \nOwnable\n.\nFreezing and thawing contracts\nFreezing and thawing contracts requires several changes:\nA \nmapping\n(opens in a new tab)\n from addresses to \nbooleans\n(opens in a new tab)\n to keep track of which addresses are frozen. All values are initially zero, which for boolean values is interpreted as false. This is what we want because by default accounts are not frozen.\nEvents\n(opens in a new tab)\n to inform anybody interested when an account is frozen or thawed. Technically speaking events are not required for these actions, but it helps off chain code to be able to listen to these events and know what is happening. It's considered good manners for a smart contract to emit them when something that miught be relevant to somebody else happens.\nThe events are indexed so will be possible to search for all the times an account has been frozen or thawed.\nFunctions for freezing and thawing accounts. These two functions are nearly identical, so we'll only go over the freeze function.\nFunctions marked \npublic\n(opens in a new tab)\n can be called from other smart contracts or directly by a transaction.\nIf the account is already frozen, revert. Otherwise, freeze it and \nemit\n an event.\nChange \n_beforeTokenTransfer\n to prevent money being moved from a frozen account. Note that money can still be transferred into the frozen account.\nAsset cleanup\nTo release ERC-20 tokens held by this contract we need to call a function on the token contract to which they belong, either \ntransfer\n(opens in a new tab)\n or \napprove\n(opens in a new tab)\n. There's no point wasting gas in this case on allowances, we might as well transfer directly.\nThis is the syntax to create an object for a contract when we receive the address. We can do this because we have the definition for ERC20 tokens as part of the source code (see line 4), and that file includes \nthe definition for IERC20\n(opens in a new tab)\n, the interface for an OpenZeppelin ERC-20 contract.\nThis is a cleanup function, so presumably we don't want to leave any tokens. Instead of getting the balance from the user manually, we might as well automate the process.\nConclusion\nThis is not a perfect solution - there is no perfect solution for the \"user made a mistake\" problem. However, using these kinds of checks can at least prevent some mistakes. The ability to freeze accounts, while dangerous, can be used to limit the damage of certain hacks by denying the hacker the stolen funds.\nWas this tutorial helpful?"
    }
}