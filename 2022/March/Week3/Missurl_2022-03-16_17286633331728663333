{
    "threat_intelligence": {
        "url": "https://www.frontiersin.org/journals/computer-science/articles/10.3389/fcomp.2021.598780/full",
        "timestamp": "2022-03-16 00:00:00",
        "original_content": "Introduction\nSince 2015, when Ethereum smart contracts were introduced, there have been several incidents in which the operation of smart contracts that held an amount of Ether resulted in conflicts or issues (\nAlkhalifah et al., 2019\n). Two of these incidents were caused by reentrancy vulnerability. The first incident was in 2016 when an attacker launched a reentrance attack against the distributed autonomous organization (DAO) smart contract, which resulted in a loss of more than 3,600,000 million Ethers worth more than US$ 60 million at that time; the Ether market plunged, and the incident caused a hard fork leading to two versions of the Ethereum blockchain. The second incident was in 2018 when an adversary stole more than 165 Ethers, which is worth almost US$ 40,000, from SpankChain due to reentrancy vulnerability in the smart contract of the network\u2019s payment channel (\nAlkhalifah et al., 2020\n). Despite these incidents, the popularity of smart contracts is growing; however, they are also becoming more attractive targets for adversaries.\nSmart contracts are one of the most used attack vectors to Ethereum because they are like any other executable applications that operate on computers. Nevertheless, smart contracts are more sensitive in terms of cybersecurity due to the following factors:\n\u2022 Smart contracts in Ethereum blockchain are considered a new platform; therefore, the coding practices of smart contracts are not yet mature (\nHung et al., 2019\n).\n\u2022 The smart contract can be associated with a digital fortune that might be worth millions of dollars (\nSchrans et al., 2018\n).\n\u2022 The smart contracts operate on top of a blockchain that is immutable. Thus, once the smart contracts are deployed on the blockchain, it can possibly be impractical and intensely complex to modify them even if they contain flaws (the \u201ccode is law\u201d concept) (\nMadnick 2020\n).\nIs it true that the \u201ccode is law\u201d in Ethereum smart contracts? Many countermeasures are aimed to detect security flaws during the development stage since the contracts operate on top of immutable technology. However, smart contract developers need to act to address these flaws during the execution stage and not only rely on the development stage. The question is how we can secure a smart contract during the execution stage, even though it is immutable and contains flaws.\nThis article is organized as follows. In the \nRelated Work and the Limitations of Current Solutions\n section, we analyze the related literature into two categories: single-function and cross-function reentrancy attacks. We summarize the limitations of existing solutions while preventing vulnerability exploitation before the deployment of smart contracts. We propose a solution along with a prevention mechanism to protect smart contracts and a detection technique to identify attackers in \nThe Proposed Solution\n section. The \nImplementation of the Solution\n and \nProof of Concept\n sections describe the three approaches of our implementation architecture and the proof-of-concept result, which shows that the proposed solution can be utilized against reentrancy attacks during the execution of any smart contract. We finally summarize the findings and provide the future research directions in the \nConclusion and Future Research\n section.\nRelated Work and the Limitations of Current Solutions\nReentrancy attacks are one of the common threats in Ethereum blockchain, which are associated with the Solidity programming language. The attacks occur when an adversary leverages an external call of a smart contract by forcing the contract to execute additional code by utilizing a fallback function to call back to itself.\nThere are two types of reentrancy attacks (\nSamreen and Alalfi 2020\n): single-function and cross-function attack. A single-function attack occurs when the adversary attempts to recursively call the vulnerable function. A cross-function attack occurs when the target function state is shared with another function that the adversary desires to exploit.\nCurrent Defensive Methods\nThere are different methods used to protect smart contracts from reentrancy vulnerability. These proactive methods, which are utilized before the deployment of the smart contracts, are vulnerability-detection tools for Ethereum smart contracts, security based on programming languages, and security based on the development of smart contracts.\nSmart Contracts Vulnerabilities Detection Tools\nThere are several detection tools for smart contract vulnerabilities that can detect reentrancy vulnerability. The following sections will briefly introduce the detection tools that can discover the reentrancy vulnerability.\nSmartCheck\nSmartCheck is a code analysis tool that detects code issues in Solidity. The source code written by Solidity is translated into an XML-based intermediate representation. After that, SmartCheck checks the output against XPath patterns (\nTikhomirov et al., 2018\n). SmartCheck automatically checks for atrocious coding practices and vulnerabilities by highlighting them and providing a vulnerability explanation with a suggested solution to avoid cybersecurity issues (\nDika and Nowostawski, 2018\n).\nRemix\nRemix is a web-based IDE for writing and debugging smart contracts by utilizing high-level languages such as Solidity and Vyper. Remix identifies the possible vulnerable coding pattern and minimizes coding mistakes. It can identify several vulnerabilities such as reentrancy, timestamp dependence, and gas-costly patterns vulnerabilities (\nDika and Nowostawski, 2018\n).\nOyente\nOyente is a symbolic execution tool that helps smart contract developers to detect possible vulnerabilities as a mitigation technique before the deployment. Oyente pursues the smart contracts execution paradigm in Ethereum blockchain and directly operates on the EVM bytecode without the need to access the high-level source code. The tool is open-source and is available for public use (\nLuu et al., 2016\n; \nLee, 2018\n).\nMythril\nMythril is a security analysis tool to analyze smart contracts\u2019 security issues in the Ethereum blockchain. It provides a different analysis of vulnerabilities in smart contracts based on symbolic code execution (\nPrechtel et al., 2019\n). Mythril works with EVM bytecode to detect cybersecurity vulnerabilities in smart contracts that are developed for EVM-compatible blockchains such as Ethereum and Tron. It uses taint analysis and symbolic execution to detect several vulnerabilities such as reentrancy and unprotected functions vulnerabilities (\nZhang et al., 2019\n).\nSecurify\nSecurify is a cybersecurity analyzer for smart contracts in the Ethereum blockchain that is fully automated and scalable and categorizes the contract behaviors into safe or unsafe based on a provided property. There are two steps in Securify analysis: the first is extracting semantic information from the code by symbolically analyzing the dependency graph of the smart contract; the second step is checking violation and compliance patterns that set the conditions to identify whether a property holds or not (\nTsankov et al., 2018\n).\nF* Framework\nF* framework is a verification method based on F* language offered by Microsoft Research. The smart contract is checked to see if it is correct by translating the code written in Solidity to F* language. Since the smart contracts\u2019 binary codes are available on the Ethereum network, whereas the source code is hard to obtain, the binary files on Ethereum blockchain are decompiled to F* language to identify possible vulnerabilities such as exception disorders and reentrancy vulnerabilities (\nLiu and Liu, 2019\n).\nSecurity Based on Programming Languages\nSeveral high-level programming languages are introduced to develop smart contracts securely. For instance, Obsidian is a state-oriented language that follows the states of the smart contracts to avoid reentrancy vulnerability and treats Ether as a linear resource to allow the compiler to track financial information. Currently, Obsidian is not ready for general use and still in the development stage (\nCoblenz, 2017\n).\nAnother example is Vyper that is also a high-level programming language that includes other new functionalities not supported by Solidity and eliminates some of the Solidity features. It includes new functionalities such as overflow checking and bounds, and it eliminates features such as modifiers and recursive calling. Vyper helps developers to avoid vulnerabilities such as integer underflow and overflow vulnerability and denial-of-service (DOS) with unbounded operations vulnerability (\nAdrian, 2018\n).\nSecurity Based on the Development of Smart Contracts\nThere are a few approaches to enhancing the programming model of smart contracts to aid developers in mitigating or avoiding reentrancy vulnerability. One of them, introduced by ConsenSys Diligence, is Ethereum smart contract best practices. This provides fundamental information about security considerations for Solidity programmers. Furthermore, various recommendations are provided to guide smart contract developers on Ethereum to avoid coding issues. Their recommendations are divided into two categories, namely, protocol-specific recommendations and Solidity-specific recommendations. Protocol-specific recommendations apply to any smart contract development on Ethereum to prevent reentrancy vulnerability, such as avoiding state changes after external calls. The other recommendations are the Solidity-specific recommendations, which might be informative for smart contract developers in other languages to prevent reentrancy attacks, such as using modifiers only for assertions (\nChen et al., 2020\n).\nLimitations of the Current Solutions\nThese solutions are generally based on a predefined specific pattern; when this pattern is detected, the vulnerability in the smart contract code is then detected.\nThe following limitations were found:\n\u2022 Detection tools that detect reentrancy vulnerability analyze the smart contract code based on predefined attack patterns, and if the patterns match any part in the code, then the tools discover the vulnerability. Thus, these approaches mainly rely on complete patterns and the specific quality of these patterns.\n\u2022 The patterns these solutions rely on are based on the observation of the previous attacks and known vulnerabilities, which makes them limited and difficult to generalize.\n\u2022 All the solutions are only applicable before the deployment of smart contracts. This means once the smart contract is deployed on the Ethereum network, these solutions cannot prevent reentrancy attacks and cannot detect the attacker.\n\u2022 If a new reentrancy pattern is introduced after the deployment of the smart contracts, these solutions need to be updated; otherwise, they will not be able to detect the new attack patterns.\nThe Proposed Solution\nWe have analyzed the root cause of reentrancy attack on the lack of integrity checking on smart contract balance and proposed a solution to overcome these limitations by providing a prevention technique to protect the smart contract and a detection technique to detect the attacker that is not based on any pattern and can be utilized after the deployment of the smart contract. This solution can differentiate between honest and malicious transactions, can be implemented within several approaches, and can be utilized on the current Ethereum platform.\nIn any smart contract that manages a fund for various participants, two values maintain the funds in the smart contract. The first value is maintained by the protocol layer, which is the contract \nbalance\n represented in Solidity as \naddress(this).balance\n, whereas the second value is maintained by the application layer, which is usually represented in Solidity as \nbalances[ParticipantAddress]\n, which maintains the balance of each participant in the smart contract. The contract balance and the total balance of all participants are not always the same; however, when any smart contract is initiated, the difference between them must always be the same after and before any operation in the smart contract that changes the state of the smart contract in order to protect the funds in the smart contract. This is because adversaries who want to launch a reentrancy attack are aiming to trick the smart contract in the application layer by decreasing the value that is maintained by the protocol layer and at the same time keeping the value that is maintained by the application layer as it is. The attackers do this because they can manipulate the smart contract in the application layer, but they cannot manipulate the value [\naddress(this).balance\n] maintained by the protocol layer because it is secured by the miners who maintain it. The only way the attacker can carry out such an attack is to trick the smart contract in the application layer, which will lead to change the difference between these two values, and if the attacker succeeds in this, then the attacker will be able to steal the funds and the smart contract will not be aware of the attack and will not be able to stop the attacker.\nThis solution is based on these two values, namely, the contract balance (noted as \na\n before the operation and \na\u2032\n after the operation) and the total balance of all participants in the smart contract (noted as \nb\n before operation and \nb\u2032\n after the operation). The solution simply calculates the difference between \na\n and \nb\n before and \na\u2032\n and \nb\u2032\n after each operation within a transaction in any smart contract. The transaction is noted as \nT\n and the difference before the operation is noted as \nx\n, whereas the difference after the operation is noted as \nx\u2032\n. If the difference is the same (\nx\n = \nx\u2032\n), then the operation is legitimate; otherwise, the operation is malicious. For instance, suppose that a smart contract has a reentrancy vulnerability and has 10 Ethers in its balance (\na\n = 10) and three participants, where two are honest and one is a malicious user who tries to exploit the vulnerability. Each of the honest participants has 2 Ethers in their balance; therefore, the total balance for all participants is 4 (\nb\n = 4). The difference, in this case, is 6 (\nx\n1\n = 6). The malicious participant conducts a reentrancy attack. The adversary sends \nT\n1\n to deposit 1 Ether to the contract; therefore, \na\u2032\n = 11, \nb\u2032\n = 5, \nx\n1\n = 6, and \nx\n1\n\u2032\n = 6. Since \nx\n1\n = \nx\n1\n\u2032\n, this transaction is not malicious. After that, the adversary sends \nT\n2\n to withdraw 1 Ether, utilizing the recursive function to exploit the reentrancy vulnerability. After the first operation in \nT\n2\n and before the second operation starts, the values will be \na\n = 11, \nb\n = 5, \na\u2032\n = 10, \nb\u2032\n = 5, \nx\n1\n = 6, and \nx\n1\n\u2032\n = 5. \nx\n1\n \u2260 \nx\n1\n\u2032\n because the execution did not reach the statement that decrements the balance of malicious user; therefore, \na\u2032\n will be decreased by 1; however, the \nb\u2032\n value will still be the same, as shown in \nFigure 1\n. This operation will be blocked, and the transaction will be considered a malicious transaction; therefore, the attacker\u2019s address will be stored by the solution.\n\n\n\n\n \n\n\n\n\nFIGURE 1\n. Reentrancy attack scenario.\nOur solution formula is as follows.\n\u2200 \nO\n \u2208 \nT\n: (\nO\n is valid) \u21d4 (\nx\n = \nx\u2032\n),\nwhere\nT\n = a transaction,\nO\n = an operation in the transaction that changes the smart contract state,\nx = a \u2013 b,\nx\n\u2032\n = a\n\u2032\n \u2013 b\n\u2032\n,\na\n = contract balance before \nO\n,\nb\n=\n\u2211\ni\n=\n1\nn\np\ni\n\u00a0before\u00a0\nO\n,\na\u2032\n = contract balance after \nO\n,\nb\n\u2032\n=\n\u2211\ni\n=\n1\nn\np\ni\n\u00a0after\n\u00a0\nO\n,\np\ni\n = the balance of participant \ni\n in the contract, and\nn\n = the number of participants in the contract.\nImplementation of the Solution\nThere are three approaches to implementing the architecture of the solution, as depicted in \nFigure 2\n. This solution can be implemented on the dApp layer (Approach 1), or on the blockchain layer as an independent smart contract (Approach 2) to control one or more smart contracts\u2019 behavior, or within a smart contract (Approach 3).\n\n\n\n\n \n\n\n\n\nFIGURE 2\n. Three approaches to implementing the architecture of the solution.\nIn Approach 1, the dApp layer is considered as a checkpoint that receives data from the smart contract. Based on these data, the dApp compares the difference between the stored value of the smart contract balance and the total balance of all participants and the difference between the current contract balance and the current total of all participants. If they match, the dApp sends the decision \u201ctrue\u201d to allow the operation in the transaction to be completed; otherwise, it sends \u201cfalse\u201d to block the operation of the transaction and notifies the smart contract owner by storing the attacker\u2019s address.\nApproach 2 is similar to Approach 1; however, another smart contract will play the dApp checkpoint role. All malicious operations in the transactions will be blocked and the smart contract owner will also be notified by storing the attacker\u2019s address in the contract.\nApproach 3 works within the smart contract itself, monitoring the operations that change the state of the smart contract; and if any malicious operation occurs, the smart contract will block the operation and the attacker address will be stored to notify the owner.\nFigure 3\n illustrates the solution data flow which is applicable in all three approaches.\n\n\n\n\n \n\n\n\n\nFiGURE 3\n. The solution data flow.\nThe first three steps in the data flow will happen during the initialization of the smart contract that needs the protection. The solution should obtain the smart contract balance and the total balance of all smart contracts\u2019 participants. The difference between these values should be calculated in the third step. All participants can interact with the smart contract in the fourth step and during the execution, the solution continuously monitors the smart contract balance and all participants balance before and after each operation that changes the smart contract state. In the seventh step, the solution calculates the difference again and compares the result with the stored result. If the results are equal, the value of \nx\n is changed to the value of \nx\u2032\n and the execution completes; otherwise, the execution is blocked and the smart contract owner will be notified by storing the address of the attacker in the contract. \nFigure 4\n shows an example of a UML class diagram of Approach 3, which can be applied for a bank smart contract.\n\n\n\n\n \n\n\n\n\nFIGURE 4\n. UML class diagram example for the solution applied to a bank contract.\nMonitoring the contract balance and all the participants\u2019 balances to prevent reentrancy vulnerability and detect the attacker can be implemented in various ways. This section will provide an example of the implementation of Approach 3 based on the previous UML class diagram, which is written by using the Solidity programming language as shown in \nFigure 5\n. There are six variables and eight functions with the constructor. Four variables are utilized by the solution: \nparticipantsLiquidity\n, \nbeforeOperation\n, \nafterOperation\n, and \nattacker\n. The reentrancy vulnerability is stated in the code in line (46) that may cause different invocations for different functions, which will be illustrated in the test scenarios in the next chapter. The contract owner is the only one who can retrieve the address of the attacker because of the modifier in line (20).\n\n\n\n\n \n\n\n\n\nFIGURE 5\n. The solution is implemented in the code of the bank smart contract.\nProof of Concept\nThe Testing Environment\nRemix IDE was used to host the test environment and to compile, deploy, debug, and test the solution. This test utilized the JavaScript VM environment, which emulates a real blockchain, to execute all the test transactions. All the smart contracts that were used in this test were written in the Solidity programming language. Two attack case studies were conducted: a single-function and a cross-function reentrancy attack. The single-function reentrancy attack case study contained three smart contracts, the \nBank{}\n, \nAttacker{},\n and \nBankWithoutSolution{}\n contracts. The \nBank{}\n and \nBankWithoutSolution{}\n contracts included a reentrancy vulnerability; however, the \nBank{}\n contract included the solution as shown in \nFigure 5\n in Section \nImplementation of the Solution,\n whereas the \nBankWithoutSolution{}\n contract did not use the solution. The \nAttacker{}\n contract included the malicious code that conducted the attacks. The second case study is the cross-function reentrancy attack case study, which included four smart contracts \nBank{}\n, \nAttacker1{}\n, \nBankWithoutSolution{},\n and \nAttacker2{}\n contracts. The \nBank{}\n and \nBankWithoutSolution{}\n contracts were the same as those in the first case study and the \nAttacker1{}\n contract was utilized to launch the attack, while the \nAttacker2{}\n contract was utilized to receive the stolen coin. Both case studies will be illustrated in detail in the following sections.\nThe Testing Scenario\nEach of the two case studies consists of two test scenarios, which are firstly conducting the attack without the solution and secondly conducting the attack with the solution. The \nBank{}\n and \nBankWithoutSolution{}\n contracts were funded by an individual account by 10 Ethers during the deployment. The first test scenario in each attack case study was conducted to see if the attacker was able to steal coins from the \nBankWithoutSolution{}\n contract and the second test scenario was conducted to see if the solution was able to detect and prevent the reentrancy attack from the \nBank{}\n contract.\nSingle-Function Reentrancy Attack Case Study\nThe \nAttacker{}\n contract as shown in \nFigure 6\n will be used in the following scenarios. The \nAttacker{}\n contract code in the first scenario will be changed in lines (90) and (94) from \nBank\n to \nBankWithoutSolution\n.\n\n\n\n\n \n\n\n\n\nFIGURE 6\n. The \nAttacker{}\n contract.\nFirst Test Scenario: Single-Function Attack (Without the Solution)\nThe first test scenario conducted a single-function reentrancy attack against \nBankWithoutSolution{}\n contract. The \nBankWithoutSolution{}\n contract code is shown in \nFigure 7\n, which contained the vulnerability in line (23).\n\n\n\n\n \n\n\n\n\nFIGURE 7\n. The \nBankWithoutSolution{}\n contract.\nThe attack sequence diagram for the first test scenario in the single-function reentrancy attack case study is shown in \nFigure 8\n. All the transactions and calls involved in the first test scenario are shown in \nSupplementary Appendix 1\n.\n\n\n\n\n \n\n\n\n\nFIGURE 8\n. UML sequence diagram for the first scenario in the first case study.\nThe scenario steps were as follows:\n1. Deploying the \nBankWithoutSolution{}\n contract with funds equal to 10 Ethers.\n2. Deploying the \nAttacker{}\n contract by passing the \nBankWithoutSolution{}\n contract address as a parameter in the \nAttacker{}\n constructor and with funds equal to 1 Ether.\n3. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check the balance, which is equal to1 Ether.\n4. Depositing 1 Ether from the \nAttacker{}\n contract to the \nBankWithoutSolution{}\n contract.\n5. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check that the balance is equal to 0 Ethers.\n6. Calling the \ngetBankLiquidity()\n function in the \nBankWithoutSolution{}\n contract to check that the balance is equal to 11 Ethers.\n7. Conducting the single-function reentrancy attack by calling the withdraw function in the \nAttacker{}\n contract.\n8. Calling the \ngetBankLiquidity()\n function in the \nBankWithoutSolution{}\n contract to check the balance, which is equal to 0 Ethers.\n9. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check the balance, which is equal to 11 Ethers.\nIn the first scenario, the single-function reentrancy attack succeeded in leveraging the reentrancy vulnerability and the attacker stole all the \nBankWithoutSolution{}\n contract funds.\nSecond Test Scenario: Single-Function Attack (With the Solution)\nThe second test scenario conducts a single-function reentrancy attack on the \nBank{}\n contract. The \nBank{}\n code is shown in \nFigure 5\n in Section \nImplementation of the Solution\n, which contains the vulnerability in line (46). The attack sequence diagram for the second test scenario in the single-function reentrancy attack case study is shown in \nFigure 9\n. All of the transactions and calls involved in the second test scenario are shown in \nSupplementary Appendix 2\n.\n\n\n\n\n \n\n\n\n\nFIGURE 9\n. UML sequence diagram for the second scenario in the first case study.\nThe scenario steps were as follows:\n1. Deploying the \nBank{}\n contract with funds equal to 10 Ethers.\n2. Deploying the \nAttacker{}\n contract by passing the \nBank{}\n contract address as a parameter in the \nAttacker{}\n constructor and with funds equal to 1 Ether.\n3. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check the balance, which is equal to 1 Ether.\n4. Depositing 1 Ether from the \nAttacker{}\n contract to the \nBank{}\n contract.\n5. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check that the balance is equal to 0 Ethers.\n6. Calling the \ngetBankLiquidity()\n function in the \nBank{}\n contract to check that the balance is equal to 11 Ethers.\n7. Conducting the single-function reentrancy attack by calling the withdraw function in the \nAttacker{}\n contract.\n8. Calling the \ngetBankLiquidity()\n function in the \nBank{}\n contract to check the balance, which is equal to 10 Ethers.\n9. Calling the \ngetAttackerBalance()\n function in the \nAttacker{}\n contract to check the balance, which is equal to 1 Ether.\n10. Calling the \ngetAttackerAddress()\n in the \nBank{}\n contract from the owner account to retrieve the attacker address.\nIn the second scenario, the single-function reentrancy attack failed to leverage the reentrancy vulnerability and the \nAttacker{}\n address was stored in the \nBank{}\n contract.\nCross-Function Reentrancy Attack Case Study\nThe \nAttacker1{}\n and \nAttacker2{}\n contracts as shown in \nFigure 10\n were utilized in the following scenarios. The \nAttacker1{}\n and \nAttacker2{}\n contracts code in the first scenario were changed in lines (86) and (91) in \nAttacker1{}\n and line (123) in \nAttacker2{}\n from \nBank\n to \nBankWithoutSolution\n.\n\n\n\n\n \n\n\n\n\nFIGURE 10\n. The \nAttacker1{}\n and \nAttacker2{}\n contracts code.\nFirst Test Scenario: Cross-Function Attack (Without the Solution)\nThe first test scenario launched a cross-function reentrancy attack on the \nBankWithoutSolution{}\n contract. The \nBankWithoutSolution{}\n code is shown in \nFigure 7\n, which contained the vulnerability in line (23). The attack sequence diagram for the first test scenario in the cross-function reentrancy attack case study is shown in \nFigure 11\n. All the transactions and calls involved in the first test scenario are shown in \nSupplementary Appendix 3\n.\n\n\n\n\n \n\n\n\n\nFIGURE 11\n. UML sequence diagram for the first scenario in the second case study.\nThe scenario steps were as follows:\n1. Deploying the \nBankWithoutSolution{}\n contract with funds equal to 10 Ethers.\n2. Deploying the \nAttacker1{}\n contract by passing the \nBankWithoutSolution{}\n contract address as a parameter in the \nAttacker1{}\n constructor and with funds equal to 10 Ethers.\n3. Deploying the \nAttacker2{}\n contract by passing the \nBankWithoutSolution{}\n contract address as a parameter in the \nAttacker2{}\n constructor.\n4. Calling the \ngetAttackerBalance()\n function in the \nAttacker2{}\n contract to check the balance, which is equal to 0 Ethers.\n5. Depositing 10 Ethers from the \nAttacker1{}\n contract to the \nBankWithoutSolution{}\n contract.\n6. Calling the \ngetAttackerBalance()\n function in the \nAttacker1{}\n contract to check that the balance is equal to 0 Ethers.\n7. Calling the \ngetBankLiquidity()\n function in the \nBankWithoutSolution{}\n contract to check that the balance is equal to 20 Ethers.\n8. Calling the \nsetAttacker2()\n function in the \nAttacker1{}\n contract and passing the \nAttacker2{}\n contract address as a parameter.\n9. Conducting the cross-function reentrancy attack by calling the \nwithdraw()\n function in the \nAttacker1{}\n contract.\n10. Calling \nwithdraw()\n function in the \nAttacker2{}\n contract to steal 10 Ethers.\n11. Calling the \ngetBankLiquidity()\n function in the \nBankWithoutSolution{}\n contract to check the balance, which is equal to 0 Ethers.\n12. Calling the \ngetAttackerBalance()\n function in the \nAttacker1{}\n contract to check the balance, which is equal to 10 Ethers.\n13. Calling the \ngetAttackerBalance()\n function in the \nAttacker2{}\n contract to check the balance, which is equal to 10 Ethers.\nIn the first scenario, the cross-function reentrancy attack succeeded in leveraging the reentrancy vulnerability, and the \nAttacker2{}\n contract withdrew 10 Ethers even though the contract did not have any funds in the \nBankWithoutSolution{}\n contract.\nSecond Test Scenario: Cross-Function Attack (With the Solution)\nThe second test scenario conducted a cross-function reentrancy attack against the \nBank{}\n contract. The \nBank{}\n contract code is shown in \nFigure 5\n in the \nImplementation of the Solution\n section, which contained the vulnerability in line (46). The attack sequence diagram for the second test scenario in the cross-function reentrancy attack case study is shown in \nFigure 12\n. All the transactions and calls involved in the second test scenario are shown in \nSupplementary Appendix 4\n.\n\n\n\n\n \n\n\n\n\nFIGURE 12\n. UML sequence diagram for the second scenario in the second case study.\nThe scenario steps were as follows:\n1. Deploying the \nBank{}\n contract with funds equal to 10 Ethers.\n2. Deploying the \nAttacker1{}\n contract by passing the \nBank{}\n contract address as a parameter in the \nAttacker1{}\n constructor and with funds equal to 10 Ethers.\n3. Deploying the \nAttacker2{}\n contract by passing the \nBank{}\n contract address as a parameter in the \nAttacker2{}\n constructor.\n4. Calling the \ngetAttackerBalance()\n function in the \nAttacker2{}\n contract to check the balance, which is equal to 0 Ethers.\n5. Depositing 10 Ethers from the \nAttacker1{}\n contract to the \nBank{}\n contract.\n6. Calling the \ngetAttackerBalance()\n function in the \nAttacker1{}\n contract to check that the balance is equal to 0 Ethers.\n7. Calling the \ngetBankLiquidity()\n function in the \nBank{}\n contract to check that the balance is equal to 20 Ethers.\n8. Calling the \nsetAttacker2()\n function in the \nAttacker1{}\n contract and passing the \nAttacker2{}\n contract address as a parameter.\n9. Conducting the cross-function reentrancy attack by calling the \nwithdraw()\n function in the \nAttacker1{}\n contract.\n10. Calling \nwithdraw()\n function in the \nAttacker2{}\n contract to steal 10 Ethers, which will fail because there are no funds for \nAttacker2{}\n in the \nBank{}\n contract.\n11. Calling the \ngetBankLiquidity()\n function in the \nBank{}\n contract to check the balance, which is equal to 10 Ethers.\n12. Calling the \ngetAttackerBalance()\n function in the \nAttacker1{}\n contract to check the balance, which is equal to 10 Ethers.\n13. Calling the \ngetAttackerBalance()\n function in the \nAttacker2{}\n contract to check the balance, which is equal to 0 Ethers, indicating that the attack is failed.\n14. Calling the \ngetAttackerAddress()\n in the \nBank{}\n contract from the owner account to retrieve the attacker address.\nIn the second scenario, the cross-function reentrancy attack failed in leveraging the reentrancy vulnerability, and the \nAttacker1{}\n address is stored in the \nBank{}\n contract.\nThe two scenarios in the two case studies followed the same attack steps and the solution, which is based on monitoring the difference between the contract balance and total of all participants\u2019 balances, proved that it can prevent the reentrancy attack during the execution time even though the reentrancy vulnerability existed in the contract. Additionally, the solution detected the attacker by storing its account address, which is accessible only by the targeted contract owner.\nDiscussion\nFrom the previous two experiments, the proposed solution can produce the following positive results:\nTest case 1: single-function reentrancy attack, the proposed solution is successful in detecting the attacker and preventing the attack.\nTest case 2: cross-function reentrancy attack, the proposed solution is successful in detecting the attacker and preventing the attack\nThe solution\u2019s hypothesis relies on the fact that the difference between the two values, the contract balance and the total of all participants\u2019 balances, must be the same before and after any operation that changes the state of any contract. The solution can be implemented in different layers, as shown in the solution architecture, and can be implemented in different programming languages. Unlike the current defensive methodologies for reentrancy vulnerability, the proposed solution can work during the execution time after the smart contract deployment and can detect the attacker by recording its account address. The solution can be implemented in different ways; however, the main concept of the solution must be the same, which is based on monitoring the two values. The proposed solution can provide a secure and reentrancy-free Ethereum network. This solution targets the reentrancy vulnerability, which is one of the vulnerabilities in the Solidity layer.\nConclusion and Future Research\nOur solution is based on the fact that the difference between the two values, the contract balance and the total balance of all participants, must be the same before and after any operation that changes the state of a contract. The solution can be implemented using different approaches and in different programming languages. Unlike the current defensive methods against reentrancy attacks, this solution works during execution, that is, after the smart contract is deployed, and can identify an attacker.\nThis article has analyzed the root cause of Ethereum reentrancy attacks and has proposed a solution with a proof-of-concept implementation, which can detect, prevent, and identify the account address of an attacker during the execution of a smart contract.\nThe result of this research prompts several possible future studies in enhancing the security of Ethereum. Firstly, the solution relies on the smart contract developers, a protocol layer solution can be established to protect all the smart contracts on the Ethereum network. The miners can check the transactions using this solution and if the transaction is considered malicious based on the solution, the miners can reject the transaction. Secondly, we invite the Ethereum community research validating the solution in the other approaches suggested here. This would evaluate the solution in different environments and measure the efficiency of these approaches to find what the best approach is in terms of security and efficiency. Finally, we shall extend this solution to detect and prevent other known smart contract vulnerabilities during the execution time through self-protection techniques carried out by the smart contract in case of attack. Since the smart contract is immutable against modification after the deployment, this research direction is very important.\nThere are many challenges to improving the security of smart contracts. A simple code flaw can have catastrophic results for a smart contract holding huge funds. Therefore, the industry and academia need to invest in future research to help create a more trustworthy Ethereum blockchain and improve the security of smart contracts.\nData Availability Statement\nThe original contributions presented in the study are included in the article/\nSupplementary Material\n; further inquiries can be directed to the corresponding author.\nAuthor Contributions\nAll authors listed have made a substantial, direct, and intellectual contribution to the work and approved it for publication.\nConflict of Interest\nThe authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.\nSupplementary Material\nThe Supplementary Material for this article can be found online at: \nhttps://www.frontiersin.org/articles/10.3389/fcomp.2021.598780/full#supplementary-material\n.\nReferences\nAdrian, O. R. (2018). \u201cThe blockchain, today and tomorrow,\u201d in \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nTimisoara, Romania\n, \nSeptember 20\u201323, 2018\n (\nIEEE\n), 458\u2013462. \nGoogle Scholar\nAlkhalifah, A., Ng, A., Chowdhury, M. J. M., Kayes, A. S. M., and Watters, P. A. (2019). \u201cAn empirical analysis of blockchain cybersecurity incidents,\u201d in \n2019 IEEE Asia-Pacific conference on computer science and data engineering (CSDE)\n, \nMelbourne, Australia\n, \nDecember 9\u201311, 2019\n (\nIEEE\n), 1\u20138. doi:10.1109/CSDE48274.2019.9162381\nCrossRef Full Text\n | \nGoogle Scholar\nAlkhalifah, A., Ng, A., Kayes, A. S. M., Chowdhury, J., Alazab, M., and Watters, P. A. (2020). \u201cA taxonomy of blockchain threats and vulnerabilities,\u201d in \nBlockchain for cybersecurity and privacy: architectures, challenges and applications\n. (Boca Raton, FL: \nCRC Press Taylor & Francis\n), Chap. 1, 1\u201327. \nGoogle Scholar\nChen, H., Pendleton, M., Njilla, L., and Xu, S. (2020). A survey on Ethereum systems security. \nACM Comput. Surv.\n 53 (3), 1\u201343. doi:10.1145/3391195\nCrossRef Full Text\n | \nGoogle Scholar\nCoblenz, M. (2017). \u201cObsidian: a safer blockchain programming language,\u201d in \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nBuenos Aires, Argentina\n, \nMay 20\u201328, 2017\n (\nIEEE\n), 97\u201399. \nGoogle Scholar\nDika, A., and Nowostawski, M. (2018). \u201cSecurity vulnerabilities in Ethereum smart contracts,\u201din \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nHalifax, NS\n, \nJuly 30\u2013August 3, 2018\n (\nIEEE\n), 955\u2013962. \nGoogle Scholar\nHung, C., Chen, K., and Liao, C. (2019). \u201cModularizing cross-cutting concerns with aspect-oriented extensions for solidity,\u201d in \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nNewark, CA\n, \nApril 4\u20139, 2019\n (\nIEEE\n), 176\u2013181. \nGoogle Scholar\nLee, J. (2018). Patch transporter: incentivized, decentralized software patch system for WSN and IoT environments. \nSensors\n 18 (2), 574. doi:10.3390/s18020574\nCrossRef Full Text\n | \nGoogle Scholar\nLiu, J., and Liu, Z. (2019). A survey on security verification of blockchain smart contracts. \nIEEE Access.\n 7, 77894\u201377904. doi:10.1109/access.2019.2921624\nCrossRef Full Text\n | \nGoogle Scholar\nLuu, L., Chu, D. H., Olickel, H., Saxena, P., and Hobor, A. (2016). \u201cMaking smart contracts smarter,\u201d in \nACM SIGSAC conference on computer and communications security\n, \nVienna, Austria\n, \nOctober 25\u201327, 2016\n, (\nACM)\n, 254\u2013269. \nGoogle Scholar\nMadnick, S. (2020). Blockchain isn\u2019t as unbreakable as you think. \nMIT Sloan Manag. Rev.\n 61 (2), 65\u201370. doi:10.2139/ssrn.3542542\nGoogle Scholar\nPrechtel, D., Gros, T., and Muller, T. (2019). \u201cEvaluating spread of \u201cgasless send\u201d in Ethereum smart contracts,\u201d in \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nCanary Islands, Spain\n, \nJune 24\u201326, 2019\n (\nIEEE\n), 1\u20136. \nGoogle Scholar\nSamreen, N. F., and Alalfi, M. H. (2020). \u201cReentrancy vulnerability identification in Ethereum smart contracts,\u201d \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nLondon, ON\n, \nFebruary 18, 2020\n (\nIEEE\n), 22\u201329. \nGoogle Scholar\nSchrans, F., Eisenbach, S., and Drossopoulou, S. (2018). \u201cWriting safe smart contracts in flint,\u201d in \nConference companion of the 2nd international conference on art, science, and engineering of programming\n, \nNew York, NY\n, \nApril 9, 2018\n \nACM\n, 218\u2013219. \nGoogle Scholar\nTikhomirov, S., Voskresenskaya, E., Ivanitskiy, I., Takhaviev, R., Marchenko, E., and Alexandrov, Y. (2018). \u201cSmartCheck: static analysis of Ethereum smart contracts,\u201d \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nGothenburg, Sweden\n, \nMay 27\u2013June 3, 2018\n (\nIEEE\n), 9\u201316. \nGoogle Scholar\nTsankov, P., Dan, A., Drachsler-Cohen, D., Gervais, A., Buenzli, F., and Vechev, M. (2018). \u201cSecurify: practical security analysis of smart contracts,\u201d in \n2018 ACM SIGSAC conference on computer and communications security\n, \nToronto, ON\n, \nOctober 15\u201319, 2018\n (\nACM\n), 67\u201382. \nGoogle Scholar\nZhang, W., Banescu, S., Pasos, L., Stewart, S., and Ganesh, V. (2019). \u201cMPro: combining static and symbolic analysis for scalable testing of smart contract,\u201d in \nThe institute of electrical and electronics engineers, Inc.(IEEE) conference proceedings\n, \nBerlin, Germany\n, \nOctober 28\u201331, 2019\n (\nIEEE\n), 456\u2013462. \nGoogle Scholar"
    }
}