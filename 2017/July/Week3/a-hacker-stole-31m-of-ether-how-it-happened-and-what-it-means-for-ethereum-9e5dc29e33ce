{
    "threat_intelligence": {
        "url": "https://www.freecodecamp.org/news/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce/",
        "timestamp": "2017-07-20 00:00:00",
        "original_content": "A hacker stole $31M of Ether - how it happened, and what it means for Ethereum\nfreeCodeCamp\nfreeCodeCamp\nA hacker stole $31M of Ether - how it happened, and what it means for Ethereum\nBy Haseeb Qureshi\n\nYesterday, a hacker pulled off the second biggest heist in the history of digital currencies.\n\nAround 12:00 PST, an unknown attacker exploited a critical flaw in the Parity multi-signature wallet on the Ethereum network, draining three massive wallets of over $31,000,000 worth of Ether in a matter of minutes. Given a couple more hours, the hacker could\u2019ve made off with over $180,000,000 from vulnerable wallets.\n\nBut someone stopped them.\n\nHaving sounded the alarm bells, a group of benevolent white-hat hackers from the Ethereum community rapidly organized. They analyzed the attack and realized that there was no way to reverse the thefts, yet many more wallets were vulnerable. Time was of the essence, so they saw only one available option: hack the remaining wallets before the attacker did.\n\nBy exploiting the same vulnerability, the white-hats hacked all of the remaining at-risk wallets and drained their accounts, effectively preventing the attacker from reaching any of the remaining $150,000,000.\n\nYes, you read that right.\n\nTo prevent the hacker from robbing any more banks, the white-hats wrote software to rob all of the remaining banks in the world. Once the money was safely stolen, they began the process of returning the funds to their respective account holders. The people who had their money saved by this heroic feat are now in the process of retrieving their funds.\n\nIt\u2019s an extraordinary story, and it has significant implications for the world of cryptocurrencies.\n\nIt\u2019s important to understand that this exploit was not a vulnerability in Ethereum or in Parity itself. Rather, it was a vulnerability in the default smart contract code that the Parity client gives the user for deploying multi-signature wallets.\n\nThis is all pretty complicated, so to make the details of this clear for everyone, this post is broken into three parts:\n\nWhat exactly happened? An explanation of Ethereum, smart contracts, and multi-signature wallets.\nHow did they do it? A technical explanation of the attack (specifically for programmers).\nWhat now? The attack\u2019s implications about the future and security of smart contracts.\nIf you are familiar with Ethereum and the crypto world, you can skip to the second section.\n\n1. What exactly happened?\nThere are three building blocks to this story: Ethereum, smart contracts, and digital wallets.\n\nImage\n\nEthereum is a digital currency invented in 2013 - a full 4 years after the release of Bitcoin. It has since grown to be the second largest digital currency in the world by market cap - $20 billion, compared to Bitcoin\u2019s $40 billion.\n\nLike all cryptocurrencies, Ethereum is a descendant of the Bitcoin protocol, and improves on Bitcoin\u2019s design. But don\u2019t be fooled: though it is a digital currency like Bitcoin, Ethereum is much more powerful.\n\nWhile Bitcoin uses its blockchain to implement a ledger of monetary transactions, Ethereum uses its blockchain to record state transitions in a gigantic distributed computer. Ethereum\u2019s corresponding digital currency, ether, is essentially a side effect of powering this massive computer.\n\nTo put it another way, Ethereum is literally a computer that spans the entire world. Anyone who runs the Ethereum software on their computer is participating in the operations of this world-computer, the Ethereum Virtual Machine (EVM). Because the EVM was designed to be Turing-complete (ignoring gas limits), it can do almost anything that can be expressed in a computer program.\n\nLet me be emphatic: this is crazy stuff. The crypto world is ebullient about the potential of Ethereum, which has seen its value skyrocket in the last 6 months.\n\nImage\n\nThe developer community has rallied behind it, and there\u2019s a lot of excitement about what can be built on top of the EVM - and this brings us to smart contracts.\n\nSmart contracts are simply computer programs that run on the EVM. In many ways, they are like normal contracts, except they don\u2019t need lawyers or judges to interpret them. Instead, they are compiled to bytecode and interpreted unambiguously by the EVM. With these programs, you can (among other things) programmatically transfer digital currency based solely on the rules of the contract code.\n\nOf course, there are things normal contracts do that smart contracts can\u2019t - smart contracts can\u2019t easily interact with things that aren\u2019t on the blockchain. But smart contracts can also do things that normal contracts can\u2019t, such as enforce a set of rules entirely through unbreakable cryptography.\n\nThis leads us to the notion of wallets. In the world of digital currencies, wallets are how you store your assets. You gain access to your wallet using essentially a secret password, also known as your private key (simplified a bit).\n\nThere are many different types of wallets that confer different security properties, such as withdrawal limits. One of the most popular types is the multi-signature wallet.\n\nIn a multi-signature wallet, there are several private keys that can unlock the wallet, but just one key is not enough to unlock it. If your multi-signature wallet has 3 keys, for example, you can specify that at least 2 of the 3 keys must be provided to successfully unlock it.\n\nThis means that if you, your father, and your mother are each signatories on this wallet, even if a criminal hacked your mother and stole her private key, they could still not access your funds. This leads to much stronger security guarantees, so multi-sigs are a standard in wallet security.\n\nThis is the type of wallet the hacker attacked.\n\nSo what went wrong? Did they break the private keys? Did they use a quantum computer, or some kind of cutting-edge factoring algorithm?\n\nNope, all the cryptography was sound. The exploit was almost laughably simple: they found a programmer-introduced bug in the code that let them re-initialize the wallet, almost like restoring it to factory settings. Once they did that, they were free to set themselves as the new owners, and then walk out with everything.\n\n2. How did this happen?\nWhat follows is a technical explanation of exactly what happened. If you\u2019re not a developer, feel free to skip to the next section, since this is going to be programming-heavy.\n\nEthereum has a fairly unique programming model. On Ethereum, you write code by publishing contracts (which you can think of as objects), and transactions are executed by calling methods on these objects to mutate their state.\n\nIn order to run code on Ethereum, you need to first deploy the contract (the deployment is itself a transaction), which costs a small amount of Ether. You then need to call methods on the contract to interact with it, which costs more Ether. As you can imagine, this incentivizes a programmer to optimize their code, both to minimize transactions and minimize computation costs.\n\nOne way to reduce costs is to use libraries. By making your contract call out to a shared library that was deployed at a previous time, you don\u2019t have to re-deploy any shared code. In Ethereum, keeping your code DRY will directly save you money.\n\nThe default multi-sig wallet in Parity did exactly this. It held a reference to a shared external library which contained wallet initialization logic. This shared library is referenced by the public key of the library contract.\n\n// FIELDSaddress constant _walletLibrary = 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3;\nThe library is called in several places, via an EVM instruction called DELEGATECALL, which does the following: for whatever method that calls DELEGATECALL, it will call the same method on the contract you're delegating to, but using the context of the current contract. It's essentially like a super call, except without the inheritance part. (The equivalent in JavaScript would be OtherClass.functionName.apply(this, args).)\n\nHere\u2019s an example of this in their multi-sig wallet: the isOwner method just delegates to the shared wallet library's isOwner method, using the current contract's state:\n\nfunction isOwner(address _addr) constant returns (bool) {    return _walletLibrary.delegatecall(msg.data);}\nThis is all innocent enough. The multi-sig wallet itself contained all of the right permission checks, and they were sure to rigorously enforce authorization on all sensitive actions related to the wallet\u2019s state.\n\nBut they made one critical mistake.\n\nSolidity allows you to define a \"fallback method.\" This is the method that gets called when there\u2019s no method that matches a given method name. You define it by not giving it a name:\n\nfunction() {    // do stuff here for all unknown methods}\nThe Parity team decided to let any unknown method that sent Ether to the contract just default to depositing the sent Ether.\n\nfunction() payable {    // payable is just a keyword that means this method can receive/pay Ether\nif (msg.value > 0) {    // just being sent some cash?    Deposit(msg.sender, msg.value);    } else {    throw;  }}\nBut they took it a step further, and herein was their critical mistake. Below is the actual code that was attacked.\n\nfunction() payable {    // just being sent some cash?  if (msg.value > 0)    Deposit(msg.sender, msg.value);  else if (msg.data.length > 0)    _walletLibrary.delegatecall(msg.data);}\nBasically:\n\nIf the method name is not defined on this contract\u2026\nAnd there\u2019s no ether being sent in the transaction\u2026\nAnd there is some data in the message payload\u2026\nThen it will call the exact same method if it\u2019s defined in _walletLibrary, but in the context of this contract.\n\nUsing this, the attacker called a method called initWallet(), which was not defined on the multisig contract but was defined in the shared wallet library:\n\nfunction initWallet(address[] _owners, uint _required, uint _daylimit) {    initDaylimit(_daylimit);  initMultiowned(_owners, _required);}\nWhich calls the initMultiowned method...\n\nfunction initMultiowned(address[] _owners, uint _required) {    m_numOwners = _owners.length + 1;  m_owners[1] = uint(msg.sender);  m_ownerIndex[uint(msg.sender)] = 1;  for (uint i = 0; i < _owners.length; ++i)  {    m_owners[2 + i] = uint(_owners[i]);    m_ownerIndex[uint(_owners[i])] = 2 + i;  }  m_required = _required;}\nDo you see what just happened there? The attacker essentially reinitialized the contract by delegating through the library method, overwriting the owners on the original contract. They and whatever array of owners they supply as arguments will be the new owners.\n\nGiven that they now control the entire wallet, they can trivially extract the remainder of the balance. And that\u2019s precisely what they did.\n\nThe initWallet: https://etherscan.io/tx/0x707aabc2f24d756480330b75fb4890ef6b8a26ce0554ec80e3d8ab105e63db07\n\nThe transfer:\nhttps://etherscan.io/tx/0x9654a93939e98ce84f09038b9855b099da38863b3c2e0e04fd59a540de1cb1e5\n\nSo what was ultimately the vulnerability? You could argue there were two. First, the initWallet and initMultiowned in the wallet library were not marked as internal (this is like a private method, which would prevent this delegated call), and those methods did not check that the wallet wasn't already initialized. Either check would've made this hack impossible.\n\nThe second vulnerability was the raw delegateCall. You can think of this as equivalent to a raw eval statement, running on a user-supplied string. In an attempt to be succinct, this contract used metaprogramming to proxy potential method calls to an underlying library. The safer approach here would be to whitelist specific methods that the user is allowed to call.\n\nThe trouble, of course, is that this is more expensive in gas costs (since it has to evaluate more conditionals). But when it comes to security, we probably have to get over this concern when writing smart contracts that move massive amounts of money.\n\nSo that was the attack.\n\nIt was a clever catch, but once you point it out, it seems almost elementary. The attacker then jumped on this vulnerability for three of the largest wallets they could find - but judging from the transaction times, they were doing this entirely manually.\n\nThe white-hat group was doing this at scale using scripts, and that\u2019s why they were able to beat the attacker to the punch. Given this, it\u2019s unlikely that the attacker was very sophisticated in how they planned their attack.\n\nYou might ask the question though - why don\u2019t they just roll back this hack, like they did with the DAO hack?\n\nUnfortunately that\u2019s not really possible. The DAO hack was unique in that when the attacker drained the DAO into a child DAO, the funds were frozen for many days inside a smart contract before they could be released to the attacker.\n\nThis prevented any of the stolen funds from going into circulation, so the stolen Ether was effectively siloed. This gave the Ethereum community plenty of time to conduct a public quorum about how to deal with the attack.\n\nIn this attack, the attacker immediately stole the funds and could start spending them. A hard fork would be impractical-what do you do about all of the transactions that occur downstream? What about the people who innocently traded assets with the attacker? Once the ether they\u2019ve stolen gets laundered and enters general circulation, it\u2019s like counterfeit bills circulating in the economy - it\u2019s easy to stop when it\u2019s all in one briefcase, but once everyone\u2019s potentially holding a counterfeit bill, you can\u2019t really turn back the clock anymore.\n\nSo the transaction won\u2019t get reversed. The $31M loss stands. It\u2019s a costly, but necessary lesson.\n\nSo what should we take away from this?\n\n3. What does this attack mean for Ethereum?\nThere are several important takeaways here.\n\nFirst, remember, this was not a flaw in Ethereum or in smart contracts in general. Rather, it was a developer error in a particular contract.\n\nSo who were the crackpot developers who wrote this? They should\u2019ve known better, right?\n\nThe developers here were a cross-collaboration between the Ethereum foundation (literally the creators of Ethereum), the Parity core team, and members of the open-source community. It underwent extensive peer review. This is basically the highest standard of programming that exists in the Ethereum ecosystem.\n\nThese developers were human. They made a mistake. And so did the reviewers who audited this code.\n\nI\u2019ve read some comments on Reddit and HackerNews along the lines of: \"What an obvious mistake! How was it even possible they missed this?\" (Ignoring that the \"obvious\" vulnerability was introduced in January and only now discovered.)\n\nWhen I see responses like this, I know the people commenting are not professional developers. For a serious developer, the reaction is instead: damn, that was a dumb mistake. I\u2019m glad I wasn\u2019t the one who made it.\n\nMistakes of this sort are routinely made in programming. All programs carry the risk of developer error. We have to throw off the mindset of \"if they were just more careful, this wouldn\u2019t have happened.\" At a certain scale, carefulness is not enough.\n\nAs programs scale to non-trivial complexity, you have to start taking it as a given that programs are probably not correct. No amount of human diligence or testing is sufficient to prevent all possible bugs. Even organizations like Google or NASA make programming mistakes, despite the extreme rigor they apply to their most critical code.\n\nWe would do well to take a page from site reliability practices at companies like Google and Airbnb. Whenever there\u2019s a production bug or outage, they do a postmortem analysis and distribute it within the company. In these postmortems, there is always a principle of never blaming individuals.\n\nBlaming mistakes on individuals is pointless, because all programmers, no matter how experienced, have a nonzero likelihood of making a mistake. Instead, the purpose of a postmortem is to identify what in the process allowed that mistake to get deployed.\n\nThe problem was not that the developer forgot to add internal to the wallet library, or that they did a raw delegateCall without checking what method was being called.\n\nThe problem is that their programming toolchain allowed them to make these mistakes.\n\nAs the smart contract ecosystem evolves, it has to evolve in the direction of making these mistakes harder, and that means making contracts secure by default.\n\nThis leads me to my next point.\n\nStrength is a weakness when it comes to programming languages. The stronger and more expressive a programming language is, the more complex its code becomes. Solidity is a very complex language, modeled to resemble Java.\n\nComplexity is the enemy of security. Complex programs are more difficult to reason about and harder to identify edge cases for. I think that languages like Viper (maintained by Vitalik Buterin) are a promising step in this direction. Viper includes by default basic security mechanisms, such as bounded looping constructs, no integer overflows, and prevents other basic bugs that developers shouldn\u2019t have to reason about.\n\nThe less the language lets you do, the easier it is to analyze and prove properties of a contract. Security is hard because the only way to prove a positive statement like \"this contract is secure\" is to disprove every possible attack vector: \"this contract cannot be re-initialized,\" \"its funds cannot be accessed except by the owners,\" etc. The fewer possible attack vectors you have to consider, the easier it is to develop a secure contract.\n\nA simpler programming model also allows things like formal verification and automatic test generation. These are areas under active research, but just as smart contracts have incorporated cutting-edge cryptography, they also should start incorporating the leading edge of programming language design.\n\nThere is a bigger lesson here too.\n\nMost of the programmers who are getting into this space, myself included, come from a web development background, and the blockchain toolchain is designed to be familiar for web developers. Solidity has achieved tremendous adoption in the developer community because of its familiarity to other forms of programming. In a way, this may end up being its downfall.\n\nThe problem is, blockchain programming is fundamentally different from web development.\n\nLet me explain.\n\nBefore the age of the client-server web model, most programming was done for packaged consumer software or on embedded systems. This was before the day of automatic software updates. In these programs, a shipped product was final - you released one form of your software every 6 months, and if there was a bug, that bug would have to stand until the next release. Because of this longer development cycle, all software releases were rigorously tested under all conceivable circumstances.\n\nWeb development is far more forgiving. When you push bad code to a web server, it\u2019s not a big deal if there\u2019s a critical mistake - you can just roll back the code, or roll forward with a fix, and all is well because you control the server. Or if the worst happens and there\u2019s an active breach or a data leak, you can always stop the bleeding by shutting off your servers and disconnecting yourself from the network.\n\nThese two development models are fundamentally different. It\u2019s only out of something like web development that you can get the motto \"move fast and break things.\"\n\nMost programmers today are trained on the web development model. Unfortunately, the blockchain security model is more akin to the older model.\n\nIn blockchain, code is intrinsically unrevertible. Once you deploy a bad smart contract, anyone is free to attack it as long and hard as they can, and there\u2019s no way to take it back if they get to it first. Unless you build intelligent security mechanisms into your contracts, if there\u2019s a bug or successful attack, there\u2019s no way to shut off your servers and fix the mistake. Being on Ethereum by definition means everyone owns your server.\n\nA common saying in cybersecurity is \"attack is always easier than defense.\" Blockchain sharply multiplies this imbalance. It\u2019s far easier to attack because you have access to the code of every contract, know how much money is in it, and can take as long as you want to try to attack it. And once your attack is successful, you can potentially steal all of the money in the contract.\n\nImagine that you were deploying software for vending machines. But instead of a bug allowing you to simply steal candy from one machine, the bug allowed you to simultaneously steal candy from every machine in the world that employed this software. Yeah, that\u2019s how blockchain works.\n\nIn the case of a successful attack, defense is extremely difficult. The white-hats in the Parity hack demonstrated how limited their defense options were - there was no way to secure or dismantle the contracts, or even to hack back the stolen money; all they could do was hack the remaining vulnerable contracts before the attacker did.\n\nThis might seem to spell a dark future.\n\nBut I don\u2019t think this is a death knell for blockchain programming. Rather, it confirms what everyone already knows: this ecosystem is young and immature. It\u2019s going to take a lot of work to develop the training and discipline to treat smart contracts the way that banks treat their ATM software. But we\u2019re going to have to get there for blockchain to be successful in the long run.\n\nThis means not just programmers maturing and getting more training. It also means developing tools and languages that make all of this easier, and give us rigorous guarantees about our code.\n\nIt\u2019s still early. Ethereum is a work in progress, and it\u2019s changing rapidly. You should not treat Ethereum as a bank or as a replacement for financial infrastructure. And certainly you should not store any money in a hot wallet that you\u2019re not comfortable losing.\n\nBut despite all that, I still think Ethereum is going to win in the long run. And here\u2019s why: the developer community in Ethereum is what makes it so powerful.\n\nEthereum will not live or die because of the money in it. It will live or die based on the developers who are fighting for it.\n\nThe league of white-hats who came together and defended the vulnerable wallets didn\u2019t do it for money. They did it because they believe in this ecosystem. They want Ethereum to thrive. They want to see their vision of the future come true. And after all the speculation and the profiteering, it\u2019s ultimately these people who are going to usher the community into its future. They are fundamentally why Ethereum will win in the long run-or if they abandon Ethereum, their abandonment will be why it loses.\n\nThis attack is important. It will shake people up. It will force the community to take a long, hard look at security best practices. It will force developers to treat smart contract programming with far more rigor than they currently do.\n\nBut this attack hasn\u2019t shaken the strength of the builders who are working on this stuff. So in that sense it\u2019s a temporary setback.\n\nIn the end, attacks like this are good for the community to grow up. They call you to your senses and force you to keep your eyes open. It hurts, and the press will likely make a mess of the story. But every wound makes the community stronger, and gets us closer to really deeply understanding the technology of blockchain - both its dangers, and its amazing potential.\n\nP.S. If you\u2019re a dev and you want to learn more about smart contract security, this is a really good resource.\n\n_Errata: This article originally said that Gavin Wood was the developer of the contract, which is incorrect. Gavin is the founder of Parity and pushed the fix to the contract, but was not the original developer. It also originally claimed that $77M additional funds were vulnerable, but this doesn\u2019t count all of the ERC20 (ICO) tokens that were vulnerable. The total amount is actually $150,000,000+ if you include all ERC20 tokens. As of the time of writing this (July 21st 4PM EST), the total value of the assets saved by the white-hats was $_179,704,659."
    }
}