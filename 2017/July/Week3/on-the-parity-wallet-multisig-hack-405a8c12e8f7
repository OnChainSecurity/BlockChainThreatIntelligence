{
    "threat_intelligence": {
        "url": "https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7",
        "timestamp": "2017-07-19 00:00:00",
        "original_content": "The Parity Wallet Hack ExplainedTL;DR\nA vulnerability was found on the Parity Multisig Wallet version 1.5+, that allowed an attacker to steal over 150,000 ETH (~30M USD).\nIf you are using the affected wallet contract, make sure to move all funds to a different wallet immediately.\nThe OpenZeppelin MultiSig wallet is unaffected by the vulnerability.\nToday, we witnessed the second largest hack, in terms of ETH stolen, in the history of the Ethereum network. As of 12:19 pm UTC, ([the attacker\u2019s account]https://etherscan.io/address/0xb3764761e297d6f121e79c32a65829cd1ddb4d32#internaltx) had drained 153,037 ETH from three high-profile multi-signature contracts used to store funds from past token sales. The problem was initially reported by the Parity team, since the affected MultiSig wallet contract was part of the Parity software suite.\n\nAs soon as we learned about the vulnerability, we rushed to analyze the cause of the issue, to check if OpenZeppelin\u2019s multisignature implementation was affected too.\n\nFirst and foremost, we want to assure our users that the OpenZeppelin MultiSig wallet is unaffected by the vulnerability, and is safe to use.\n\nThat being said, we proceed to share our findings, to raise awareness on the pitfalls that made the attack possible.\n\nThe attack explained\nThe attacker sent two transactions to each of the affected contracts: the first to obtain exclusive ownership of the MultiSig, and the second to move all of its funds.\n\nWe can see that the first transaction is a call to initWallet (line 216 of WalletLibrary):\n\n// constructor - just pass on the owner array to the multiowned and  // the limit to daylimit  \nfunction initWallet(address[] _owners, uint _required, uint _daylimit) {    \n  initDaylimit(_daylimit);    \n  initMultiowned(_owners, _required);  \n}\nThis function was probably created as a way to extract the wallet\u2019s constructor logic into a separate library. This uses a similar idea to the proxy libraries pattern we talked about in the past. The wallet contract forwards all unmatched function calls to the library using delegatecall, in line 424 of Wallet:\n\nfunction() payable {\n  // just being sent some cash?\n  if (msg.value > 0)\n    Deposit(msg.sender, msg.value);\n  else if (msg.data.length > 0)\n_walletLibrary.delegatecall(msg.data);\n}\nThis causes all public functions from the library to be callable by anyone, including initWallet, which can change the contract\u2019s owners. Unfortunately, initWallet has no checks to prevent an attacker from calling it after the contract was initialized. The attacker exploited this and simply changed the contract\u2019s m_owners state variable to a list containing only their address, and requiring just one confirmation to execute any transaction:\n\nFunction: initWallet(address[] _owners, uint256 _required, uint256 _daylimit) ***\nMethodID: 0xe46dcfeb\n[0]:0000000000000000000000000000000000000000000000000000000000000060\n[1]:0000000000000000000000000000000000000000000000000000000000000000\n[2]:00000000000000000000000000000000000000000000116779808c03e4140000\n[3]:0000000000000000000000000000000000000000000000000000000000000001\n[4]:000000000000000000000000b3764761e297d6f121e79c32a65829cd1ddb4d32\nAfter that, it was just a matter of invoking the execute function to send all funds to an account controlled by the attacker:\n\nFunction: execute(address _to, uint256 _value, bytes _data) ***\nMethodID: 0xb61d27f6\n[0]:000000000000000000000000b3764761e297d6f121e79c32a65829cd1ddb4d32\n[1]:00000000000000000000000000000000000000000000116779808c03e4140000\n[2]:0000000000000000000000000000000000000000000000000000000000000060\n[3]:0000000000000000000000000000000000000000000000000000000000000000\n[4]:0000000000000000000000000000000000000000000000000000000000000000\nThis execution was automatically authorized, since the attacker was then the only owner of the multisig, effectively draining the contract of all its funds.\n\nThe solution\nThe attack could have been prevented either by not extracting the constructor logic into the library contract altogether, or better by not using delegatecall as a catch-all forwarding mechanism. The recommended pattern is explicitly defining which library functions can be invoked externally on the wallet contract.\n\nIt is important to note that the technique of abstracting logic into a shared library can be quite useful, though. It helps improve code reusability and reduces gas deployment costs. This attack, however, makes clear that a set of best practices and standards is needed in the Ethereum ecosystem to ensure that these coding patterns are implemented effectively and securely. Otherwise, the most innocent-looking bug can have disastrous consequences.\n\nAt Zeppelin Solutions, we have been working on a solution to these problems, based on our experience building OpenZeppelin and on the many security audits we have performed. We will be sharing more details about this soon."
    }
}