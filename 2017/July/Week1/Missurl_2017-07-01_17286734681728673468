{
    "threat_intelligence": {
        "url": "https://dl.acm.org/doi/fullHtml/10.1145/3316481",
        "timestamp": "2017-07-01 00:00:00",
        "original_content": "\n\nBlockchain technology is a recent breakthrough of secure computing without centralized authority in an open networked system. From a data management perspective, a blockchain is a distributed database that logs an evolving list of transaction records by organizing them into a hierarchical chain of blocks. From a security perspective, the block chain is created and maintained using a peer to peer overlay network and secured through intelligent and decentralized utilization of cryptography with crowd computing.\n\n\nIt is predicted [\n30\n] that the annual revenue of blockchain-based enterprise applications worldwide will reach \n$\n19.9 billion by 2025, an annual growth rate of 26.2% from about \n$\n2.5 billion in 2016. Meanwhile, Goldman Sachs, Morgan Stanley, Citibank, HSBC, Accenture, Microsoft, IBM, Cisco, Tencent, Ali, and other world-renowned financial institutions, consulting firms, IT vendors, and Internet giants are accelerating laboratory research and capital layout on blockchain technology. Blockchain together with artificial intelligence and big data are considered as the three core computing technologies for the next generation financial industry. In addition to Bitcoin.com, several orthogonal efforts, such as the Hyperledger project sponsored by IBM and Apache foundation, Ethereum [\n2\n, \n23\n], and FileCoin [\n57\n] provide open source repositories and platforms for blockchain research and development.\n\n\nGovernments have released white papers and technical reports on blockchain to show their positive attitude toward the development of blockchain technology. In the UK, the government's chief scientific adviser released a new report that describes the future of distributed ledger technology [\n90\n]. European central bank released documents on distributes ledger technologies in securities post-trading [\n76\n]. Chinese government released white papers on blockchain technology and its development in China [\n85\n]. In the USA, the governor of Delaware launched \u201cDelaware Blockchain Initiative,\u201d which is a comprehensive program to build a legal and regulatory environment for the blockchain technology development. The governor for the state of Delaware officially signed a blockchain bill in July of 2017, which, if it becomes law, will formally legitimize and approve those companies registered in the state to manage their accounting and other business transactions using blockchain [\n24\n].\n\n\nIn academia, thousands of papers were published on blockchain in the past 5 years, including a dozen of study reports on security and privacy threats of blockchain. Joseph Bonneau et al. [\n20\n] provided the first systematic elaboration on Bitcoin and other cryptocurrencies, and analyzed anonymity problems and reviewed privacy enhancing methods. Ghassan Karame [\n54\n] overviewed and analyzed the security provisioning of blockchain in Bitcoin systematically, including risks and attacks in Bitcoin like digital currency systems. They also described and evaluated mitigation strategies to eliminate some of the risks. Mauro Conti et al. [\n32\n] reviewed security and privacy of Bitcoin, including existing loopholes, which lead to various security risks during the implementation of the Bitcoin system. Li et al. [\n61\n] surveyed the security risks of popular blockchain systems, reviewed the attack cases suffered by blockchain, and analyzed the vulnerabilities exploited in these cases.\n\n\nMost security and privacy research studies on blockchain have been focused along two threads: (1) uncovering some attacks suffered by blockchain based systems to date, and (2) putting forward specific proposals of employing some state-of-the-art countermeasures against a subset of such attacks. However, very few efforts have been made to provide an in-depth analysis of the security and privacy properties of blockchain and different blockchain implementation techniques. This survey presents a comprehensive review of the security and privacy of blockchains. We first describe the notion of blockchains for online transactions, and discuss the basic and additional security and privacy attributes of blockchains. Then we discuss a set of corresponding security techniques, especially cryptographic solutions, for realizing both basic and additional security goals. We argue that as blockchain technology continues to attract attentions and to be deployed in various applications, it is critical to gain an in-depth understanding of the security and privacy properties of blockchain and the degree of trust that blockchain may provide. Such understanding may shed light on the root causes of vulnerabilities in current blockchain deployment models and provide foresight and technological innovation on robust defense techniques and countermeasures.\n\n\nThis survey article is designed with dual goals. First, it will provide an entry point for non-security experts to gain better understanding of security and privacy properties of blockchain technology. Second, it will help specialists and researchers to explore the cutting edge security and privacy techniques of blockchain. In addition, we identify basic security attributes of blockchain and additional security and privacy properties, discuss some security solutions for achieving these security goals, and insinuate open challenges. We anticipate that this survey will also guide domain scientists and engineers to uncover suitable blockchain models and techniques for many domain-specific application scenarios.\n\n\nWe organize the rest of the article as follows. Section \n2\n describes basic blockchain concepts. Section \n3\n describes security attributes that are inherent or desired in blockchain systems. Section \n4\n introduces consensus algorithms that can be used in blockchain-based systems. Section \n5\n discusses the security and privacy techniques that can be employed on blockchain. Section \n6\n concludes the survey.\n\n\n\n\n\n\nThe first documented design of blockchain was in 2008, and the first open source implementation of blockchain was deployed in 2009 as an integral element of Bitcoin, the first decentralized digital currency system to distribute bitcoins through the open source release of the Bitcoin peer-to-peer software. Both were put forward by an anonymous entity, known as Satoshi Nakamoto [\n67\n].\n\n\nThe Bitcoin system uses the blockchain as its distributed public ledger, which records and verifies all bitcoin transactions on the open Bitcoin peer-to-peer networked system. A remarkable innovation of the Bitcoin blockchain is its capability to prevent double spending for bitcoin transactions traded in a fully decentralized peer-to-peer network, with no reliance to any trusted central authority.\n\n\n \nWhat is Blockchain?\n As a secure ledger, the blockchain organizes the growing list of transaction records into a hierarchically expanding chain of blocks [\n68\n] with each block guarded by cryptography techniques to enforce strong integrity of its transaction records. New blocks can only be committed into the global block chain upon their successful competition of the decentralized consensus procedure.\n\n\nConcretely, in addition to information about transaction records, a block also maintains the hash value of the entire block itself, which can be seen as its cryptographic image, plus the hash value of its preceding block, which serves as a cryptographic linkage to the previous block in the blockchain. A decentralized consensus procedure is enforced by the network, which controls (i) the admission of new blocks into the block chain, (ii) the read protocol for secure verification of the block chain, and (iii) the consistency of the data content of transaction records included in each copy of the blockchain maintained on each node. As a result, the blockchain ensures that once a transaction record is added into a block and the block has been successfully created and committed into the blockchain, the transaction record cannot be altered or compromised retrospectively, the integrity of the data content in each block of the chain is guaranteed, and the blocks, once committed into the blockchain, cannot be tampered with by any means. Thus, a blockchain serves as a secure and distributed ledger that archives all transactions between any two parties of an open networked system effectively, persistently, and in a verifiable manner.\n\n\nIn the context of Bitcoin systems, the blockchain is employed as its secure, private, and trusted public archive for all transactions that trade bitcoins on the Bitcoin network. This ensures that all bitcoin transactions are recorded, organized, and stored in cryptographically secured blocks, which are chained in a verifiable and persistent manner. Blockchain is the pivotal guard in securing bitcoin transactions from many known and hard security, privacy, and trust problems, such as double spending, unauthorized disclosure of private transactions, reliance of a trusted central authority, and the untrustworthiness of decentralized computing. The bitcoin way of deploying blockchain has been the inspiration for many other applications, such as healthcare, logistics, education certification, crowd sourcing, and secure storage. The blockchain ecosystem is growing rapidly with increasing investment and interests from industry, government, and academia.\n\n\n\n\nA blockchain functionally serves as a distributed and secure database of transaction logs. In a Bitcoin network, if client A wants to send some bitcoins to another client B, it will create a bitcoin transaction by client A. The transaction has to be approved by miners before it gets committed by the Bitcoin network. To initiate the mining process, the transaction is broadcasted to every node in the network. Those nodes that are miners will collect transactions into a block, verify transactions in the block, and broadcast the block and its verification using a consensus protocol (a.k.a., Proof of Work) to get approval from the network. When other nodes verify that all transactions contained in the block are valid, the block can be added to the blockchain. Figure \n1\n provides an illustration of this process. Only when the \u201cblock\u201d containing the transaction is approved by the other nodes and added to the blockchain, this bitcoin transfer from A to B will become finalized and legitimate.\n\n\n\n\n\n\n\n\nFig. 1.\n\n\nHow the Blockchain works.\n\n\n\n\n\n\nThree basic and important capabilities that are supported by the blockchain implementation in Bitcoin are: (1) the hash chained storage, (2) digital signature, and (3) the commitment consensus for adding a new block to the globally chained storage. By an elegant combination of a suite of popular security techniques, such as Hash chain, Merkle tree, digital signature, with consensus mechanisms, the Bitcoin blockchain can prevent both the double spending problem of bitcoins and stop the retrospective modification of any transaction data in a block after the block has been successfully committed into the blockchain.\n\n\n\n\n \n2.1.1\n \nHash Chained Storage.\n Hash pointer and Merkle tree are the two fundamental building blocks for implementing the blockchain in Bitcoin using the hash chained storage.\n\n\n \nHash Pointer\n. Hash pointer is a hash of the data by cryptography, pointing to the location in which the data is stored. Thus, a hash pointer can be used to check whether or not the data has been tampered with. A \nblock chain\n is organized using hash pointers to link data blocks together. With the hash pointer pointing to the predecessor block, each block indicates the address where the data of the predecessor block is stored. Moreover, the hash of the stored data can be publicly verified by users to prove that the stored data has not been tampered with.\n\n\nIf an adversary attempts to change data in any block in the entire chain, in order to disguise the tampering, the adversary has to change the hash pointers of all previous blocks. Ultimately, the adversary has to stop tampering because he will not be able to falsify the data on the head of the chain, which is initially generated once the system has been built. We call this initial opening block in the chain the \ngenesis\n block. Finally, the adversary's tampering will be uncovered because by recording this single root hash pointer of \ngenesis\n block, one can effectively make the entire chain have the property of tamper-resilience. Users are allowed to go back to some special block and verify it from the beginning of the chain.\n\n\n \nMerkle Tree\n. A Merkle tree is defined as a binary search tree with its tree nodes linked to one another using hash pointers. It is another useful data structure used for building a blockchain. In turn, grouping these nodes into disjoint groups, such that each time two nodes at the lower level are grouped into one at the parent level, and for each pair of lower level nodes, the Merkle tree construction algorithm is creating a new data node, which contains the hash value of each. This process is repeated until reaching the root of the tree.\n\n\nA Merkle tree has the ability of preventing data from tampering by traversing down through the hash pointers to any node in the tree. Specifically, when an adversary tries to tamper with data at a leaf node, it will cause a change in the hash value of its parent node; even if he continues to tamper with the upper node, he needs to change all nodes on the path of the bottom to the top. One can easily detect the data has been tampered with, since the hash pointer of root node does not match with the hash pointer that has been stored.\n\n\nAn advantage of Merkle tree is that it can prove effectively and concisely the membership of a data node by showing this data node and all of its ancestor nodes on its upward pathway to the root node. The membership of Merkle tree can be verified in a logarithmic time by computing hashes on the path and checking the hash value against the root.\n\n\n\n\n\n\n \n2.1.2\n \nDigital Signature.\n A digital signature establishes the validity of a piece of data by using a cryptographic algorithm. It is also a scheme for verifying that a piece of data has not been tampered with. There are three core components that formulate a digital signature scheme. The first component is the key generation algorithm, which creates two keys\u2014one is used to sign messages and be kept privately and called the private key; the other is made available to the public, thus called the public key, and used to validate whether the message has the signature signed with the corresponding private key. The second core component is the signing algorithm. It produces a signature on the input message endorsed by using the given private key. The third core component is the verification algorithm. It takes a signature, a message, and a public key as inputs, and validates the message's signature using the public key and returns a Boolean value.\n\n\nA well-defined and secure signature algorithm should have two properties. The first property is \nvalid signatures must be verifiable\n. The second property is \nsignatures are existentially unforgeable\n. It means that an adversary who has your public key cannot forge signatures on some messages with an overwhelming probability.\n\n\n \nElliptic Curve Digital Signature Algorithm (ECDSA)\n. The blockchain used in Bitcoin adopts ECDSA as its digital signature scheme for signing transactions. By employing ECDSA over the standard elliptic curve \u201csecp256k1,\u201d 128 bits of security is provided for Bitcoin blockchain [\n51\n]. ECDSA proves to be resilient to forgery in the presence of a chosen-message attack based on a generic group and the collision resistant hash function [\n22\n]. Thus, a digital signature scheme like ECDSA should be resistant to a chosen-message attack against a legitimate entity \nC\nC\n, aiming at fabricating a valid signature on an unseen message \nM\nM\n, after the adversary obtained the entity \nC\nC\n\u2019s signature by sending a set of chosen probing queries on a set of messages (not including \nM\nM\n).\n\n\n \nPublic Keys as Pseudonyms\n. The advantage of using a digital signature is to effectively validate the authenticity of a message by utilizing public key infrastructure (PKI) such that the writer of a message signs it with her private key before sending it out; the recipient of this signed message can use the sender's public key to prove the validity of the message. One can obtain the key pair from a trusted third party in most application scenarios. A PKI is used to manage the public keys via establishing a binding agreement between respective identities of entities (like name, email, and ID) and their public keys. Such binding is done by registering and issuing certificates with a certificate authority (CA). The process of signature verification is automatically translated into identity verification of the signer based on the assurance level of the binding. Thus, public key can be seen as an identity in these scenarios.\n\n\nWhile Bitcoin's blockchain adopts decentralizing identity management, without having a central authority to register a user in a system. Key pairs are generated by users themselves. Users can generate key pairs\u2014as many as they want. These identities (hashes of public keys) are called addresses in Bitcoin. Because there is no central management of public keys, these identities are actually pseudonyms made up by users.\n\n\n\n\n\n\n \n2.1.3\n \nConsensus.\n In the context of decentralized blockchain, when a new block is sent by broadcasting to the network, each node has the option to add that block to their copy of the global ledger or to ignore it. The consensus is employed to seek for the majority of the network to agree upon a single state update in order to secure the expansion of the global ledger (the blockchain) and prevent dishonest attempts or malicious attacks.\n\n\nConcretely, given that the blockchain is a huge, shared global ledger, anyone may update it. Adversarial offense could happen when a node decides to tamper with the state of his copy of the global ledger, or when several nodes collusively attempt on such tampering. For example, if Alice were sending 10 bitcoins to Bob from her wallet, she would like to be sure that no one in the network can tamper with the transaction content and change 10 bitcoins to 100 bitcoins. In order to enable the blockchain to function on a global scale with security and correctness guarantee, the shared public ledger needs an efficient and secure consensus algorithm, which must be fault tolerant, and ensure that (i) all nodes simultaneously maintain an identical chain of blocks and (ii) it does not rely on central authority to keep malicious adversaries from disrupting the coordination process of reaching consensus. In short, every message transmitted between the nodes has to be approved by a majority of participants of the network through a consensus-based agreement. Also, the network as a whole should be resilient to the partial failures and \u201cattacks,\u201d such as when a group of nodes are malicious or when a message in transit is corrupted.\n\n\nA good consensus mechanism used in the blockchain implementation also ensures a robust transaction ledger with two important properties: persistence and liveness. Persistence guarantees the consistent response from the system regarding the state of a transaction. For example, if one node on the network states that a transaction is in the \u201cstable\u201d state, then the other nodes on the network should also report it as stable, if queried and responded to honestly. Liveness states that all nodes or processes eventually agree on a decision or a value. By \u201ceventually,\u201d it indicates that it may take a sufficient amount of time for reaching the agreement. By combining persistence and liveness, it ensures that a transaction ledger is robust such that only authentic transactions are approved and become permanent.\n\n\nIn summary, the role of blockchain in the Bitcoin system is to replace the centralized database with authoritative access control. Once some data has been recorded into the global ledger block chain, it should be \u201cimpossible\u201d to change the blockchain, and by enforcing the majority agreement of update validity through consensus, it ensures the consistency state and prevents the double spending problem. We describe and compare the representative consensus algorithms in Section \n4\n.\n\n\n\n\n\n\n\n\nBlockchain is created and maintained as a distributed ledger for online transactions. There are two representative blockchain level transaction models: the unspent transaction outputs (UTXO) model, initially introduced by Bitcoin [\n1\n] and the account-based transaction model, introduced by Ethereums [\n2\n]. In this section, we describe the two transaction models and how their design difference may impact on the solution to the double spending problems.\n\n\n\n\n \n2.2.1\n \nThe UTXO Model.\n In Bitcoin and many of its derivatives, a user stores the total amount of her bitcoins as a list of \u201cunspent\u201d instances of bitcoins that she has received but has not spent yet. Using the UTXO model, the entire history of the Bitcoin transactions in the system is recorded in a time series of unspent outputs, such that each of them has an owner and a value. The sum of all unspent bitcoin instances that the user has the key to access as the owner in her bitcoin wallet is the total balance of this user. It is straightforward to trace the provenance of individual bitcoins (BTCs) as each of them is signed and sent from one participant to another. A transaction is legitimate if one can prove that the sender has the ownership of the actual bitcoins that are being spent. More specifically, each UTXO transaction can be endorsed if it meets three constraints: (1) Every referenced input in the transaction must be signed by its owner (sender) and not yet spent; (2) If the transaction has multiple inputs, then each input must have a signature matching the owner of the input; (3) A transaction is legal if the total value of its inputs equals or exceeds the total value of its outputs.\n\n\nConsider an example under the UTXO model: if Bob and Mary both send Alice 5 BTC, and Alice has not spent them, then there are 5 BTC from Bob signed to Alice and another 5 BTC from Mary signed to Alice. If Alice wants to combine her two single instances of 5 BTC into an instance of 10 BTC, Alice must perform another transaction, in a similar way as she would need to exchange her two 5 dollar bills into a 10 dollar bill.\n\n\nThere are a number of benefits for using the UTXO style of online transaction model:\n\n\n\n\n \nPotentially high degree of privacy:\n The UTXO model defines a data structure such that each user (the account holder) can hold multiple instances of BTCs without combining them into one total amount, unlike it is done in each of our accounts in a bank. By holding many such instances, the account holder need only disclose to her payee (such as Bob) the instances she used to pay the payee. This means that the payer can make multiple payments at the same time. For example, Alice could pay 1 BTC to Bob and 2 BTC to Carol from a 3 BTC instance that Alice holds, without revealing to Bob or Carol the total amount of the aggregate of BTC instances, which Alice has as the owner. Similarly, a user may use different addresses for different transactions that she receives. This will make it difficult to link her accounts to one another.\n \n\n\n \nPotentially high degree of scalability:\n The UTXO model does not have the concept of account for a user, which removes some constrains of the account-based transaction model. A user (payer) can easily send payment transactions in parallel to multiple payees as long as the payer has sufficient granular entries (BTC instances). Such parallel transactions can be executed independently without worrying about transaction ordering, simply because the blockchain relies on hash functions to identify previous states; thus, it is impossible for transactions to be mis-ordered. As a result, using the UTXO model, one no longer needs to worry about solving the hard problem of keeping track of transaction sequence numbers in a fully distributed system.\n \n\n\n \nPotentially high degree of security:\n The UTXO model maintains a Merkle proof of ownership for all BTC instances for each user. Conflict resolution is reduced to the double spending problem, namely, the digital currency-based transactions can easily be duplicated and spent twice. Bitcoin resolves the double spending problem by enforcing a consensus-based confirmation mechanism for committing new blocks into the blockchain and by maintaining the blockchain as a universal ledger.\n \n\n\n\n\nIn a Bitcoin network, the blockchain is created and maintained as a hierarchical and chronologically-ordered chain of blocks with timestamp since its inception in 2009. Each node keeps a copy of the blockchain. A newly created block consisting of several transactions is added to the blockchain. To be secure against double spending, a block should not be considered as confirmed until \n\u03c9\n\u03c9\n blocks are added after it (a.k.a. \n\u03c9\n\u03c9\n confirmations). The default setting of \n\u03c9\n\u03c9\n is six, which means that a transaction contained in the block considered as confirmed takes about 60 minutes, with the rate of generating a new block being roughly 10 minutes. In addition, transactions are embedded in blocks and every block is arithmetically linked to the previous block through cryptography. A combination of these techniques makes transactions and blocks immutable and hard to tamper with.\n\n\nNow we illustrate how the double spending problem is resolved using the Bitcoin blockchain. Assume that Bob sent 1 BTC to Andrew, then signs and sends the same 1 BTC to Alice. Both transactions enter the unconfirmed pool of transactions on the network. If the block containing Bob's first transaction was mined by some miner, and the block containing Bob's second transaction was mined by some other miners. The block containing Bob's first transaction was broadcasted to the entire network and verified by miners first. Then, most miners will continue to mine on the top of the block that contains Bob's first transaction. Thus, Bob's second transaction was judged by the miners as invalid and pulled from the network. If both transactions are received by the miners simultaneously, then whichever transaction gets the maximum number of confirmations (blocks deep) first from the network will be included in the blockchain eventually, and the other one will be rejected.\n\n\nThe UTXO model also has some weaknesses, some of which stem from its strengths. For example, if Alice receives 100 BTC and wishes to send Carlo 10 BTC, Alice has to consume the 100 BTC output by creating two outputs: a 10 BTC for the payee Carlo and 90 BTC back to herself as the change. But, the occurence of this kind situation may leak private information to an observer. Also, this makes the balance calculation, which is a core feature of the UTXO model and a significant contributor to wallet's complexity. Although a payer can apply transactions in parallel, it is difficult to achieve them in real parallel due to the need to strictly enforce a total ordering constraint such that the total of the inputs should equal or exceed the total of the outputs.\n\n\n\n\n\n\n \n2.2.2\n \nAccount-based Online Transaction Model.\n In contrast to the UTXO model, the account-based online transaction model is by design a simpler model, which explicitly operates all transactions based on the account of senders, instead of unspent transaction outputs, with the objective of improving consensus efficiency and faster block times at the cost of higher degree of risk. It is adopted and extended in Ethereum. Concretely, by the account balance-based transaction model, which operates in a similar way as the bank account in a brick and mortar banking today, a user's entire balance information is stored in Ethereum. A transaction with a token value (ETH) is valid if the following three validity constraints are met: (i) the token is signed by the message writer (sender); (ii) the writer's ownership of token value can be attested, and (iii) the writer's spending account has a sufficient balance for the transaction. Upon validation of a transaction, the sending account is debited by the token value and the receiving account is credited with the value. Thus, a user's account \u201cbalance\u201d in the Ethereum system refers to the sum of the ETH coins for which the user has a private key capable of producing a valid signature. In this model, if Bob has 1 ETH, then upon receiving 1 ETH from Alice, Bob's account balance will be 2 ETH without the need of another exchange transaction to combine the two instances of 1 ETH. In Ethereum, a global state stores a list of accounts with balances, code, and internal storage. It is possible but more difficult to track individual transactions as they are added to the receiver's balance and subtracted from the sender's balance.\n\n\nThere are a number of obvious benefits for the account-based transaction model. First, in contrast to the UTXO model, it has larger space savings because every transaction in this account balance-based model needs only one reference and one signature to produce an output. Second, it has greater simplicity. Unlike the UTXO model, it does not maintain the source information of coins from transactions in blockchain. Thus, coins are not distinguished based on the sources from which they were received. Third, it does not allow changing reference with each transaction, but it offers easy accessibility to account related data. This is because the Merkle Patricia Tree (MPT) is used to store all account states, transactions, and receipts in each block, and a user can scan down the state tree maintained in the MPT along a specific direction to access all data related to an account. In the MPT, SHA3(\nT\nT\n) is used to obtain the hash key of item \nT\nT\n in the secure tree (value \nT\nT\n being account state, transaction, or receipt). As a result, every distinct key/value pair maps uniquely to a root hash, making it very hard to deceive membership of a key/value pair in an MPT.\n\n\n \nAccount nonce.\n In the account balance-based model, one way to prevent double spends is to have each account associated with a globally accessible nonce, which is simply the count of transactions sending from the account (i.e., the sequence number). Given that this nonce is associated to an account, two accounts may have the same nonce at the same time. Each transaction must assign a \u2018nonce to the sending account, which miners check and will process transactions from a specific account in a strict order according to the value of its nonce. If a block has a transaction with an incorrect nonce, it is considered an invalid block, and other miners will not build on top of it. Hence, if Alice first signs a message sending 100 ETH to Bob, and then signs another message to send 100 ETH to herself from the same account, then, using nonce associated to the same sending account of Alice, the second message with higher nonce should not be confirmed before the first. Note that the double spending here is orthogonal to the case in which Alice has two independent accounts, one in Japan and the other in France. Similarly, by associating the transaction counter to a sending account as nonce, the replay attacks can be prevented: namely, a transaction sending 100 ETH from Alice to Bob can be repeated over and over by Bob to continually drain Alice's balance. Thus, maintaining the correct transaction count is very important and failing to increment this value correctly can result in different kinds of errors. For example, reusing nonce or creating incorrect nonce will be detected and rejected: if Alice sends a new transaction for the same account by reusing a past nonce, the mining node will reject the transaction. If Alice sends a new transaction with a nonce that is higher than the correct increment count, the transaction will not be processed until this gap is closed, i.e., until a transaction with each of the missing nonce values has been processed.\n\n\n \nProof of Work nonce.\n In addition to the account nonce that records the transaction count of an account, Ethereum also uses the proof of work nonce as the second type of nonce, which is the random value in a block that was used to get the proof of work satisfied through mining, an enabling mechanism for decentralized record-keeping.\n\n\nEthereum proof of work blockchain is designed in a similar way as that of Bitcoin. A new block can be accepted by the network after being validated through mining. Miners can choose to mine any unverified blocks on the network by solving a puzzle, and compete with one another until a winner emerges. If a miner is the first to find a hash that matches the current target, it broadcasts the block across the network to each node. Once the block passes the verification, each node adds this block to their own copy of the ledger. If another miner finds the hash faster, then the rest of the miners will stop working on the current block and start the mining process for the next block. This mining process is simultaneously repeated by multiple miners. The consistency is maintained in a decentralized manner by the peer-to-peer network. The winning miner will be awarded ETH. Similar to Bitcoin, when two miners mine the next block at the same time, the network will decide which one will be the main chain. When two blocks X and Y are mined at the same time. Miners would accept the first block that was broadcast to them. Thus, some miners accept X and others accept Y. The block that is accepted by the majority of the network (51% or more) will be the winner. Also, miners who accepted block X will continue to mine the next block on top of block X, and similarly, miners who accepted block Y will continue to mine the next block on top of Y. If the next block is found and added on the top of block X faster, then the miners working on top of block Y will turn to the X chain, which is the main chain. The block X will be the winner and the block Y will become an orphaned block. This decentralized consensus process ensures that any attempt to tamper with the transactions and the blockchain is very hard to fool the majority of the network.\n\n\nSimilar to the PoW in Bitcoin, to counter the domination of the network majority for mining, a system-defined timer is enforced, which controls the hardness of the hash puzzle to ensure that a block can be validated in approximately every 12\u201315 seconds. If the puzzles are solved faster or slower than this system-default rate, the complexity of the problem is adjusted routinely by the mining algorithm to maintain the roughly 12-second default validation time. This puzzle-solving method prevents cheating at this game from multiple perspectives, such as leveraging powerful computing resources, forming colluding partners, and faking the proof of the correct puzzle answer. Another innovative feature of this mining algorithm is that miners have to find the correct hash value to show the \u201cproof-of-work,\u201d but each node on the network can easily confirm that the hash value is correct. By combining the account nonce with the proof of work nonce, Ethereum can speed up the time required to mine a block significantly compared to Bitcoin, without substantially weakening the resilience of blockchain against malicious manipulation.\n\n\n\n\n\n\n\n\n\n\n \n2.3.1\n \nCAP Theorem.\n CAP refers to Consistency, Availability, and Partition tolerance. CAP theorem is a fundamental theorem for defining transactional properties in distributed systems. A distributed system involves a set of computing nodes that are connected over an overlay network and communicate with one another to accomplish some tasks. CAP theorem states that any distributed systems can have only two of the following properties [\n43\n]:\n\n\n\n\n \nConsistency:\n where each computing node receives the most recent write.\n \n\n\n \nAvailability:\n where any requests for some data is always available.\n \n\n\n \nPartition tolerance:\n where the distributed systems is always operational, even when some subset of nodes fail to operate.\n \n\n\n\n\n\n\n\n\n \n2.3.2\n \nCAP Properties in Distributed Ledger\u2014The Problems.\n In the context of a distributed ledger, CAP properties mean\u2014(1) Consistency: all nodes keep an identical ledger with most recent updates. (2) Availability: any transactions generated at any time in the network will be accepted in the ledger. (3) Partition tolerance: even if part of the nodes fail, the network can still operate normally. The main issue is that it is hard for any widely acceptable currency to exist without all three conditions being met. No one will use a currency if the system is not available when the transaction is initiated or some transactions are not recognized by the system (CP system). No one will use a currency if any one node fails; the system will not operate normally (CA system). No one will use a currency if the ledger saved by different nodes in a distributed ledger system are inconsistent (PA system).\n\n\n\n\n\n\n \n2.3.3\n \nThe Blockchain Solution.\n It seems that the CAP theorem has been violated in the blockchain of the Bitcoin system, one of the most successful blockchain implementations, because it achieves consistency, availability, and partition tolerance. However, this is not the case. In reality, the blockchain consistency is not achieved simultaneously as availability and partition tolerance, but it is after a period of time. The concept of mining is used in Bitcoin, in conjunction with a consensus protocol and a minimum of six confirmations, to ensure eventual consistency through reaching consensus.\n\n\n\n\n\n\n\n\nAs the blockchain technology continues to evolve with respect to the ways of how blockchains are constructed, accessed, and verified, they are being classified into three broad categories: (1) \nPublic blockchain\n, which is open for anyone to read, send, or receive transactions, and allows any participant to join the consensus procedure of making the decision on which blocks contain correct transactions and get added to the blockchain. (2) \nConsortium blockchain\n, which has placed certain constraints on write permissions such that only a pre-selected set of participants in the network can influence and control the consensus process, even though read is open to any participant in the network, and (3) \nPrivate blockchain\n, whose write permissions are restricted strictly to a single participant (or organization), even though its read permissions are open to the public or constrained to a subset of participants in the network. Although from a security and performance perspective, they differ in the speed of consensus (SoC) and whether any trust authority (TA) is used, and how many TAs are required. As summarized in Table \n1\n, these three categories of blockchain share some common properties: (1) they all use decentralized peer to peer networks for transactions; (2) they all require that each transaction is digitally signed and append only to the blockchain, and each peer node maintains a replica of a distributed global ledger of transactions; and (iii) they all rely on consensus to synchronize the replicas across the network.\n\n\n\n\n\n\nTable 1.\n\n\nClassification of Blockchains\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\nDescribe\n\n\n#TA\n\n\nSoC\n\n\nScenarios\n\n\n\n\n\n\n\n\n\n\nPublic Blockchain\n\n\nAnyone can participate and is accessible worldwide\n\n\n0\n\n\nSlow\n\n\nGlobal decentralized scenarios\n\n\n\n\n\n\nConsortium Blockchain\n\n\nControlled by pre-selected nodes within the consortium\n\n\n \n\u2265\n1\n\u2265\n1\n \n\n\nSlightly Fast\n\n\nBusinesses among selected organizations\n\n\n\n\n\n\nPrivate Blockchain\n\n\nWrite rights are controlled by an organization\n\n\n1\n\n\nFast\n\n\nInformation sharing and management in an organization\n\n\n\n\n\n\n\n\n\n\nAlthough Bitcoin [\n67\n] was publicly released in 2009 as the first peer-to-peer digital currency system, which implements the blockchain as its public ledger for all transactions, the concept of a secure chain of blocks by cryptography was first proposed in 1991 [\n49\n], and the use of Merkle trees as an efficiency optimization of the hash chain was first described by Bayer, Haber, and Stornetta [\n14\n] in 1993. Over the past 10 years, blockchain has evolved beyond digital currency (Blockchain 1.0), to smart contracts (Blockchain 2.0), and to many other forms of decentralized collaborations with high accountability and a high level of security and trust (Blockchain 3.0). Figure \n2\n shows the architecture of Blockchain, where the contents of the red dotted were developed by Blockchain 2.0.\n\n\n\n\n\n\n\n\nFig. 2.\n\n\nThe architecture of Blockchain.\n\n\n\n\n\n\nAs the application utility of blockchain continues to grow from Blockchain 1.0 to Blockchain 3.0, it becomes even more critical for blockchain users and developers to gain a better understanding of the security and privacy properties of blockchains. We have given an overview of the first implementation of the blockchain in Bitcoin. We have also touched on some frequently asked questions such as how the blockchain ensures security through its hash chained storage with hash pointer and Merkle tree and its consensus mechanism, as well as what the impact of different online transaction models may have on the security of blockchain, especially against the double spending problem. In the subsequent sections, we focus on discussing the security properties that a blockchain system provides, whether a Bitcoin system can really guarantee anonymity, and what security and privacy techniques can benefit the current and the future generation of blockchain development.\n\n\n\n\n\n\n\n\nConsensus is a group-based protocol for reaching agreement dynamically in a group. Compared to the majority voting, a consensus emphasizes that the entire group as a whole could benefit by reaching a consensus. The problem of dynamically getting a consensus in a group relies on group-based coordination. Such coordinated consensus may be tampered in the presence of malicious actors and faulty processes. For example, a bad actor may secretly create conflicting messages to make group members fail to act in unison, which breaks down the effectiveness of the group to coordinate its actions. This problem is so called the \u201cByzantine Generals Problem\u201d (BGP) [\n75\n]. The failure of reaching consensus due to faulty actors is referred to as Byzantine fault. Leslie Lamport, Marshall Pease, and Robert Shostak showed in 1982 [\n59\n] that Byzantine fault tolerance can be achieved only if a majority agreement can be reached by the honest generals on their strategy.\n\n\nThe consensus algorithms popularly used in current blockchain systems provide a probabilistic solution to BGP. In the subsequent sections, we will review these consensus protocols with the focus on their security and privacy properties.\n\n\n\n\nThe consensus protocol designed by Satoshi Nakamoto [\n67\n] for the Bitcoin is aimed at reaching a coordinated consensus from the network on the validity of each bitcoin transaction. It bypasses the BGP by using the PoW protocol.\n\n\nWe characterize the PoW with dual properties: (1) it should be difficult and time-consuming for any prover to produce a proof that meets certain requirements, and (2) it should be easy and fast for others to verify the proof in terms of its correctness. For the first property, one must design a proof of work challenge such that computing a valid proof of work is difficult with low and somewhat random probability, thus a lot of trial and error is needed.\n\n\nWe illustrate how the PoW works in terms of BGP. When the troops on the east of the city want to send a message to the west side troops, it follows the steps of the PoW protocol:\n\n\n\n\n Append a \u201cnonce\u201d (usually start with zero) to the original message, which is a random hexadecimal value;\n \n\n\n Apply hash to the nonce augmented message and check if the hashing result is less than or equal to a preset value (say starts with five zeros);\n \n\n\n If the hash condition is satisfied, the troops on one side of the city will send the messenger to the troops on the other side of the city with the hash of the message and the nonce. If not, then increase the nonce by one and this process iterates until the desired result is obtained. Finding the right nonce can be time consuming and computationally expensive;\n \n\n\n Due to the collision-resistant property of the hash function, it is hard to tamper the hash of the message even if the messenger got caught, because the hash of the tampered message will be drastically different from the hash of the original message, and the generals on the west of the city can verify whether the message starts with five zeros and disregard the message if not.\n \n\n\n Repeat the above process for multiple iterations such that multiple messengers are sent from the east-side troops to the west-side troops through the city.\n \n\n\n\n\nThis last step is to address a possible loophole with sending only one messenger: If the city captured the messenger, got the message, and tampered with it, then, accordingly, the nonce is changed until the right nonce value is found such that the desired hash result with required number of zeros is obtained. Even though this process is computationally costly and time consuming, it is still possible. The PoW protocol counters this loophole by increasing strengths in numbers. First, by adding more messengers, the probability of all of them to get caught is reduced significantly. Second, even if some of them got caught, the amount of time required to tamper the cumulative message and find the corresponding nonce for the hash will be increased substantially. For a block to be valid in the blockchain, a miner has to be able to hash it to a value less than or equal to the current target and then present its solution to the network for verification by other nodes. The dual properties of PoW ensures that it is extremely difficult and time consuming to find the right nonce for the appropriate hash target; yet, it is super easy and simple to validate the hash result so that no tampering has been made.\n\n\nThe PoW protocol in Bitcoin extends the Hashcash [\n13\n] system with some minor improvements. First, Bitcoin limits the rate of creating and adding new blocks to the blockchain by the network to roughly one at every 10 minutes. It implements such rate control by automatically monitoring the time spent to solve each proof of work challenge, and adjusting the difficulty of the challenge accordingly. Second, Bitcoin increases the difficulty of predicting which miner in the network will be able to generate the next block by making successful generation of the proof of work at a high cost.\n\n\nFor the formal analysis of PoW, Garay and Kiayias [\n39\n] first formally extracted and analyzed the two fundamental attributes of the Bitcoin protocol: \ncommon prefix\n and \nchain quality\n. However, their analysis is based on several simplifying assumptions, such as a fixed setting with a given number of players, the fully synchronous network channels in which messages are delivered with no delays. Pass et al. [\n72\n] proved that the Nakamoto consensus protocol ensures the blockchain maintaining strong \nconsistency\n and \nliveness\n, assuming that an asynchronous network has \na priori\n bounded adversarial delays and the computational challenge is casted as a random oracle. Recently, Pass and Shi proposed FruitChain [\n73\n], a protocol that extends the Bitcoin PoW protocol with a reward mechanism, while providing the same consistency and liveness properties with an approximate Nash equilibrium proof.\n\n\nAlthough the PoW protocol is effective in solving the Byzantine Generals problem, it suffers three limitations. \nFirst\n, the protocol is an extremely inefficient process due to high computation complexity and low probability of successful generation of the proof of work. It is argued that for different applications with different levels of consistency requirements and different risk tolerance levels, it may be attractive to look into more efficient protocols by tradeoff between efficiency and strong consistency. \nSecond\n, the proof of work security primarily comes from block creation (mining) rewards, which are strong incentives to attract a large number of miners to participate the proof of work, which is necessary for ensuring the robustness of the PoW blockchain protocol with rigorous security guarantees, defined by \npersistence\n and \nliveness\n. Persistence warrants that as soon as a transaction is appended to a block deep into the blockchain of an honest node such that there are additional \n\u03c9\n\u03c9\n or more blocks being placed on top of this block, this transaction will ultimately be contained in every authentic node's blockchain in the network with high probability. Liveness ensures that every transaction originated from an authentic node will be finally stored in a block more than \n\u03c9\n\u03c9\n deep of the blockchain of an honest node and become immutable. An honest majority is mandatory for both properties to hold. Although economic consensus has a very important role in protecting liveness and persistence properties in the short term, as shown in the Bitcoin system, seeking moderation by combining with social consensus may hold potential for healthy growth and wide deployment of blockchain in many other applications. The \nthird\n concern is due to the fact that participants may have varying computational capacities and thus different probabilities of successful rates in generating proof of work. It is reported at https://blockchain.info/pools that over 70% of the hash rate is divided among the top five independent mining farms (e.g., BTC.com 24.4%, AntPool 14.4%, ViaBTC 11.1%, SlusuPool 11.1%, accessed on March 20, 2018). If these big mining farms were to team up with each other, they could acquire more than 51% of Bitcoin hash power. However, even if an adversary can get unlimited hashing ability, with a 51% attack of any major blockchain, convincing all nodes of the entire network that this chain is legitimate is much harder than just obtaining the 50% hash power. Thus, such social layer of consensus may hold some potential toward ultimately protecting any blockchain in the long term.\n\n\nIn summary, the proof of work consensus algorithms tend to rely on anti-centralization incentives and economic incentives for security. By providing block creation rewards to promote more miners, and by requiring to solve computationally expensive challenges to acquire rewards, the former discourages centralized cartels and colluding parties from forming and the latter discourages centralized cartels from acting anti-socially.\n\n\n\n\n\n\nThe proof of state (PoS) represents an alternative type of distributed consensus protocols for ensuring the CAP properties of public blockchains. It breaks the dependency on rewards for security by promoting penalties-based solutions. Comparing to PoW-based public blockchains, such as those used in Bitcoin and the baseline Ethereum, in which any participant on the network can be a miner who validates transactions and creates new blocks to add to the blockchain by solving cryptographical puzzles, PoS-based public blockchains, such as the one implemented in Ethereum's Casper, set the constraint on who can be chosen as miners, and by PoS, only those participants who have locked up their capital as deposits (stake) are qualified to be chosen as miners or so-called validators in PoS. The blockchain keeps track of a set of validators that have put aside deposit. Anyone can become a validator by sending a special type of transaction to lock up a certain amount of their coins into a validator deposit. All validators have known identities, which are stable addresses in Ethereum, and the network keeps track of all legitimate validators (those who have reserved coins for participating in validation. Every validator can participate in proposing to create and validate new blocks through a consensus algorithm, which requires the set of validators to put the bet on the next block and take turns to vote. The decision on who will be the validator for the next block is made based on the weight of voting computed by the size of each validator's stake. The probability of being selected is proportional to their bet.\n\n\n \nRewards vs. Penalties.\n In a PoW-based blockchain network, miners race to be the first to solve the proof of work because a reward is given to the first miner who is the winner of adding the next block to the blockchain. This reward includes both the block creation reward and the transaction fees. In contrast, for PoS, to add the next block into the blockchain, each of the qualified validators has to place a bet on the block in order to qualify as a validator for the block. If the block gets appended, then all the validators will get a reward proportional to their bets. There is no block creation award, so validators (miners) are only rewarded by sharing the transaction fees of the block, in addition to the proportion of the bets they put on the block. Although validators received small rewards in order to compensate them for locking up their state and maintaining nodes and taking additional precaution to secure their private key, most of the cost of reverting transactions comes from penalties that may be thousands of times larger than the rewards that they got in the meantime. Thus, unlike PoW with \u201csecurity from rewards of burning computational energy,\u201d the proof of stake ensures \u201csecurity from penalties of putting up economic value-at-loss.\u201d\n\n\nThere are many versions of PoS-based consensus algorithms. From an algorithmic perspective, chain-based proof of stake and Byzantine Fault Tolerance (BFT) style proof of stake (see Section \n4.3\n) are the two major types from an algorithmic perspective.\n\n\nIn \nchain-based PoS\n, the algorithm pseudo-randomly selects a validator during each time slot (e.g., every 10 seconds) and assigns that validator the privilege to create a block, and links this block to some previous block (normally the block at the end of the previously longest chain). Thus, over time, most blocks converge into a single constantly growing chain.\n\n\nEarly versions of chain-based PoS algorithms are naive because rewards are used for producing blocks with no penalties, and thus suffer from the \u201cnothing at stake\u201d problem. Concretely, a validator can vote and make blocks on top of multiple competing chains at once and can do so without incurring additional cost. The economically optimal strategy is to vote on as many forks as the validator can find in order to reap more block rewards because the expected value for voting on multiple competing chains is greater than the expected value for voting on a single chain in such naive PoS design. Even with no attackers, a blockchain may never reach consensus.\n\n\nIn contrast, chain splits are avoided in a PoW system because it is more preferred to add the new block to a longer chain and no miners want to waste resources on a block that will be rejected by the network. Thus, there is an implicit penalty for creating a block on the wrong chain. Also, the \u201cpenalty\u201d for mining on multiple chains is that miners must split up their physical hashing power to do so, or miners have to spend extra electricity and obtain or rent extra hardware. In more recent algorithm proposals for PoS, the strategies for explicit penalties are introduced. For example, one strategy is to penalize those dishonest validators, which create blocks on multiple chains concurrently. If the validators are known and are selected at a time before the fork takes place, then those who place two conflicting signed block headers into the blockchain will be detected as misbehavior. Another strategy is to penalize the validators who create blocks on the wrong chain, and it does not require validators to be known ahead of time.\n\n\nThe Casper PoS protocol in Ethereum is a representative penalty-based PoS protocol. Concretely, the validators put on a portion of their digital currencies (ETHs) as stake for participating in validation of the next blocks. For a new block, only those nodes that want to add it to their local blockchain will place a bet (a portion of their stake) on it and become a validator. The validators can get a reward proportionately to their bets on the block in addition to the transaction fees, only when the block gets verified and appended into the blockchain. If a validator acts maliciously, they will be reprimanded and all of their stakes get slashed off. The Casper protocol makes malicious players have something to lose and thus the \u201cnothing at stake\u201d problem is not possible with the Casper consensus protocol.\n\n\n \nSelection of validator for signing the next block.\n Although each PoS algorithm defines a way of selecting validators for the next block and signing it to the blockchain, all make efforts to avoid undesirable centralization, such as selection by account balance. This is because the single richest member has a permanent advantage of putting the largest deposit at stake. We describe several different methods for validator selection below.\n\n\nNxt [\n31\n] and BlackCoin [\n88\n] select the validator as the generator for the next block randomly from those nodes who have put a stake on the block. Randomization-based selection adds uncertainty to the decision process that is solely based on the proportion of the stakes. This is because the stakes are public; it is easy to predict which account will likely win the right to generate the next block with reasonable accuracy.\n\n\nPeercoin [\n56\n] implements its PoS system by combining randomization with the constraint of \u201ccoin age\u201d to limit the amount of stakes that are used for validation competition. The coin age is defined for each coin by the number of days in which the coin has not been spent. If the constraint of \u201ccoin age\u201d is defined by at least 30 days, then only coins with the coin age of at least 30 days may compete for signing the next block. Those coins that have been used to sign a block must start over with zero \u201ccoin age.\u201d One can also set an upper limit of 90 days for the \u201ccoin age.\u201d The concept of \u201ccoin age\u201d and the set of constraints make it more difficult to use large stakes to dominate the blockchain. When the size of the network is large, this approach likely makes purchasing more than half of the total stakes in PoS costlier than acquiring 51% of hashing power in PoW.\n\n\nSnow White [\n34\n] is the first provably secure, robustly reconfigurable consensus protocol for PoS with a growing stakeholder distribution. This protocol proposed a corruption delay mechanism for ensuring security, i.e., robustness under sporadic participation and security in the presence of posterior corruption of past committee members. As long as money does not switch hands too fast (which is enforceable by the cryptocurrency layer), Snow White can attain security when a minority of the stake in the system is controlled by an adversary.\n\n\nOuroboros [\n55\n] is another PoS blockchain protocol with rigorous security guarantees defined by \npersistence\n and \nliveness\n. By incorporating a reward mechanism into its PoS protocol, Ouroboros proves that honest behavior approximates Nash equilibrium and thus adversarial behavior such as selfish mining can be neutralized and authentic transactions will be approved and become permanent.\n\n\n\n\n\n\nBFT is defined as the failure tolerance capability of a system against the BGP [\n75\n]. Consider an agreement scenario among a set of players: each player holds a possibly different initial value, and all players need to agree on a single value by obeying a consensus protocol. In a system where such agreement is reached if a majority of the players are honest players who rigorously follow the protocol, even when a minority of the players are malicious and may diverge from the protocol arbitrarily, we consider this system Byzantine fault tolerant.\n\n\nMost traditional distributed computing systems have central authorities that coordinate and determine what to do next when Byzantine failures occur. However, in a decentralized blockchain system, there is no central authority. The blockchain is maintained as a distributed global ledger by the network such that each node has a replica of the chain. The initial values are the candidate blocks to be validated and then inserted into the blockchain. For each candidate block, the verification is done by having the network reaching an agreement through the digital signatures of a sufficient number of nodes. Only those candidate blocks that are verified by the network can be added to the blockchain. In order to prevent the occurrence of the Byzantine faults, the blockchain systems rely on the consensus algorithms, such as PoW and PoS, to endorse transactions, which is what makes the blockchain so powerful and so attractive to many applications.\n\n\nHowever, neither the PoW nor the PoS algorithm is a perfect solution to address the BFT problem in decentralized peer-to-peer systems. Understanding BFT is important for applying blockchains solutions to the application areas beyond digital currency. Also, existing consensus algorithms and protocols proposed for the Byzantine fault problem may not be feasible when applied to other blockchain applications. Take healthcare blockchain as an example. Asking healthcare providers to spend a lot of computing resources to hashing data is not only very inefficient, but also completely unrealistic. Also, participants in a healthcare blockchain prefer to operate under users with real identities, rather than giving users high anonymity. Thus, relying on node voting and avoiding PoW may be a practical solution to the Byzantine faults.\n\n\nSince the first solutions to BFT were introduced by Lamport, Shostak, and Pease in 1982 [\n59\n], many Byzantine fault tolerant algorithms and protocols have been put forward that can help resolve many of the misconceptions associated with Byzantine faults and the difficulties in preventing the propagation of related faults. The PBFT algorithm for practical BFT was proposed by Miguel Castro and Barbara Liskov [\n25\n] in 1999 for high-performance replication of Byzantine state machine. PBFT achieves sub-millisecond increases in latency by processing thousands of requests per second.\n\n\nAlgoRAND [\n42\n] is a new Byzantine agreement protocol that is much more efficient than all previous ones, and has a novel property, called \nplayer replaceability\n, which guarantees the security in an adversarial environment. Instead of being played by all users in the system, which makes the protocol unwieldy, AlgoRAND chooses its players to be a much smaller subset of users by an algorithm called \ncryptographic sortition\n, which is a random process of choosing officials from a large set of eligible users. Provided that honest users retain a fraction greater than 2/3 of the money, the main advantages of AlgoRAND are: (1) No forks arise with an overwhelming probability; (2) Only require the minimal amount of computation; and (3) Reach a consensus quickly. Consensus latency is close to the block propagation latency.\n\n\nHoneyBadgerBFT [\n65\n] is the first practical asynchronous BFT protocol. It is based on a new broadcast protocol that achieves activity and optimal asymptotic efficiency without the need to make any timing assumptions. The main advantage is that HoneyBadgerBFT does not depend on careful tuning of parameters. No matter how unstable the network conditions are, the throughput of HoneyBadgerBFT is always close to the available bandwidth of the network. HoneyBadgerBFT will eventually continue execution once messages are delivered. The authors not only provided the formal proof of the security and liveness of HoneyBadgerBFT protocol, but also showed experimental results that even under optimistic conditions, HoneyBadgerBFT has better throughput than the traditional PBFT protocol [\n25\n].\n\n\n\n\n\n\n\n\n \n4.4.1\n \nSleepy Consensus.\n Sleepy consensus [\n74\n] considers a \u201csleepy model,\u201d in which participants are in one of the two modes: \u201cawake/active\u201d (online) or \u201casleep\u201d (offline). Also, participants can change their awake or active status freely during the protocol execution. Sleepy consensus is proved to be resilient when the honest participants are the majority.\n\n\nSleepy consensus is established using a PKI. It proves to be safe and consistent in the context of the Dwork-Naor-Sahai timing model [\n36\n], in which the network is assumed to be weakly-synchronous, and there are very small errors between all clocks and the \u201creal time.\u201d Constructed on the collision-resistant hash function, the first protocol of sleepy consensus is easy to implement. But it only supports static corruptions and \u201cstatic online schedule.\u201d The second protocol of sleepy consensus enhances security in two aspects: (1) it supports adaptive corruptions; (2) it is resilience even under the condition that an adversary arbitrarily chooses which and when the nodes are online. The main idea of Sleepy consensus is established on the Bitcoin PoW blockchain protocol while avoiding using PoW, rather than the standard approaches of distributed consensus. However, Sleepy consensus cannot work in the case when dishonest online players are the majority.\n\n\n\n\n\n\n \n4.4.2\n \nProof of Elapsed Time (PoET).\n Proof of elapsed time (PoET), proposed by Intel [\n50\n], is a blockchain network consensus algorithm that achieves fairness and low computing consumption by leveraging SGX, the Intel trusted computing platform.\n\n\nIn the PoET consensus, each participating node is required to wait for a randomly chosen time period, and the first one to complete the designated waiting time is permitted to generate a new block. Upon broadcasting a new block to the network, SGX facilitates the node to generate an easily verifiable proof of the waiting time. The PoET consensus needs to ensure two important factors. First, the participating nodes genuinely select a time that is indeed random and not a shorter duration chosen purposely by the participants in order to win. Second, the winner has indeed completed the waiting time.\n\n\nHowever, like most trusted computing technologies, SGX is not entirely reliable. For example, it may not be able to prevent attacks against strategic adversaries equipped with necessary resources. A recent study shows the security vulnerabilities of the blockchain protocol implemented on Intel's SGX platform [\n28\n]. Two countermeasures are proposed to mitigate these vulnerabilities: (1) Altering the probability distribution and (2) Performing statistical tests to reject some blocks that are generated by a given fraction of nodes [\n28\n].\n\n\n\n\n\n\n \n4.4.3\n \nProof of Authority (PoA).\n Proof of Authority (PoA) is a consensus algorithm that supports comparatively fast transactions [\n92\n]. The basic idea of PoA is that only validators have the right to approve transactions and new blocks. A participating node earns a reputation to his identity and only when the reputation is accumulated to a high score, the node can become a validator. PoA is considered more robust than PoS for two reasons. On one hand, validators are incentivized to honestly verify transactions and blocks; otherwise, their identities will be attached to a negative reputation. On the other hand, a validator cannot approve any two consecutive blocks. This prevents trust from being centralized.\n\n\n\n\n\n\n \n4.4.4\n \nProof of Reputation (PoR).\n Proof of Reputation (PoR) can be seen as an extension of PoA. It was recently proposed by different research groups and companies [\n9\n, \n38\n, \n44\n]. The PoR consensus algorithm may have different variations and parameters tuning its performance, but the basic idea is simple. Reputation is accumulated and calculated by predefined formulas. Once a node proves reputation and passes verification, it may be voted into the network as an authoritative node and, at this point, it operates like a PoA, where only authoritative nodes can sign and validate blocks.\n\n\n\n\n\n\n\n\nIn the practical applications, according to different constraints, there are mainly two types of consensus algorithms: strong consistency consensus and eventual consistency consensus. Typical strong consistency consensus algorithms include BFT and PBFT that consider Byzantine faults as well as Paxos [\n58\n] and Raft [\n70\n] without considering Byzantine failure. The strong consistency consensus algorithms are mostly used in the private blockchain and consortium blockchain where the number of nodes is relatively small and there is a stronger requirement for consistency and correctness. More specifically, PBFT is more suitable for consortium blockchain, whereas Paxos and Raft are suitable for private blockchain. Because in both Paxos and Raft, all members of the network are trusted. As shown in Table \n3\n, Paxos and Raft have better fault tolerance than PBFT, but it should be noted that the fault tolerance of Paxos/Raft only considers node failures without considering the Byzantine fault tolerance. In addition, the communication complexity of Paxos and Raft are much lower than that of PBFT, and they are easy to implement in practical systems.\n\n\n\n\n\n\nTable 3.\n\n\nSummary of Consensus Algorithms\n\n\n\n\n\n\n\n\n\n\nConsensus\n\n\nConsistency\n\n\nEfficiency\n\n\nResource consumption\n\n\nFault tolerance\n\n\nScalability\n\n\nApplications\n\n\nApplicable blockchain type\n\n\n\n\n\n\n\n\n\n\nPoW\n\n\nFork\n\n\nLow\n\n\nHuge\n\n\n \n<\n50\n%\n<\n50\n%\n \n\n\nPoor\n\n\nBitcoin [\n67\n]\n\n\nPublic blockchain\n\n\n\n\n\n\nPoS\n\n\nFork\n\n\nHigher\n\n\nSlight small\n\n\n \n<\n50\n%\n<\n50\n%\n \n\n\nGood\n\n\nPPcoin [\n56\n]\n\n\n\n\n\n\n\n\nDPoS\n\n\nFork\n\n\nHigh\n\n\nSlight small\n\n\n \n<\n50\n%\n<\n50\n%\n \n\n\nGood\n\n\nBitshares [\n6\n]\n\n\n\n\n\n\n\n\nPBFT\n\n\nNo fork\n\n\nVery high\n\n\nVery small\n\n\n \n<\n33\n%\n<\n33\n%\n \n\n\nPoor\n\n\nFabric [\n3\n]\n\n\nConsortium blockchain\n\n\n\n\n\n\nPaxos/Raft\n\n\nNo fork\n\n\nHigh\n\n\nSmall\n\n\n \n<\n50\n%\n<\n50\n%\n \n\n\nGood\n\n\nZookeeper [\n8\n]\n\n\nPrivate blockchain\n\n\n\n\n\n\n\n\n\n\nTypical eventual consistency consensus algorithms include PoW, PoS, and DPoS. The eventual consistency consensus algorithms are used in public blockchain where the number of nodes is large and it is difficult to achieve 100% consistency and correctness for all nodes. The choice of the consensus algorithm is highly related to the application scenario. As the blockchain technology is applied to various fields, more consensus algorithms suitable for different application fields will be developed in the future.\n\n\n\n\n\n\n\n\nIn this section, we provide a detailed discussion on a selection of techniques that can be leveraged to enhance the security and privacy of existing and future blockchain systems.\n\n\n\n\nAs we mentioned before, Bitcoin's blockchain does not guarantee anonymity for users: transactions use pseudonymous addresses and can be verified publicly. Thus, anyone can relate a user's transaction to her other transactions by a simple analysis of addresses she used in making bitcoin exchanges. More seriously, when the address of transaction is linked to the real-world identity of a user, it may cause the leakage of all her transactions. Thus, \nmixing services\n (\nor tumblers\n) was designed to prevent users\u2019 addresses from being linked. Mixing, literally, is a random exchange of user's coins with other users\u2019 coins. As a result, for the observer, their ownership of coins are obfuscated. However, these mixing services do not provide protection from coin theft. In this section, we describe two such mixing services and analyze their security and privacy properties.\n\n\n\n\n \n5.1.1\n \nMixcoin.\n Mixcoin [\n21\n] was proposed by Bonneau et al. in 2014, which provides anonymous payment in Bitcoin and bitcoin-like cryptocurrencies. To defend against passive adversaries, Mixcoin extends the anonymity set to allow all users to mix coins simultaneously. To defend against active adversaries, Mixcoin provides anonymity similar to traditional communication mixes. In addition, Mixcoin uses an accountability mechanism to detect stealing, and it shows that users will use Mixcoin rationally without stealing bitcoins by aligning incentives [\n21\n].\n\n\n\n\n\n\n \n5.1.2\n \nCoinJoin.\n CoinJoin [\n62\n] was proposed in 2013 as an alternative anonymization method for bitcoin transactions. It is motivated by the idea of joint payment. Suppose a user wants to make a payment. She will find another user who also wants to make a payment, and they make a joint payment together in one transaction by negotiation. By the joint payment, it significantly reduces the probability of linking inputs and outputs in one transaction and tracing the exact direction of money movement of a specific user.\n\n\nCoinJoin requires that users negotiate transactions with whom they wish to join payment. The first generation of the mixing services to offer this functionality (such as SharedCoin [\n66\n]) has used centralized servers and required users to trust the service operator not to steal or allow others to steal the bitcoins. However, despite the single point of failure, centralized services may have risk of leakage of users\u2019 privacy because they will keep logs of the transactions and record all participants of joint payment.\n\n\nIn addition, incorrectly implementation of CoinJoin protocol also will diminish the anonymity. Kristov Atlas identified such a flaw in the SharedCoin mixing service [\n66\n] and provided a detailed analysis of the flaw in Ref. [\n12\n]. In Ref. [\n12\n], Kristov Atlas developed a tool named \u201cCoinJoin Sudoku\u201d [\n11\n], which could identify SharedCoin transactions and discover relationships between specific payments and payees, indicating that the SharedCoin mixing service can not provide strong privacy for transactions.\n\n\nCoinShuffle [\n79\n] was proposed by Tim Ruffing et al. in 2014, which further extends the CoinJoin concept and increases privacy by avoiding the necessity of a trusted third-party for mixing transactions. CoinShuffle is claimed as a completely decentralized coin-mixing protocol and has the ability to ensure security against theft. To ensure anonymity, CoinShuffle uses a novel accountable anonymous group communication protocol, which is called Dissent [\n33\n].\n\n\n\n\n\n\n\n\nDigital signature technology was developed by several variants. Some signature schemes themselves have the ability of providing anonymity for the signer. We call this kind of signature schemes anonymous signature. Among the anonymous signature schemes, group signature and ring signature were proposed earlier and are the two most important and typical anonymous signature schemes.\n\n\n\n\n \n5.2.1\n \nGroup Signature.\n Group signature is a cryptography scheme proposed initially in 1991 [\n27\n]. Given a group, any of its members can sign a message for the entire group anonymously by using her personal secret key, and any member with the group's public key can check and validate the generated signature and confirm that the signature of some group member is used to sign the message. The process of signature verification reveals nothing about true identity of the signer except the membership of the group.\n\n\nGroup signature has a group manager who manages adding group members, handling the event of disputes, including revealing the original signer. In blockchain system, we also need an authority entity to create and revoke the group and dynamically add new members to the group and delete/revoke membership of some participants from the group.\n\n\nSince the group signature requires a group manager to setup the group, the group signature is suitable for consortium blockchain. Recently, PlatON [\n4\n] added group signature in its platform for providing users with anonymity support.\n\n\n\n\n\n\n \n5.2.2\n \nRing Signature.\n Ring signature [\n78\n] also can achieve anonymity through signing by any member of a group of users. The term of \u201cring signature\u201d originates from the signature algorithm that uses the ring-like structure. The ring signature is anonymous if it is difficult to determine which member of the group uses his/her key to sign the message.\n\n\nRing signatures differ from group signatures in two principal ways: First, in a ring signature scheme, the real identity of the signer cannot be revealed in the event of dispute, since there is no group manager in ring signature. Second, any users can group a \u201cring\u201d by themselves without additional setup. Thus, ring signature is applicable to public blockchain.\n\n\nOne of the typical applications of ring signature is CryptoNote [\n80\n]. It adopts ring signature to hide the connection between the sender's addresses of transactions. More precisely, CryptoNote constructs the sender's public key with several other keys so that it is impossible to identify who actually sent (signed) the transaction. Due to the use of ring signature, if the number of ring members is \nn\nn\n, then the probability that an adversary may successfully guess a real sender of a transaction is \n1\n/\nn\n1\n/\nn\n. Later, Ethereum added ring signature in 2015, which gives the users anonymity like CryptoNote currencies such as Monero [\n5\n].\n\n\n\n\n\n\n\n\nHomomorphic encryption (HE) is a powerful cryptography. It can perform certain types of computations directly on ciphertext and ensure that the operations performed on the encrypted data, when decrypting the computed results, will generate identical results to those performed by the same operations on the plaintext. There are several partially homomorphic crypto-systems [\n37\n, \n71\n, \n77\n] as well as fully homomorphic systems [\n41\n, \n87\n].\n\n\nOne can use homomorphic encryption techniques to store data over the blockchain with no significant changes in the blockchain properties. This ensures that the data on the blockchain will be encrypted, addressing the privacy concerns associated with public blockchains. The use of homomorphic encryption technique offers privacy protection and allows ready access to encrypted data over public blockchain for auditing and other purposes, such as managing employee expenses. Ethereum smart contracts provide homomorphic encryption on data stored in blockchain for greater control and privacy.\n\n\n\n\n\n\nAttribute-based encryption (ABE) is a cryptographic method in which attributes are the defining and regulating factors for the ciphertext encrypted using the secret key of a user. One can decrypt the encrypted data using the users secret key if her attributes agree with the attributes of the ciphertext. The collusion-resistance is an important security property of ABE. It ensures that when a malicious user colludes with other users, he cannot access other data except the data that he can decrypt with his private key.\n\n\nThe concept of attribute-based encryption was proposed in 2005 [\n81\n] with single authority. Since then, a number of extensions have been proposed to the baseline ABE, including ABE with multiple authorities to generate users\u2019 private keys jointly [\n26\n, \n52\n, \n60\n] and ABE schemes that support arbitrary predicates [\n40\n, \n47\n].\n\n\nAttribute-based encryption is very powerful, yet few applications to date deploy it due to the lack of understanding of both core concepts and efficient implementation. ABE has not yet been deployed in any form on a blockchain for real-time operation to date. In 2011, a decentralized ABE scheme was proposed [\n60\n] to employ ABE on a blockchain. For example, on a blockchain, permissions could be represented by ownership of access tokens. All nodes in the network, which have a certain token issued to them, will be granted access to the special rights and privileges associated with the token. The token provides a means of tracking who has certain attributes and such tracking should be done in an algorithmic and consistent fashion by the authority entity that distributes the token. Tokens can be viewed as badges that represent attributes or qualifications, and should be used as non-transferable quantifiers of reputation or attributes.\n\n\nIn Ref. [\n60\n], it is shown that there is no need for a fixed authority to do attribute-based encryption. It is possible to have multiple authorities in a decentralized network and fulfill the same accomplishment. For instance, relying on witnesses for the role of these authorities may be possible in a blockchain, with technologies, recently made possible, such as Steemit [\n7\n], Storj [\n93\n], InterPlanetary File System (IPFS) [\n15\n], and Secure Access For Everyone (SAFE) Network [\n69\n], though an implementation of attribute-based encryption utilizing a blockchain approach remains to be an open challenge.\n\n\n\n\n\n\nThe multi-party computation (MPC) model defines a multi-party protocol to allow them to carry out some computation jointly over their private data inputs without violating their input privacy, such that an adversary learns nothing about the input of an authentic party but the output of the joint computation.\n\n\nAndrew Yao formally defined secure two-party computation in 1982 [\n94\n] and generalized it in 1986 [\n95\n] for the Millionaires\u2019 problem. Goldreich et al. proposed a generalization of the two party computation to the multi-party computation in 1987 [\n45\n], assuming that all inputs of the computation and zero-knowledge proofs are parts of secret sharing. This generalization has served as the foundation for many subsequent and increasingly efficient MPC protocols. The success of employing MPC in distributed voting, private bidding, and private information retrieval has made it a popular solution to many real-world problems. The first large-scale deployment of MPC was in 2008 for an actual auction problem in Denmark [\n19\n].\n\n\nIn recent years, MPC has been used in blockchain systems to protect users\u2019 privacy. Andrychowicz et al. designed and implemented secure multiparty computation protocols on Bitcoin system in 2014 [\n10\n]. They constructed protocols for secure multiparty lotteries without any trusted authority. Their protocols are able to guarantee fairness for the honest users regardless of how dishonest one behaves. If a user violates or interferes with the protocol, then she becomes a loser and her bitcoins are transported to the honest users.\n\n\nA decentralized SMP computation platform, called Enigma, is proposed in 2015 by Zyskind et al. [\n96\n]. By using an advanced version of SMP computation, Enigma employs a verifiable secret-sharing scheme to guarantee privacy of its computational model. Also, Enigma encodes shared secret data using a modified distributed hash table for efficient storage. Moreover, it leverages an external blockchain as a corruption-resistant recording of events and the regulator of the peer-to-peer network for identity management and access control. Similar to the Bitcoin system, Enigma provides autonomous control and protection of personal data while eliminating the necessity and dependency of a trusted third party.\n\n\n\n\n\n\nAnother cryptographic technology that has powerful privacy-preserving properties is zero-knowledge proofs, proposed in the early 1980s [\n46\n]. The basic idea is that a formal proof can be formulated to verify that a program executed with some input privately known by the user can produce some publicly open output with no disclosure of any other information. In other words, a certifier can prove to a verifier that some assertion is accurate without providing any useful information to the verifier.\n\n\nAs a variant of zero-knowledge proofs, it is shown in Ref. [\n18\n] that, with the non-interactive variant of zero-knowledge proofs, coined as NIZK, one can achieve computational zero-knowledge without requiring certifier and verifier to interact at all, provided that the certifier and the verifier shares a common reference string. In a blockchain application, all account balances are encrypted and stored in the chain. When a user transfers money to another user, he can easily prove that he has sufficient balance for the transfer with zero-knowledge proofs, without revealing the account balance.\n\n\nAnother variation is the zero-knowledge Succinct Non-interactive ARgument of Knowledge (zk-SNARK) proof, introduced in 2012 by Bitansky and his coauthors [\n16\n] and is served as the backbone of the Zcash protocol [\n82\n]. Zcash [\n82\n] uses zk-SNARKs [\n17\n, \n48\n] to verify transactions while protecting users\u2019 privacy.\n\n\nRecently, the Zcash group enhanced the Ethereum contract language to efficiently provide zk-SNARK proofs verification. More specifically, they adopted a snark-verify precompile (like an opcode) to a fork of \u201cParity,\u201d which uses lib-snark to verify generic proofs. They also used the new zk-SNARK verifier to enforce an original coin mixing contract, which adopts a simplified version of Zerocash, an academic protocol whose implementation is used to build Zcash. Thus, it is called \u201cbaby\u201d ZoE, standing for Zerocash over Ethereum. The contract allows a user to store discrete amounts (units of ETH) by adding a \u201cserial number\u201d as a commitment into a Merkle tree, which is maintained by the contract.\n\n\n\n\n\n\nAn execution environment is called TEE if it provides a completely isolated environment for application execution, which effectively prevents other software applications and operating system(s) from tampering with and learning the state of the application running in it. The Intel Software Guard eXtensions (SGX) is a representative technology to implement a TEE. For example, Ekiden [\n29\n] is a SGX-based solution for confidentiality-preserving smart contracts. Ekiden separates computation from consensus. It performs smart contract computation in TEEs on compute nodes off chain, then uses a remote attestation protocol to validate the execution correctness of compute nodes on chain. The consensus nodes are used for maintaining the blockchain and do not require to use a trusted hardware. Enigma [\n96\n] utilizes TEE in its current version to allow users to create privacy-preserving smart contracts using a decentralized credit scoring algorithm. Multiple factors are weighted for credit scoring, such as the number and types of accounts, payment history, and credit utilization.\n\n\n\n\n\n\nThe game-based solutions for smart contracts verification are very recent developments, represented by TrueBit [\n86\n] and Arbitrum [\n53\n].\n\n\nTrueBit [\n86\n] uses an interactive \u201cverification game\u201d to decide whether a computational task was correctly performed or not. TrueBit offers rewards to encourage players to check computation tasks and find bugs, such that a smart contract can securely perform a computation task with verifiable properties. In addition, in each round of \u201cverification game,\u201d the verifier recursively checks a smaller and smaller subset of the computation, which allows TrueBit to greatly reduce the computational burden on its nodes.\n\n\nArbitrum [\n53\n] has designed an incentive mechanism for parties to agree off-chain on the behavior of virtual machines, so that it only requires the verifiers to verify digital signatures of the contracts. For dishonest parties who try to lie about the behavior of virtual machines, Arbitrum has designed an efficient challenge-based protocol to identify and penalize the dishonest parties. The incentive mechanism of off-chain verification of virtual machine's behavior has significantly improved the scalability and the privacy of smart contracts.\n\n\n\n\n\n\nWe summarize the pros and cons of each security and privacy technique in Table \n4\n. To achieve security and privacy in a complex blockchain system that needs to meet multiple security and privacy requirements with desired properties, we would like to make the following three remarks: (1) No single technology is a panacea for security and privacy of Blockchain. Therefore, the appropriate security and privacy techniques should be chosen based on the security and privacy requirements and the context of application. In general, the combination of multiple technologies works more effectively than using a single technology. For example, Enigma [\n96\n] combines cutting-edge cryptographic technique SMPC and hardware privacy technology TEE with blockchains to provide computation over encrypted data at scale. (2) There is no technology that has no defects or is perfect in all aspects. When we add a new technology to a complex system, it always causes other problems or a new form(s) of attacks. This requires careful attention on the pitfalls and potential harms induced from integrating some security and privacy techniques into the blockchains. (3) There is always a tradeoff between security, privacy, and efficiency. We should advocate those techniques that improve the security and privacy of blockchain and at the same time promote the practical deployment of the blockchain applications with acceptable performance.\n\n\n\n\n\n\nTable 4.\n\n\nSummary of Security and Privacy Techniques\n\n\n\n\n\n\n\n\n\n\nTechniques\n\n\nApplications\n\n\nAdvantages\n\n\nDisadvantages\n\n\n\n\n\n\n\n\n\n\nMixing\n\n\nMixcoin [\n21\n], CoinJoin [\n62\n]\n\n\nIt can prevent users\u2019 addresses from being linked.\n\n\nThe centralized services may have risk of leakage of users\u2019 privacy.\n\n\n\n\n\n\nGroup signature\n\n\nPlatON [\n4\n]\n\n\nThe identity of signer can be hidden among a group of users. In the event of a dispute, the identity of the signer can be revealed.\n\n\nNeed a trusted third party to act as a manager.\n\n\n\n\n\n\nRing signature\n\n\nCryptoNote [\n80\n], Monero [\n5\n], Ethereum [\n2\n]\n\n\nThe identity of signer can be hidden among a group of users. No need for the participation of any trusted third party.\n\n\nIn the event of a dispute, the identity of the signer cannot be revealed.\n\n\n\n\n\n\nABE\n\n\nNone\n\n\nIt can simultaneously achieve data confidentiality and fine-grained access control.\n\n\nThe issuance and revocation of attribute certificate in a distributed environment still need to be resolved.\n\n\n\n\n\n\nHE\n\n\nEthereum [\n2\n]\n\n\nIt can achieve privacy-preserving computation by performing computations directly on ciphertext.\n\n\nOnly some types of operations, such as addition and multiplication, can be efficiently implemented. The computational efficiency of complex functions is very low.\n\n\n\n\n\n\nSMPC\n\n\nEnigma [\n96\n]\n\n\nIt allows multi-party to carry out some computation jointly over their private data inputs without violating their input privacy.\n\n\nOnly some simple functions can be supported, and complex functions are less efficient.\n\n\n\n\n\n\nNIZK\n\n\nZcash [\n82\n]\n\n\nUser can easily prove that he has sufficient balance for the transfer with NIZK, while without revealing the account balance.\n\n\nLess efficient\n\n\n\n\n\n\nTEE-based solutions\n\n\nEkiden [\n29\n], Enigma [\n96\n]\n\n\nIt can protect the privacy of smart contracts by running them in TEE.\n\n\nThe compute nodes need to be equipped with a CPU, which has TEE, such as Intel SGX. The attacks on SGX still need to be resolved.\n\n\n\n\n\n\nGame-Based solutions\n\n\nTrueBit [\n86\n], Arbitrum [\n53\n]\n\n\nIt encourages parties to verify the correctness of smart contracts through incentives mechanisms.\n\n\nThere is still a risk of being deceived by a malicious user.\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
}