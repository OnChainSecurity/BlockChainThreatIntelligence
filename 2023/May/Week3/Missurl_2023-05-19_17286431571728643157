{
    "threat_intelligence": {
        "url": "https://ethereum.org/pcm/developers/tutorials/scam-token-tricks/",
        "timestamp": "2023-05-19 00:00:00",
        "original_content": "Some tricks used by scam tokens and how to detect them\nscam\nsolidity\nerc-20\njavascript\ntypescript\nIntermediate\nOri Pomerantz\n 2023915\n15 minute read minute read\nIn this tutorial we dissect \na scam token\n(opens in a new tab)\n to see some of the tricks that scammers play and how they implement them. By the end of the tutorial you will have a more comprehensive view of ERC-20 token contracts, their capabilities, and why skepticism is necessary. Then we look at the events emitted by that scam token and see how we can identify that it is not legitimate automatically.\nScam tokens - what are they, why do people do them, and how to avoid them\nOne of the most common uses for Ethereum is for a group to create a tradable token, in a sense their own currency. However, anywhere there are legitimate use cases that bring value, there are also criminals who try to steal that value for themselves.\nYou can read more about this subject \nelsewhere on ethereum.org\n from a user perspective. This tutorial focuses on dissecting a scam token to see how it's done and how it can be detected.\nHow do I know wARB is a scam?\nThe token we dissect is \nwARB\n(opens in a new tab)\n, which pretends to be equivalent to the legitimate \nARB token\n(opens in a new tab)\n.\nThe easiest way to know which is the legitimate token is looking at the originating organization, \nArbitrum\n(opens in a new tab)\n. The legitimate addresses are specified \nin their documentation\n(opens in a new tab)\n.\nWhy is the source code available?\nNormally we'd expect people who try to scam others to be secretive, and indeed many scam tokens do not have their code available (for example, \nthis one\n(opens in a new tab)\n and \nthis one\n(opens in a new tab)\n).\nHowever, legitimate tokens usually publish their source code, so to appear legitimate scam tokens' authors' sometimes do the same. \nwARB\n(opens in a new tab)\n is one of those tokens with source code available, which makes it easier to understand it.\nWhile contract deployers can choose whether or not to publish the source code, they \ncan't\n publish the wrong source code. The block explorer compiles the provided source code independently, and if doesn't get the exact same bytecode, it rejects that source code. \nYou can read more about this on the Etherscan site\n(opens in a new tab)\n.\nComparison to legitimate ERC-20 tokens\nWe are going to compare this token to legitimate ERC-20 tokens. If you are not familiar with how legitimate ERC-20 tokens are typically written, \nsee this tutorial\n.\nConstants for privileged addresses\nContracts sometimes need privileged addresses. Contracts that are designed for long term use allow some privileged address to change those addresses, for example to enable the use of a new multisig contract. There are several ways to do this.\nThe \nHOP\n token contract\n(opens in a new tab)\n uses the \nOwnable\n(opens in a new tab)\n pattern. The privileged address is kept in storage, in a field called \n_owner\n (see the third file, \nOwnable.sol\n).\nThe \nARB\n token contract\n(opens in a new tab)\n does not have a privileged address directly. However, it does not need one. It sits behind a \nproxy\n(opens in a new tab)\n at \naddress \n0xb50721bcf8d664c30412cfbc6cf7a15145234ad1\n(opens in a new tab)\n. That contract has a privileged address (see the fourth file, \nERC1967Upgrade.sol\n) that be used for upgrades.\nIn contrast, the \nwARB\n contract has a hard coded \ncontract_owner\n.\nThis contract owner\n(opens in a new tab)\n is not a contract that could be controlled by different accounts at different times, but an \nexternally owned account\n. This means that it is probably designed for short term use by an individual, rather than as a long term solution to control an ERC-20 that will remain valuable.\nAnd indeed, if we look in Etherscan we see that the scammer only used this contract for only 12 hours (\nfirst transaction\n(opens in a new tab)\n to \nlast transaction\n(opens in a new tab)\n) during May 19th, 2023.\nThe fake \n_transfer\nfunction\nIt is standard to have actual transfers happen using \nan internal \n_transfer\n function\n.\nIn \nwARB\n this function looks almost legitimate:\nThe suspicious part is:\nIf the contract owner sends tokens, why does the \nTransfer\n event show they come from \ndeployer\n?\nHowever, there is a more important issue. Who calls this \n_transfer\n function? It can't be called from the outside, it is marked \ninternal\n. And the code we have doesn't include any calls to \n_transfer\n. Clearly, it is here as a decoy.\nWhen we look at the functions that are called to transfer tokens, \ntransfer\n and \ntransferFrom\n, we see that they call a completely different function, \n_f_\n.\nThe real \n_f_\nfunction\nThere are two potential red flags in this function.\nThe use of the \nfunction modifier\n(opens in a new tab)\n \n_mod_\n. However, when we look into the source code we see that \n_mod_\n is actually harmless.\nThe same issue we saw in \n_transfer\n, which is when \ncontract_owner\n sends tokens they appear to come from \ndeployer\n.\nThe fake events function \ndropNewTokens\nNow we come to something that looks like an actual scam. I edited the function a bit for readability, but it's functionally equivalent.\nThis function has the \nauth()\n modifier, which means it can only be called by the contract owner.\nThis restriction makes perfect sense, because we wouldn't want random accounts to distribute tokens. However, the rest of the function is suspicious.\nA function to transfer from a pool account to an array of receivers an array of amounts makes perfect sense. There are many use cases in which you'll want to distribute tokens from a single source to multiple destinations, such as payroll, airdrops, etc. It is cheaper (in gas) to do in a single transaction instead of issuing multiple transactions, or even calling the ERC-20 multiple times from a different contract as part of the same transaction.\nHowever, \ndropNewTokens\n doesn't do that. It emits \nTransfer\n events\n(opens in a new tab)\n, but does not actually transfer any tokens. There is no legitimate reason to confuse offchain applications by telling them of a transfer that did not really happen.\nThe burning \nApprove\nfunction\nERC-20 contracts are supposed to have \nan \napprove\n function\n for allowances, and indeed our scam token has such a function, and it is even correct. However, because Solidity is descended from C it is case significant. \"Approve\" and \"approve\" are different strings.\nAlso, the functionality is not related to \napprove\n.\nThis function is called with an array of addresses for holders of the token.\nThe \napprover()\n modifying makes sure only \ncontract_owner\n is allowed to call this function (see below).\nFor every holder address the function moves the holder's entire balance to the address \n0x00...01\n, effectively burning it (the actual \nburn\n in the standard also changes the total supply, and transfers the tokens to \n0x00...00\n). This means that \ncontract_owner\n can remove the assets of any user. That doesn't seem like a feature you'd want in a governance token.\nCode quality issues\nThese code quality issues don't \nprove\n that this code is a scam, but they make it appear suspicious. Organized companies such as Arbitrum don't usually release code this bad.\nThe \nmount\nfunction\nWhile it is not specified in \nthe standard\n(opens in a new tab)\n, generally speaking the function that creates new tokens is called \nmint\n(opens in a new tab)\n.\nIf we look in the \nwARB\n constructor, we see the time mint function has been renamed to \nmount\n for some reason, and is called five times with a fifth of the initial supply, instead of once for the entire amount for efficiency.\nThe \nmount\n function itself is also suspicious.\nLooking at the \nrequire\n, we see that only the contract owner is allowed to mint. That is legitimate. But the error message should be \nonly owner is allowed to mint\n or something like that. Instead, it is the irrelevant \nERC20: mint to the zero address\n. The correct test for minting to the zero address is \nrequire(account != address(0), \"<error message>\")\n, which the contract never bothers to check.\nThere are two more suspicious facts, directly related to minting:\nThere is an \naccount\n parameter, which is presumably the account that should receive the minted amount. But the balance that increases is actually \ncontract_owner\n's.\nWhile the balance increased belongs to \ncontract_owner\n, the event emitted shows a transfer to \naccount\n.\nWhy both \nauth\n and \napprover\n? Why the \nmod\nthat does nothing?\nThis contract contains three modifiers: \n_mod_\n, \nauth\n, and \napprover\n.\n_mod_\n takes three parameters and doesn't do anything with them. Why have it?\nauth\n and \napprover\n make more sense, because they check that the contract was called by \ncontract_owner\n. We'd expect certain privileged actions, such as minting, to be limited to that account. However, what is the point of having two separate functions that do \nprecisely the same thing\n?\nWhat can we detect automatically?\nWe can see that \nwARB\n is a scam token by looking at Etherscan. However, that is a centralized solution. In theory, Etherscan could be subverted or hacked. It is better to be able to figure out independently if a token is legitimate or not.\nThere are some tricks we can use to identify that an ERC-20 token is suspicious (either a scam or very badly written), by looking at the events they emit.\nSuspicious \nApproval\nevents\nApproval\n events\n(opens in a new tab)\n should only happen with a direct request (in contrast to \nTransfer\n events\n(opens in a new tab)\n which can happen as a result of an allowance). \nSee the Solidity docs\n(opens in a new tab)\n for a detailed explanation of this issue and why the requests need to be direct, rather than mediated by a contract.\nThis means that \nApproval\n events that approve spending from an \nexternally owned account\n have to come from transactions that originate in that account, and whose destination is the ERC-20 contract. Any other kind of approval from an externally owned account is suspicious.\nHere is \na program that identifies this kind of event\n(opens in a new tab)\n, using \nviem\n(opens in a new tab)\n and \nTypeScript\n(opens in a new tab)\n, a JavaScript variant with type safety. To run it:\nCopy \n.env.example\n to \n.env\n.\nEdit \n.env\n to provide the URL to an Ethereum mainnet node.\nRun \npnpm install\n to install the necessary packages.\nRun \npnpm susApproval\n to look for suspicious approvals.\nHere is a line by line explanation:\nImport type definitions, functions, and the chain definition from \nviem\n.\nRead \n.env\n to get the URL.\nCreate a Viem client. We only need to read from the blockchain, so this client does not need a private key.\nThe address of the suspicious ERC-20 contract, and the blocks within which we'll look for events. Node providers typically limit our ability to read events because the bandwidth can get expensive. Luckily \nwARB\n wasn't in use for an eighteen hour period, so we can look for all the events (there were only 13 in total).\nThis is the way to ask Viem for event information. When we provide it with the exact event signature, including field names, it parses the event for us.\nOur algorithm is only applicable to externally owned accounts. If there is any bytecode returned by \nclient.getBytecode\n it means that this is a contract and we should just skip it.\nIf you haven't used TypeScript before, the function definition might look a bit weird. We don't just tell it the first (and only) parameter is called \naddr\n, but also that it is of type \nAddress\n. Similarly, the \n: boolean\n part tells TypeScript that the return value of the function is a boolean.\nThis function gets the transaction receipt from an event. We need the receipt to ensure we know what was the transaction destination.\nThis is the most important function, the one that actually decides if an event is suspicious or not. The return type, \n(Event | null)\n, tells TypeScript that this function can return either an \nEvent\n or \nnull\n. We return \nnull\n if the event is not suspicious.\nViem has the field names, so it parsed the event for us. \n_owner\n is the owner of the tokens to be spent.\nIf the owner is a contract, assume this approval is not suspicious. To check if a contract's approval is suspicious or not we'll need to trace the full execution of the transaction to see if it ever got to the owner contract, and if that contract called the ERC-20 contract directly. That is a lot more resource expensive than we'd like to do.\nIf the approval comes from an externally owned account, get the transaction that caused it.\nWe can't just check for string equality because addresses are hexadecimal, so they contain letters. Sometimes, for example in \ntxn.from\n, those letters are all lowercase. In other cases, such as \nev.args._owner\n, the address is in \nmixed-case for error identification\n(opens in a new tab)\n.\nBut if the transaction isn't from the owner, and that owner is externally owned, then we have a suspicious transaction.\nSimilarly, if the transaction's \nto\n address, the first contract called, isn't the ERC-20 contract under investigation then it is suspicious.\nIf neither condition is true then the \nApproval\n event is not suspicious.\nAn \nasync\n function\n(opens in a new tab)\n returns a \nPromise\n object. With the common syntax, \nawait x()\n, we wait for that \nPromise\n to be fulfilled before we continue processing. This is simple to program and follow, but it is also inefficient. While we are waiting for the \nPromise\n for a specific event to be fulfilled we can already get working on the next event.\nHere we use \nmap\n(opens in a new tab)\n to create an array of \nPromise\n objects. Then we use \nPromise.all\n(opens in a new tab)\n to wait for all of those promises to the resolved. We then \nfilter\n(opens in a new tab)\n those results to remove the non-suspicious events.\nSuspicious \nTransfer\nevents\nAnother possible way to identify scam tokens is to see if they have any suspicious transfers. For example, transfers from accounts that don't have that many tokens. You can see \nhow to implement this test\n(opens in a new tab)\n, but \nwARB\n doesn't have this issue.\nConclusion\nAutomated detection of ERC-20 scams suffers from \nfalse negatives\n(opens in a new tab)\n, because a scam can use a perfectly normal ERC-20 token contract that just doesn't represent anything real. So you should always attempt to \nget the token address from a trusted source\n.\nAutomated detection can help in certain cases, such as DeFi pieces, where there are many tokens and they need to be handled automatically. But as always \ncaveat emptor\n(opens in a new tab)\n, do your own research, and encourage your users to do likewise.\nShey dis tutorial dey helep?"
    }
}