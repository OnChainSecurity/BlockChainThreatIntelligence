{
    "threat_intelligence": {
        "url": "https://www.blocknative.com/blog/mev-and-creating-a-basic-arbitrage-bot-on-ethereum-mainnet",
        "timestamp": "2023-01-01 00:00:00",
        "original_content": "January 2023 Update: If you are an MEV searcher, Blocknative now offers an MEV bundle RPC endpoint. Searchers can interact with the RPC endpoint at \nhttps://api.blocknative.com/v1/auction\n. The API provides JSON-RPC methods for interfacing with Blocknative builders, which are documented via our \nbundle docs\n.\nAt Blocknative we are often asked about getting started in the world of \nMEV\n. In this blog, I will go over the creation of a very basic arbitrage script that highlights some key ideas in the world of MEV bots.\n\n\nMEV, or Maximal Extractable Value, is essentially the maximum value that can be extracted from a block. While this had traditionally been an opportunity that only miners could participate in\u2014which is why it was sometimes called Miner Extractable Value\u2014the democratization of the mempool has allowed more opportunities for traders to extract value by influencing what goes into a block. MEV Searchers can easily affect which transactions are included and excluded, or even change the order of transactions in a block, by seeing what\u2019s already in the mempool and then timing and pricing their transactions accordingly.\n\n\nThese Searchers will typically run algorithms to detect profitable MEV opportunities and have bots automatically submit any profitable transactions to the network. This blog details my attempt at creating one of these bots, and the lessons I learned along the way. You can treat this as a beginner\u2019s guide to help you get your creative juices flowing and start thinking about other strategies unique to you.\n\n\nPlease note the script and smart contract in this blog are for educational purposes only\n. You will not make any money using this code, so please do your own research before deploying any of your own money into any opportunity. Ethereum mainnet is extremely competitive, and this idea is quite common among the elite bots in the ecosystem.\u00a0\n\n\nWhat is an arbitrage strategy in the world of MEV?\u00a0\n\n\nArbitrage is an \nMEV strategy\n that allows traders to profit from price differences between the same asset in different markets.\u00a0In the traditional financial world, this creates an opportunity to make two trades to get the two exchanges into equilibrium\u2014and make a little profit for doing so.\n\n\nYou would start with asset A and sell it for asset B on the exchange where asset B is cheaper. Then, you would take asset B and sell it for asset A on the other exchange, receiving more of asset A in return than when you started. This basic example is extremely competitive in traditional finance and many High Frequency Traders compete against each other to be the first ones to complete the arbitrage opportunity.\n\n\nIn the MEV world, things are a little bit more complicated. In crypto, transactions are submitted to the mempool\u2014which, for the most part, is public\u2014 for inclusion into the next block. This means traders can see pending transactions in the mempool and know what the effects will be once they are finalized on-chain.\u00a0\n\n\nThis added visibility results in MEV arbitrage working slightly differently than traditional arbitrage because traders don\u2019t need to wait until transactions are on-chain to find an opportunity. As a result, MEV searchers need a \nreal-time data feed of the mempool\n to analyze each transaction as it comes in.\u00a0\n\n\nOnce you detect a transaction that might cause an arbitrage opportunity when it lands on-chain, you can send your two transactions that will complete the arbitrage opportunity directly into the mempool or to the flashbots private relay as a bundle. If done correctly, this means the mempool transaction that creates the opportunity + your two transactions will all be mined in the same block. As a result, the moment that arbitrage opportunity is created it is also completed by the next two transactions\u2014your two transactions.\u00a0\n\n\nLet\u2019s break this down with a completely unrealistic, but hopefully illuminating example.\n\n\n\n\nSuppose you are monitoring the mempool and you detect a transaction that will impact the liquidity pool on Uniswap V2 for token A and token B. Since you know that liquidity pools are \ngoverned by the equation x * y = k\n (I am ignoring fees in this example), then you know when you see somebody submit a swap for 2 of token A for as much of token B as possible, you can calculate (based on the reserves of those tokens in the liquidity pool, which, in this case, are 10 and 10) that they will receive 1.7 of token B in return. \n\n\n\u00a0\nThe key insight is that you know this transaction will impact the price between token A and token B on Uniswap V2, but not on another DEX like Sushiswap\u2026 at least not until somebody takes advantage of the arbitrage opportunity. The moment this transaction is mined, token A will be cheaper on Uniswap than Sushiswap, so whoever can sell token A on Sushiswap for token B and then sell those token Bs on Uniswap for token A should end up with more token A than they started. And that is exactly what this example illustrates. \n\n\nThere is some specific math that you can do to calculate the optimal amount to trade back and forth, but is beyond the scope of this post.\n\u00a0\n\n\nSearching for arbitrage opportunities\n\u00a0\n\n\nWhile doing some research on the various opportunities in MEV, I stumbled upon a pre-built smart contract in \nthis awesome github repo\n, which walks you through how to optimally calculate the correct amount needed to arbitrage between two Uniswap V2 DEXs\u2014for example Uniswap V2 and Sushiswap. \n\n\nSince this project wasn\u2019t really about taking a deep dive in solidity, this repo was perfect to get a proof of concept. The key insight with this smart contract is that you can supply it two pools\u2014one Uniswap pool and one Sushiswap pool\u2014 and return whether there is any profit arbitraging the two pools. However, the calculation is being done by looking at the reserves of those two pools as they currently stand (ie. the latest block state). \n\n\nBut what if you knew how those pools were going to change \nprior\n to the next block? Then you would know about arbitrage opportunities before they happen on-chain and you could submit your arbitrage transaction in the correct position to take advantage of these opportunities. My goal in this project was now to write a basic script that modifies this smart contract to successfully detect arbitrage opportunities using the \nBlocknative Simulation Platform\u2019s\n net balance change calculation.\n\n\nWriting a basic arbitrage script\n\n\nThis post is not a post to learn about solidity. There are plenty of great posts and tutorials out there, but in order to truly compete for MEV opportunities (at least in the EVM world), you need to know some solidity.\n\n\nThat said, I used my limited knowledge of solidity to update the smart contract to fit my needs. In order to calculate the real-time profit of an arbitrage opportunity, I would need to have some way of supplying my getProfit function with an adjustment on a liquidity pool. This adjustment is when I see a swap transaction in the mempool that will impact the Uniswap or Sushiswap liquidity pool. \n\n\nI incorporate the impact of the mempool transaction when I calculate the profit potential for the arbitrage opportunity. To incorporate this adjustment, I created a new struct called \u2018Adjustments\u2019 that would host the pool that needed to be adjusted, the direction it needed to be adjusted and the amount of adjustments to each token in the token pair. Then you will notice that getProfit relies on getOrderedReserves to calculate the reserves of each pool and the correct direction of the trades. Therefore, I added some logic to getOrderedReserves that would take in the mempool data of a token swap on Uniswap or Sushiswap and then adjust the token reserves of that pair so when getProfit was called it would incorporate the mempool data instead of just the latest chain state.\n\n\n\u00a0\n\n\nfunction\n \ngetOrderedReserves\n(\n\n        \naddress\n pool0,\n        \naddress\n pool1,\n        Adjustments \nmemory\n adjustment,\n        \nbool\n baseTokenSmaller\n    \n)\n        \ninternal\n\n        \nview\n\n        \nreturns\n (\n\n            \naddress\n lowerPool,\n            \naddress\n higherPool,\n            OrderedReserves \nmemory\n orderedReserves\n        \n)\n    \n{\n        (\nuint256\n pool0Reserve0, \nuint256\n pool0Reserve1, ) \n=\n IUniswapV2Pair(pool0).getReserves();\n        (\nuint256\n pool1Reserve0, \nuint256\n pool1Reserve1, ) \n=\n IUniswapV2Pair(pool1).getReserves();\n\n        \nif\n (pool0 \n=\n=\n adjustment.adjustmentPool) {\n            \nif\n (adjustment.adjustmentToken0 \n=\n=\n IUniswapV2Pair(pool0).token0()) {\n                pool0Reserve0 \n-\n=\n adjustment.adjustment0;\n                pool0Reserve1 \n+\n=\n adjustment.adjustment1;\n            } \nelse\n {\n                pool0Reserve1 \n-\n=\n adjustment.adjustment0;\n                pool0Reserve0 \n+\n=\n adjustment.adjustment1;\n            }\n        } \nelse\n {\n            \nif\n (adjustment.adjustmentToken0 \n=\n=\n IUniswapV2Pair(pool1).token0()) {\n                pool1Reserve0 \n-\n=\n adjustment.adjustment0;\n                pool1Reserve1 \n+\n=\n adjustment.adjustment1;\n            } \nelse\n {\n                pool1Reserve1 \n-\n=\n adjustment.adjustment0;\n                pool1Reserve0 \n+\n=\n adjustment.adjustment1;\n            }\n        }\n\n\n\u00a0\n\n\nNow that I have adjusted the smart contract to be able to incorporate the real-time mempool data, I can complete my script using \nBlocknative\u2019s mempool API\n and \nflashbots private relay\n.\n\n\nUsing Simulation Platform, each simulation is done in isolation against the current block state, meaning there is some degree of probability involved in the \u2018pending-simulation\u2019 payloads. However, if the transaction is at the top of the block, then that effectively means it is happening against the current block state, since there won\u2019t be any transactions between the current block state and this one. The best way to ensure it gets to the top of the block (or at least close to it) is to use flashbots private relay. \n\n\nFor this project, I looked at pending simulation events on the Uniswap V2 and Sushiswap routers using \nBlocknative\u2019s Javascript SDK\n. The pending simulation payloads include net balance changes on all the addresses involved (like the liquidity pool), allowing me to do two things:\n\n\n\n\nCheck to see if that pair exists on the other exchange\n\n\nUse the balance changes as inputs as the \u2018adjustments\u2019 in my getProfit function in my smart contract\n\n\n\n\nAs I receive these events I loop through the netBalanceChange list in our \nSimulation Platform\n payload and I skip when the address is equal to the actual router itself (because I am only looking for liquidity pool addresses) or if the netBalanceChange[index].address doesn\u2019t have 2 elements (if it only has 1 element, then it can\u2019t be a pool, because a pool would have 2 or more token reserves with net balance changes).\n\n\n\n\nIf one of the addresses in the netBalanceChange field is not one of the router addresses and has 2 different token addresses that have net balance changes, then it must be a pool address. I now have the pool address, the token addresses involved, and the net balance changes of each token. I can now check to see what the other DEX\u2019s liquidity pool address is so that I can supply it to my smart contract. If the other DEX does not have a liquidity pool with the same token pair, then I can\u2019t arbitrage between the two, so I move on.\n\n\n\u00a0\n\n\ntry\n {\n      \nfor\n (entry \nin\n transaction.\nnetBalanceChanges\n) {\n        \nif\n (transaction.\nnetBalanceChanges\n[entry].\nbalanceChanges\n.\nlength\n !== \n2\n\n          || blacklist.\nindexOf\n(transaction.\nnetBalanceChanges\n[entry].\naddress\n) !== -\n1\n )\n          { \ncontinue\n }\n\n        pairAddress = transaction.\nnetBalanceChanges\n[entry].\naddress\n;\n        tokenAddress1 = transaction.\nnetBalanceChanges\n[entry].\nbalanceChanges\n[\n0\n].\nasset\n.\ncontractAddress\n;\n        tokenAddress0 = transaction.\nnetBalanceChanges\n[entry].\nbalanceChanges\n[\n1\n].\nasset\n.\ncontractAddress\n;\n        adjustment1 = transaction.\nnetBalanceChanges\n[entry].\nbalanceChanges\n[\n0\n].\ndelta\n;\n        adjustment0 = transaction.\nnetBalanceChanges\n[entry].\nbalanceChanges\n[\n1\n].\ndelta\n.\nsubstring\n(\n1\n,);\n\n        adjustment0 = ethers.\nutils\n.\nparseEther\n(ethers.\nutils\n.\nformatEther\n(adjustment0)).\n_hex\n\n        adjustment1 = ethers.\nutils\n.\nparseEther\n(ethers.\nutils\n.\nformatEther\n(adjustment1)).\n_hex\n\n        otherPairAddress = \nawait\n \ngetSushiPair\n(tokenAddress0, tokenAddress1)\n\n        \nif\n (otherPairAddress === \nundefined\n) {\n          otherPairAddress = \nawait\n \ngetUniPair\n(tokenAddress0, tokenAddress1)\n          \nif\n (otherPairAddress === \nundefined\n) {\n            \ncontinue\n\n          }\n        }\n\n\n\u00a0\n\n\nLikewise, if the other DEX does have a liquidity pool with the same token pair, then I can arbitrage between the two. Using my script, this means I will have detected a pending swap on either Uniswap or Sushiswap in the mempool and I have located the same liquidity pool on the other DEX. Now I have all the information I need to supply my smart contract to see if there is a profit opportunity. \n\n\nThe result I get from my smart contract doesn\u2019t include gas, so I do a naive calculation to see what the all in gas cost would be (including my extra tip to the miners on the flashbots relay). I knew my two transactions would cost about 240K gas, so I hardcoded that in for my net-profit calculation. For my \ngas price\n, I assumed I would need to give up 95% of my gross profit to compete in the private relay. The 95% was hardcoded and arbitrary (room for improvement!). \n\n\nIf the net calculation is greater than 0, I have successfully found an arbitrage opportunity where I will net 5% and give the miner 95%!\n\n\n\u00a0\n\n\nprofitHex = \nawait\n arbContract.\ngetProfit\n(pairAddress, otherPairAddress, pairAddress, tokenAddress0, adjustment0, adjustment1)\n\nconst\n gross = ethers.\nutils\n.\nformatEther\n(profitHex.\ntoString\n(\n10\n).\nsplit\n(\n','\n)[\n0\n])\n\nconst\n gasLimit = \n240000\n\n\nconst\n gasFee = \nMath\n.\nfloor\n(ethers.\nutils\n.\nparseEther\n(gross)*\n.95\n/gasLimit)\n\nconst\n gasCost = gasLimit*gasFee\n\nconst\n net = ethers.\nutils\n.\nparseEther\n(gross) - gasCost\n\n\n\u00a0\n\n\nConstructing a flashbots bundle for arbitrage\n\n\nNext, I needed to construct my flashbots bundle to send to the relay. Since the detected mempool transaction could be a type 0 or type 2 transaction, I must have scenarios for both. For more on using mempool transactions in your bundles, you can refer to our prior post on using \nBlocknative with Flashbots\n.\n\n\nif\n (transaction.\ntype\n == \n2\n) {\n            params = [\n              \n'0x01'\n,\n              transaction.\nnonce\n === \n0\n ? \n'0x'\n : ethers.\nutils\n.\nhexlify\n(transaction.\nnonce\n),\n              ethers.\nutils\n.\nparseEther\n(ethers.\nutils\n.\nformatEther\n(transaction.\nmaxPriorityFeePerGas\n)).\n_hex\n,\n              ethers.\nutils\n.\nparseEther\n(ethers.\nutils\n.\nformatEther\n(transaction.\nmaxFeePerGas\n)).\n_hex\n,\n              ethers.\nutils\n.\nhexlify\n(transaction.\ngas\n),\n              transaction.\nto\n,\n              transaction.\nvalue\n === \n'0'\n ? \n'0x'\n : ethers.\nutils\n.\nhexlify\n(transaction.\nvalue\n),\n              transaction.\ninput\n,\n              [],\n              transaction.\nv\n === \n'0x0'\n ? \n'0x'\n : transaction.\nv\n,\n              transaction.\nr\n,\n              transaction.\ns\n\n            ]\n            s1 = \n'0x02'\n+\nencode\n(params).\ntoString\n(\n'hex'\n);\n          } \nelse\n {\n            params = [\n              transaction.\nnonce\n === \n0\n ? \n'0x'\n : ethers.\nutils\n.\nhexlify\n(transaction.\nnonce\n),\n              ethers.\nutils\n.\nparseEther\n(ethers.\nutils\n.\nformatEther\n(transaction.\ngasPrice\n)).\n_hex\n,\n              ethers.\nutils\n.\nhexlify\n(transaction.\ngas\n),\n              transaction.\nto\n,\n              transaction.\nvalue\n === \n'0'\n ? \n'0x'\n : ethers.\nutils\n.\nhexlify\n(transaction.\nvalue\n),\n              transaction.\ninput\n,\n              transaction.\nv\n,\n              transaction.\nr\n,\n              transaction.\ns\n\n            ];\n            s1 = \n'0x'\n+\nencode\n(params).\ntoString\n(\n'hex'\n);\n          }\n\n\nI used my modified smart contract to construct my transaction, which would include either two internal transactions or two swaps between the two DEXs.\n\n\nconst\n s2 = \nawait\n arbContract.\npopulateTransaction\n.\nflashArbitrage\n(\n            pairAddress,\n            otherPairAddress,\n            pairAddress,\n            tokenAddress0,\n            ethers.\nutils\n.\nparseEther\n(\n'0'\n).\n_hex\n,\n            ethers.\nutils\n.\nparseEther\n(\n'0'\n).\n_hex\n\n          )\n          s2.\ngasPrice\n = ethers.\nutils\n.\nhexlify\n(gasFee)\n          s2.\ngasLimit\n = ethers.\nutils\n.\nhexlify\n(\n500000\n)\n          s2.\nnonce\n = \nawait\n wallet.\ngetTransactionCount\n();\n\n\nWith the transaction constructed, I then created the flashbots bundle and simulated it to ensure the transaction wouldn\u2019t fail for any reason. I also created a final net-profit calculation to ensure I was still actualizing a profit. If my transaction passed the simulation, and I was still making a profit, then I submitted it to the flashbots relay for inclusion.\n\n\nconst\n signedTransactions = \nawait\n flashbotsProvider.\nsignBundle\n([\n            {\n              \nsignedTransaction\n: s1\n            },\n            {\n              \nsigner\n: wallet,\n              \ntransaction\n: s2\n            }\n          ])\n\n          \nconst\n blockNumber = transaction.\npendingBlockNumber\n+\n1\n;\n\n          \nconst\n simulation = \nawait\n flashbotsProvider.\nsimulate\n(signedTransactions, blockNumber);\n          \nif\n (\n'error'\n \nin\n simulation) {\n            \nconsole\n.\nlog\n(\n`Simulation Error: \n${simulation.error.message}\n`\n)\n\n          } \nelse\n {\n            \nif\n (simulation.\nfirstRevert\n!==\nundefined\n) {\n              \nconsole\n.\nlog\n(simulation.\nfirstRevert\n.\nrevert\n)\n            } \nelse\n {\n              \nconst\n net2 = ethers.\nutils\n.\nparseEther\n(gross) - simulation.\nresults\n[\n1\n].\ngasUsed\n*gasFee\n              \nconsole\n.\nlog\n(\n`Net: \n${ethers.utils.formatEther(net2)}\n | Pair address: \n${pairAddress}\n | TxHash: \n${transaction.hash}\n`\n)\n              \nconsole\n.\nlog\n(simulation)\n              \nif\n (net2>\n0\n) {\n                \nconsole\n.\nlog\n(\n`Coinbase diff: \n${simulation.coinbaseDiff}\n`\n)\n                \nconst\n submittedBundle = \nawait\n flashbotsProvider.\nsendRawBundle\n(signedTransactions, blockNumber);\n                \nconst\n bundleResponse = \nawait\n submittedBundle.\nwait\n();\n                \nconsole\n.\nlog\n(bundleResponse)\n              }\n            }\n          }\n\n\n\u00a0\n\n\nLessons learned from creating a basic arbitrage bot\n\n\nI ran my script for several days and it worked exactly as intended\u2014it detected profitable opportunities using \nBlocknative\u2019s mempool API\n and submitted them to flashbots to compete for inclusion by a miner. However, the opportunities this script competed for were VERY competitive and I wasn\u2019t able to outcompete the other bots. \n\n\nThe biggest reason for this was that most of the other bot\u2019s smart contracts were far more gas efficient than mine, allowing them to pay more to the miner to get included. Additionally, using flashswaps is pretty inefficient compared to just doing the swaps with tokens you already own. There are a whole host of other gas optimizations out there, but that is a very competitive, tough game to play against people far better at solidity (and Yul!) than I am. \n\n\nOther areas that I didn\u2019t optimize include:\n\n\n\n\nChoosing the correct tip to send to the miner. \n\n\nOnly looking at two DEXs.\n\n\nOnly looking at arbitrage between two tokens. A path-finding algorithm across many pairs could result in better profit potential.\n\n\nTrying this out on other EVM compatible chains like \nPolygon\n.\n\n\nCross-chain MEV\n.\n\n\n\n\nTrade with an edge using Blocknative\u2019s Simulation Platform\n\n\nFinding the best arbitrage opportunities is impossible without the best mempool data feeds. Blocknative\u2019s \nSimulation Platform\n leverages our \nGlobal Mempool Data Platform\n to provide probabilistic outcomes of every public pending Ethereum transaction, including detailed traces of each smart contract function call and net balance changes. \n\n\nMEV searchers can go hands-on today and monitor simulated transactions directly on \nMempool Explorer\n. Our powerful UI enables users to filter on everything in the payload to ensure you get a fine-tuned view of the mempool that fits your exact needs. These saved configurations can easily be integrated into any project using websockets or webhooks.\n\n"
    }
}