{
    "threat_intelligence": {
        "url": "https://arxiv.org/html/2403.01290v1",
        "timestamp": "2023-09-01 00:00:00",
        "original_content": "\n\nABSTRACT.\nReport issue for preceding element\n\n\nUpgradeable smart contracts (USCs) have been widely adopted to enable modifying deployed smart contracts.\nWhile USCs bring great flexibility to developers, improper usage might introduce new security issues, potentially allowing attackers to hijack USCs and their users.\nIn this paper, we conduct a large-scale measurement study to characterize USCs and their security implications in the wild.\nWe summarize six commonly used USC patterns and develop a tool, USCDetector, to identify USCs without needing source code.\nParticularly, USCDetector collects various information such as bytecode and transaction information to construct upgrade chains for USCs and disclose potentially vulnerable ones.\nWe evaluate USCDetector using verified smart contracts (i.e., with source code) as ground truth and show that USCDetector can achieve high accuracy with a precision of 96.26%. We then use USCDetector to conduct a large-scale study on Ethereum, covering a total of 60,251,064 smart contracts.\nUSCDetecor constructs 10,218 upgrade chains and discloses multiple real-world USCs with potential security issues.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n1. \nINTRODUCTION\nReport issue for preceding element\n\n\n\n\nSmart contracts are critical building blocks for decentralized applications (DApps) such as decentralized finance (DeFi)\u00a0\n(Qin et\u00a0al\n.\n, \n2022\n)\n and NFT\u00a0\n(Das et\u00a0al\n.\n, \n2022\n)\n. As of Sep 2023, more than \n61\n61\n61\n61\n million smart contracts have been deployed on Ethereum\u00a0\n(Cloud, \n2023\n)\n, the largest blockchain supporting smart contracts. To enforce transparency and trust decentralization, Ethereum and many other contract-supporting blockchains adopt the immutable smart contract design. That is, a smart contract, once deployed, cannot be changed or upgraded by any centralized entities. However, immutability conflicts with various legitimate causes to upgrade a deployed smart contract, such as introducing new functional features or patching security vulnerabilities, leading to inconvenience in practice.\nThus, since 2016, various design patterns for upgradable smart contracts (USCs) have been introduced on Ethereum\u00a0\n(Barros, \n2019\n; Mudge, \n2018\n, \n2020b\n, \n2020a\n)\n, and widely adopted by DApps\u00a0\n(Uniswap, \n2023\n; OpenSea, \n2023\n)\n.\nAlso, many third-party libraries, such as OpenZeppelin\u00a0\n(OpenZeppelin, \n2023a\n)\n, have been developed to ease and accelerate USC development and deployment.\nReport issue for preceding element\n\n\n\n\n\n\nDespite all these efforts, developing USCs is still challenging and requires developers to be trained with security awareness\u00a0\n(Josselinfeist, \n2018\n)\n.\nOtherwise, security vulnerabilities might exist in USCs, allowing attackers to hijack USCs and further affect their users.\nUnfortunately, such vulnerabilities are not rare among USCs.\nFor example, a widely adopted OpenZeppelin USC template is vulnerable to permanent state impairment that can potentially cause huge financial loss (e.g., over $50m)\u00a0\n(Iosiro, \n2021\n)\n.\nAttackers have even successfully destroyed a USC and obtained all its ETH\u00a0\n(uup, \n2022\n)\n.\nWith more contracts integrating upgrade features, it becomes more likely that attackers target these upgradeable contracts in the future\u00a0\n(YAcademy, \n2022\n)\n.\nReport issue for preceding element\n\n\n\n\n\n\nIn this paper, we conduct a large-scale measurement study to characterize USCs and their security implications in the wild.\nWe first introduce six commonly used USC patterns and their implementations.\nSpecifically, our works cover the straightforward method (e.g., to deploy a new contract and migrate states), the Ethereum built-in method (i.e., Metamorphic contract), and four methods that decouple a contract into two sub-contracts (e.g., one immutable contract and one contract that can be modified).\nIn addition, we present a series of security risks that could potentially cause serious consequences.\nSome vulnerabilities might enable off-path attackers to completely destroy target USCs (e.g., deny their service) and even hijack existing contracts.\nOther issues might put smart contract users into dangerous situations, such as losing assets or trading deprecated tokens.\nTo the best of our knowledge, we are the first to systematically investigate several USC security issues on a large scale.\nReport issue for preceding element\n\n\n\n\n\n\nWe develop a tool, USCDetector, to identify USCs and their security issues.\nUnlike previous work relying on source code analysis\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n and can only detect limited USC types (e.g., proxy-based\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n), USCDetector collects various information such as bytecode and transaction information, which are available for all contracts, to detect six types of USCs, construct their upgrade chains, and disclose potentially vulnerable ones.\nThus, USCDetector can cover both unverified (i.e., without source code) and verified smart contracts.\nWe evaluate USCDetector using a subset of verified smart contracts, and show that it can achieve high accuracy with an overall 96.26% precision.\nReport issue for preceding element\n\n\n\n\n\n\nWe adopt USCDetector on Ethereum, covering a total of 60,251,064 smart contracts.\nUSCDetecor constructs 10,218 upgrade chains with 91,959 USCs identified.\nOur results show some interesting observations: while the proxy-based approach is the most popular one, many developers attempt to mix different approaches to implementing USCs,\nwhich can offer more flexibility and facilitate batch processing.\nMoreover, USCDetector successfully discloses multiple real-world USCs with potential security issues.\nFor example, we have identified 15 USCs lacking restrictive checks on the upgradable functions, potentially enabling anyone to hijack them.\nAdditionally, we have discovered 118 vulnerable contracts that may completely disable USCs (e.g., become unusable forever).\nWe have also identified tokens of many deprecated contracts are still listed in various decentralized exchanges, affecting many unaware users.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n5. \nMETHODOLOGY\nReport issue for preceding element\n\n\n\n\nWe design an analysis tool, USCDetector, to characterize USCs and investigate their potential vulnerabilities in the existing Ethereum blockchain.\nUnlike previous work\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n that only detect proxy-based USCs based on source code analysis, USCDetector identifies multiple types of USCs based on bytecode, which are always publicly accessible, and thus enable us to characterize both verified and unverified USCs in the wild.\nThe high-level idea is that developers attempt to use common keywords (e.g., upgrade, update) in their upgrading functions\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n, which are available in bytecode.\nWith the help of other collectable information (e.g., transactions), we can identify USCs with high accuracy.\nReport issue for preceding element\n\n\n\n\n\n\nThe overall workflow is illustrated in Figure\u00a0\n2\n.\nUSCDetector first disassembles smart contract bytecode into opcodes and extracts function selectors.\nThen it filters a list of USC candidates based on a set of pre-defined common upgrade function keywords.\nAdditionally, USCDetector collects various supplementary information such as logic contract addresses and transaction information.\nFinally, based on all collected information, a rule-based pattern detector identifies USCs and their upgrading patterns.\nReport issue for preceding element\n\n\n\n\n\n\nFigure 2\n. \nOverview of USCDetector.\n\n\nReport issue for preceding element\n\n\n\n\n\n\n5.1. \nBytecode Collector\nReport issue for preceding element\n\n\n\n\nThe bytecode collector first uses an Ethereum RPC (Remote Procedure Call) service\u00a0\n(ChainList, \n2023\n)\n to collect smart contract bytecode.\nThen we disassemble bytecode into opcodes using an npm package \ntruffle-code-utils\n\u00a0\n(Truffle, \n2018\n)\n, and further utilize \nabi-decode-functions\n\u00a0\n(Abi-decoder, \n2018\n)\n to extract functions selectors.\nParticularly, a smart contract\u2019s bytecode first compares the function selector in the transaction\u2019s input to all function selectors in the smart contract, and then jumps to the matching function for execution.\n\nabi-decode-functions\n extracts function selectors based on such patterns (i.e., match and jump) using pre-defined templates.\nHowever, we find that it only covers a subset of templates so some function selectors might be missed.\nWe thus extend it to include more common patterns.\nReport issue for preceding element\n\n\n\n\n\n\nThe above method can extract most function selectors from the immutable contract of USCs (e.g., proxy contract in the proxy pattern, main contract in the strategy pattern, and data contract in the data separation).\nHowever, it cannot extract function selectors of the logic contract in the \nstrategy pattern\n.\nParticularly, the main contract can use the \nPUSH4\n opcode to push a 4-byte function selector onto the stack, and then use the opcode \nCALL\n to call that function whose logic is implemented in the logic contract.\nIn other words, the function selector included in the main contract actually represents a function in the logic contract.\nWe also extend the \nabi-decode-functions\n tool to handle such cases.\nReport issue for preceding element\n\n\n\n\n\n\nFinally, the bytecode collector also extracts various opcodes (e.g., \nSELFDESTRUCT\n) and other function related information (e.g., fallback function) for pattern detection (Section\u00a0\n5.4\n).\nTable\u00a0\n4\n in Appendix\u00a0\nA\n lists the detailed description.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n5.2. \nCommon Upgrade Function Keywords.\nReport issue for preceding element\n\n\n\n\nOur idea is to construct and apply a set of keywords that are commonly used in upgrade functions to filter function selectors. Obviously, the quality of such a dataset is critical for USC detection accuracy.\nWe first analyze the Ethereum mainnet dataset\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n, which contains 2,295 unique (3,822 in total) proxy-based USCs.\nFrom a total of 9,842 upgrade functions, we extract 111 unique upgrade functions, and find most of them can be divided into groups containing five keywords: \nset\n (570), \nupgrade\n (8,548), \nupdate\n (229), \nchange\n (88), and \nreplace\n (22).\nWe then query these keywords on the \nEthereum Signature Database\n\u00a0\n(Database, \n2023\n)\n, which contains 4-byte signatures of functions in EVM.\nThe Ethereum signature database returns all functions including selected keywords and their corresponding 4-byte signatures.\nHowever, functions containing keywords cannot ensure they are upgrade functions.\nFor example, \nsetUserData(address,uint256,uint256)\n is clearly not used for upgrading.\nThus, we only keep the functions containing meaningful and related words, such as \ncontract\n, \nimplementation\n, and \nlogic\n, etc.\nWe also include some function names that we manually\ncollect online, such as \nenableModule\n from \nGnosis Safe Contracts\n\u00a0\n(Foundation, \n2023\n)\n.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n5.3. \nSupplementary Data Collector.\nReport issue for preceding element\n\n\n\n\nWe further collect various information in addition to bytecode to assist USC detection.\nReport issue for preceding element\n\n\n\n\n\n\nLogic Contract Collector.\n\nIn proxy-based USCs, particularly UUPS, the upgrade function exists in the logic contract, instead of the proxy contract.\nWe then utilize an RPC (\nevm-proxy-detection\n) to collect the logic contract\u2019s address of smart contracts that contain \nDELEGATECALL\n opcode (e.g., potential proxy-based USCs).\nSuch addresses are further fed to the \nBytecode Collector\n to process their bytecode.\nReport issue for preceding element\n\n\n\n\n\n\nCall Trace Collector.\n\nMetamorphic-based USCs need to destroy the old contract (i.e., using the \nSELFDESTRUCT\n opcode) and then redeploy new bytecode using the \nCREATE2\n opcode to that address.\nThus, to identify metamorphic-based USCs, we need to collect the call traces of the transaction that creates a new contract, and then detect if the contract is indeed created by \nCREATE2\n in that call traces.\nParticularly, we first request Etherscan API\u00a0\n(Etherscan, \n2023a\n)\n to obtain the creators and transaction hashes of smart contracts that contain \nSELFDESTRUCT\n.\nThen we use transaction hashes to request Openchain API\u00a0\n(Openchain, \n2023\n)\n to obtain call traces.\nFinally, we parse the opcodes and input them into the detector.\nReport issue for preceding element\n\n\n\n\n\n\nEtherscan Crawler.\n\nWe also crawl various information from Etherscan websites for all contracts that are labeled as \u201cOld Contract\u201d.\nAs mentioned in Section\u00a0\n3.1\n, the \u201cOld Contract\u201d is labeled by Etherscan when the deployer provides the addresses of both the old and new contracts and a link to an official announcement regarding the contract migration\u00a0\n(Center, \n2023\n)\n.\nThe crawler then collects all related information.\nReport issue for preceding element\n\n\n\n\n\n\nTransaction Analyzer.\n\nWe further collect all transactions whose \ninput\n contains upgrade functions (which are potential USCs\u2019 upgrade transactions).\nSpecifically, we collect them by querying Bigquery\u00a0\n(Cloud, \n2018\n)\n that uses \nethereum-etl\n\u00a0\n(ETL, \n2023\n)\n to extract data from the Ethereum blockchain every day.\nThen we use \nethereum-input-data-decoder\n\u00a0\n(input-data decoder, \n2022\n)\n to decode the transactions\u2019 \ninput\n and extract function selectors and arguments.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n5.4. \nRule-based Pattern Detector\nReport issue for preceding element\n\n\n\n\nBased on the characteristics of different USC patterns, we develop a rule-based pattern detector to identify them.\nThe detailed rules and notations are listed in Table\u00a0\n5\n in Appendix\u00a0\n5\n.\nSpecifically, the \nproxy pattern\n must have (1) both \nDELEGATECALL\n and the \nfallback\n function exist in the proxy contract; and (2) an upgrade function in either the proxy or logic contract (i.e., UUPS).\nWe first use three criteria for detecting \nstrategy pattern\n and \ndata separation\n: (1) the existence of upgrade functions; (2) \nCALL\n or \nSTATICCALL\n used; and (3) particular external functions.\nWe further distinguish these two patterns using transaction information: strategy-based USCs call logic contracts, while data separation USCs are called by logic contracts.\nFor \nMetamorphic\n contracts, we check whether \nSELFDESTRUCT\n exists and \nCREATE2\n is in the call trace.\nIf contracts meet the rules for both proxy-based and strategy-based, we mark them as mix patterns.\nFinally, it is difficult to identify the \ncontract migration\n pattern at the bytecode level. Therefore, we select all contracts labeled with the \u201cOld Contract\u201d label on Etherscan and remove contracts that are identified as other patterns (e.g., data separation).\nReport issue for preceding element\n\n\n\n\n\n\nTable 1\n. \nUSCDetector Precision on Randomly Sampled Data.\n\n\n\n\n\n\nPatterns\n\n\nTP\n\n\nFP\n\n\nPrecision\n\n\n\n\n\n\nProxy Pattern\n\n\n244\n\n\n6\n\n\n97.60%\n\n\n\n\n\n\nData Separation\n\n\n43\n\n\n2\n\n\n95.55%\n\n\n\n\n\n\nStrategy Pattern\n\n\n70\n\n\n2\n\n\n97.22%\n\n\n\n\n\n\nThe Rest of Data or Strategy\n\n\n308\n\n\n15\n\n\n95.35%\n\n\n\n\n\n\nMix Pattern\n\n\n50\n\n\n3\n\n\n94.33%\n\n\n\n\n\n\nMetamorphic Contract\n\n\n7\n\n\n0\n\n\n100%\n\n\n\n\n\n\nTotal\n\n\n722\n\n\n28\n\n\n96.26%\n\n\n\n\n\n\nReport issue for preceding element\n\n\n\n\n\n\n\n\n5.5. \nUpgrade Chain Constructor\nReport issue for preceding element\n\n\n\n\nFinally, we construct contract upgrade chains for USCs that have already performed upgrades.\nThe upgrade chain for \ncontract migration\n is straightforward: we simply concatenate contracts based on Etherscan labels.\nFor other patterns, to perform an upgrade, an EOA must initiate a transaction to the contract that needs an upgrade. We thus rely on collected transaction information to build the chain.\nFor example, upgrading metamorphic contracts is to redeploy new bytecode on the same address. We then chain detected metamorphic contracts with the same address.\nWith the upgrade chain, we further check multiple security issues (details in Section\u00a0\n7\n).\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n5.6. \nUSCDetector Evaluation\nReport issue for preceding element\n\n\n\n\nThe Smart Contract Sanctuary project\u00a0\n(Ortner and Eskandari, \n2023\n)\n is a project including verified Ethereum smart contracts on Etherscan.\nAs of March 22, 2023, this dataset contains 320,080 verified smart contracts, with source code available.\nWe input this list into USCDetector and have identified 8,653 USCs, with 2,517 proxy-based USCs, 7 Metamorphic contracts, and 568 mix pattern USCs.\nIn addition, there are 5,746 USCs using \ndata separation\n or \nstrategy pattern\n.\nAmong them, we further utilize transaction information to separate them.\nSince not all USCs have performed upgrades (i.e., have upgrade transactions), we detect 468 \ndata separation\n and 988 \nstrategy pattern\n USCs.\nReport issue for preceding element\n\n\n\n\n\n\nTo evaluate the accuracy, we randomly select and manually verify 750 smart contracts including all patterns based on their source code and decompiled code.\nThe result of random sampling is listed in Table\u00a0\n1\n.\nOverall, we are able to achieve 96.26% precision, with only a few false positives.\nWe then randomly select 100 smart contracts from those identified as non-USCs by USCDetector. By examining those contracts, we identified one false negative, which is caused by the exclusion of the upgrading function in our \nCommon Upgrade Function\n dataset.\nAppendix\u00a0\nA\n further presents an evaluation of false negatives using the dataset from Proxy Hunting\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n.\nIt is worth noting that our list of upgrade functions is not obtained from this dataset, indicating that our methodology has the potential to accurately detect unknown USCs without their source code.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n\n\n6. \nMEASUREMENT IN THE WILD\nReport issue for preceding element\n\n\n\n\nWe utilize USCDetector to detect smart contracts collected from Bigquery\u00a0\n(Cloud, \n2023\n)\n, which has exported 60,251,064 smart contracts (date: 6/5/2023) from the Ethereum blockchain.\nWe first group smart contracts based on their bytecode, so that smart contracts in each group have identical bytecode.\nWe take the smart contract with the earliest creation time from each group as the representative for further analysis.\nReport issue for preceding element\n\n\n\n\n\n\nIn the total of 964,585 groups, we have identified 27,420 groups, with\n1,938,727\nindividual USCs (column\u201cRaw\u201d in Table\u00a0\n2\n).\nWe find that proxy-based pattern dominates existing upgradable methods, with 1,866,904 USCs from 4,964 groups.\nHowever, most of them are dominated by one group, namely \nOwnableDelegateProxy\n\u00a0\n(OwnableDelegateProxy, \n2018\n)\n, which includes 1,546,462 USCs.\nThis group was created by the smart contract \nWyvernProxyRegistry\n\u00a0\n(OpenSea, \n2018\n)\n, which is maintained by OpenSea\u00a0\n(OpenSea, \n2023\n)\n, a popular NFT market.\n\nWyvernProxyRegistry\n creates a proxy contract for each seller on OpenSea (i.e., the seller owns the contract) for executing sellers\u2019 actions.\nObviously, this group of proxies is not for business logic upgrading. In addition to this specific group, there are several other groups adopting a similar approach. In these groups, USCs are created by another smart contract (i.e., a contract factory), instead of an EOA account. The main purpose of a contract factory is to allow DApps (or DeFi) users to generate smart contracts (e.g., create their own tokens \u00a0\n(Academy, \n2023\n)\n).\nIn the following analysis (e.g., the numbers presented in Column \u201cNumber\u201d in Table\u00a0\n2\n), we exclude the smart contracts created by a factory smart contract as a practice of deduplication.\nReport issue for preceding element\n\n\n\n\n\n\nFigure 3\n. \nPatterns Over Time.\n\n\n\n\n\n\nTable 2\n. \nUSC Breakdown.\n\n\n\n\n\n\n\n\n\n\nPatterns\n\n\nRaw\n\n\nNumber\u00a0\n\n\nETH\n\n\nTrans.\n\n\n\n\nProxy Pattern\n\n\n1,866,904\n\n\n43,650\n\n\n736K\n\n\n51M\n\n\n\n\nData Separation\n\n\n1,024\n\n\n1,024\n\n\n131\n\n\n1M\n\n\n\n\nStrategy Pattern\n\n\n2,444\n\n\n2,444\n\n\n280K\n\n\n7.7M\n\n\n\n\nThe Rest of Data or Strategy\n\n\n40,549\n\n\n39,340\n\n\n7K\n\n\n11.3M\n\n\n\n\nMix Pattern\n\n\n23,725\n\n\n1,420\n\n\n2.8K\n\n\n5.7M\n\n\n\n\nMetamorphic Contract\n\n\n3,097\n\n\n3,097\n\n\n68.5\n\n\n3.3M\n\n\n\n\nContract Migration\n\n\n984\n\n\n984\n\n\n410\n\n\n16M\n\n\n\n\nTotal\n\n\n1,938,727\n\n\n91,959\n\n\n1.025M\n\n\n96M\n\n\n\n\n\n\n\n\nFigure 3\n. \nPatterns Over Time.\n\n\nFigure 4\n. \nUpgrade Chain CDF.\n\n\nReport issue for preceding element\n\n\n\n\nBasic Characterization.\n\nTable\u00a0\n2\n shows the detailed breakdown of each pattern.\nWe also present the aggregated ETH and transaction volumes.\nThe most popular is the proxy pattern, with 43,650 contracts containing more than 736k ETH and 51M transactions.\nOne possible reason is the wide adoption of third-party templates (e.g., Openzeppelin\u00a0\n(OpenZeppelin, \n2023a\n)\n), which provide open source contract libraries for developing smart contracts.\nFigure\u00a0\n4\n presents the number of different patterns of USCs over time. The blue line indicates that data separation and strategy pattern were the main upgrade methods until the proxy method (green) was introduced.\nThe Metamorphic contract comes after February 2019, and is not popular due to its drawback mentioned in Section\u00a0\n3\n.\nReport issue for preceding element\n\n\n\n\n\n\nUpgrade Chains.\n\nIn total, we have constructed 4,692 upgrade chains for proxy-based USCs, 4,337 for strategy-based or data separation patterns, 201 for mix pattern, 110 for metamorphic-based USCs, and 878 for contract migration.\nFigure\u00a0\n4\n shows the CDF of upgrade chains.\nMost of them have conducted less than 20 upgrades, while the longest chain contains 92 upgrades.\nAlso, 89.1% of the contract migration approach have only 1 upgrade, which is reasonable as contract migration essentially is to deploy a new contract.\nReport issue for preceding element\n\n\n\n\n\n\nWe also find that many upgrades are conducted by different owners (i.e., owner change): there are 185 proxy-based, 97 strategy/data separation, and 52 mix-pattern USCs.\nReport issue for preceding element\n\n\n\n\n\n\nMix Pattern Demystified.\n\nWe detect 23,725 (Raw) mix-based USCs, which combine features of both strategy and proxy patterns.\nWe find that there are different ways to implement the mix pattern.\nOne popular way (20,591) utilizes an upgradeable intermediate contract.\nThe main (proxy) contract can \nCALL\n the intermediate contract to get the return address for the logic contract.\nThen, the main contract can delegate calls to the logic contract using the returned address.\nIn this way, the main contract does not preserve the actual address of the logic contract.\nWhen performing an upgrade, developers simply modify the logic contract\u2019s address in the intermediate contract.\nIt does not require any operations on the main contract for upgrading.\nThus, it enables uniform upgrades across multiple USCs that share a logic contract.\nReport issue for preceding element\n\n\n\n\n\n\nAnother popular approach (704) is similar: the main contract preservers the logic contract\u2019s address, and also contains the upgrade function.\nWhen upgrade, the main contract first \nCALL\n the logic contract to see if a new logic address is returned. If yes, the main contract updates the new logic address, and then delegate the call to the new one.\nReport issue for preceding element\n\n\n\n\n\n\nHierarchy Upgrade.\n Interestingly, we find some developers utilize strategy-based USCs to further upgrade multiple proxy-based USCs.\nFor example, a proxy-based USC already contains an upgrade function (in the proxy contract) that can upgrade its logic contracts.\nThen, the developers utilize a strategy-based main contract to directly \nCALL\n the upgrade function in the proxy contract to upgrade its logic contract.\nThe advantage is that, developers can utilize one main contract to manage multiple proxy contracts.\nUSCDetector finds 1,349 such strategy-based USCs, and 2,628 proxy-based USCs were upgraded in this way.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n8. \nRELATED WORKS\nReport issue for preceding element\n\n\n\n\nSmart Contract Upgrades.\n\nUSCs have attracted many research efforts\u00a0\n(Meisami and Bodell\u00a0III, \n2023\n; Antonino et\u00a0al\n.\n, \n2022\n; Rodler et\u00a0al\n.\n, \n2021\n)\n on understanding their characteristics.\nFor example, \nAntonino et al.\n proposed a framework\u00a0\n(Antonino et\u00a0al\n.\n, \n2022\n)\n to introduce a trusted deployer to vet smart contracts\u2019 creation and upgrade.\n\nRodler et al.\n designed EVMPatch\u00a0\n(Rodler et\u00a0al\n.\n, \n2021\n)\n to rewrite the bytecode of exploited smart contracts and deploy them as upgradeable proxy contracts.\nOur work focuses on characterizing existing mainstream smart contract upgrading patterns and their security implications.\nReport issue for preceding element\n\n\n\n\n\n\nOne closely related work is Proxy Hunting\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n, which focuses on security issues of proxy-based USCs from contracts\u2019 source code.\nInstead, our work covers more USCs patterns (e.g., data separation and strategy pattern) on unverified smart contracts (i.e., without source code). We also investigate several security issues that have not been studied by previous literature.\nFinally, there are two works on detecting metamorphic contracts using opcode \nCREATE2\n\u00a0\n(Blau, \n2022\n; Fr\u00f6wis and B\u00f6hme, \n2022\n)\n.\nOur work further utilizes transaction call traces to check whether \nCREATE2\n is used to create smart contracts.\nReport issue for preceding element\n\n\n\n\n\n\nSmart Contract Security Analysis.\n\nExtensive research efforts have been conducted on analyzing various security issues (e.g., reentrancy vulnerabilities) of smart contracts\u00a0\n(ConsenSys, \n2023\n; Nikoli\u0107 et\u00a0al\n.\n, \n2018\n; So et\u00a0al\n.\n, \n2020\n; Xue et\u00a0al\n.\n, \n2022\n; Bose et\u00a0al\n.\n, \n2022\n; Rodler et\u00a0al\n.\n, \n2019\n; Permenev et\u00a0al\n.\n, \n2020\n)\n at both the source code level\u00a0\n(Stephens et\u00a0al\n.\n, \n2021\n; Wang et\u00a0al\n.\n, \n2019\n; Duan et\u00a0al\n.\n, \n2022\n; Chen, \n2020\n; Xue et\u00a0al\n.\n, \n2020\n; Torres et\u00a0al\n.\n, \n2021\n; Jiang et\u00a0al\n.\n, \n2018\n; Torres et\u00a0al\n.\n, \n2018\n; Tikhomirov et\u00a0al\n.\n, \n2018\n; Frank et\u00a0al\n.\n, \n2020\n; Grech et\u00a0al\n.\n, \n2018\n; Grossman et\u00a0al\n.\n, \n2017\n; Liu et\u00a0al\n.\n, \n2018\n; Nguyen et\u00a0al\n.\n, \n2020\n)\n and bytecode level\u00a0\n(Luu et\u00a0al\n.\n, \n2016\n; Rodler et\u00a0al\n.\n, \n2021\n; Chen et\u00a0al\n.\n, \n2021b\n; Shi et\u00a0al\n.\n, \n2022\n; Chen et\u00a0al\n.\n, \n2021a\n; Choi et\u00a0al\n.\n, \n2021\n; Ferreira\u00a0Torres et\u00a0al\n.\n, \n2022\n; Zhang et\u00a0al\n.\n, \n2020\n; Krupp and Rossow, \n2018\n)\n.\nFor example, \nWang et al.\n developed NPChecker\u00a0\n(Wang et\u00a0al\n.\n, \n2019\n)\n to detect nondeterministic vulnerabilities in smart contracts.\nDefectChecker\u00a0\n(Chen et\u00a0al\n.\n, \n2021b\n)\n is introduced to detect smart contracts\u2019 defects from bytecode.\nDifferent from previous efforts, our work focuses on uncovering existing USCs that have security issues at the bytecode level.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\nAppendix A \nAPPENDIX\nReport issue for preceding element\n\n\n\n\nTable 4\n. \nOpcodes and Function Information Extracted From Bytecode.\n\n\n\n\n\n\nInfor.\n\n\nAbbr.\n\n\nDesc.\n\n\n\n\n\n\nCALL\n\n\nCALL\n\n\nCall a method in another contract.\n\n\n\n\n\n\nDELEGATECALL\n\n\nDCALL\n\n\nCall a method in another contract\n\n\n\n\n\n\nusing the storage of current contract.\n\n\n\n\n\n\n\n\n\n\nCall a method in another contract\n\n\n\n\n\n\nSTATICCALL\n\n\nSCALL\n\n\nwithout state changes.\n\n\n\n\n\n\nSELFDESTRUCT\n\n\nSDES\n\n\nDestroy the contract.\n\n\n\n\n\n\n\n\n\n\nFallback function will be called when a non-\n\n\n\n\n\n\nFallback\n\n\nFBK\n\n\nexistent function is called on the current contract.\n\n\n\n\n\n\nFunctions\n\n\n{Func}\n\n\nA set of functions belong to current contract.\n\n\n\n\n\n\n\n\n\n\nA set of functions that current contract calls\n\n\n\n\n\n\nOther Functions\n\n\n{OFunc}\n\n\nanother contract.\n\n\n\n\n\n\nReport issue for preceding element\n\n\n\n\nTable 5\n. \nThe Rules Specified for Each Pattern. \n\n\n\n\n\n\nPattern\n\n\n\u00a0Rules\n\n\n\n\n\n\nProxy Pattern\n\n\n\n\n\u2005\n \nU\n\u2062\np\n\u2062\ng\n\u2208\n(\n{\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\np\n\u2062\nr\n\u2062\no\n\u2062\nx\n\u2062\ny\n\u2228\n{\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\nl\n\u2062\no\n\u2062\ng\n\u2062\ni\n\u2062\nc\n)\n\u2227\nD\n\u2062\nC\n\u2062\nA\n\u2062\nL\n\u2062\nL\n\u2227\nF\n\u2062\nB\n\u2062\nK\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpg\\in(\\{Func\\}_{proxy}\\lor\\{Func\\}_{logic})\\land DCALL\\land FBK\nitalic_U italic_p italic_g \u2208 ( { italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_p italic_r italic_o italic_x italic_y end_POSTSUBSCRIPT \u2228 { italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_l italic_o italic_g italic_i italic_c end_POSTSUBSCRIPT ) \u2227 italic_D italic_C italic_A italic_L italic_L \u2227 italic_F italic_B italic_K\n\n\n\n\n\n\n\n\nStrategy Pattern\n\n\n\n\n\u2005\n \nU\n\u2062\np\n\u2062\ng\n\u2208\n{\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\nm\n\u2062\na\n\u2062\ni\n\u2062\nn\n\u2227\n(\nC\n\u2062\nA\n\u2062\nL\n\u2062\nL\n\u2228\nS\n\u2062\nC\n\u2062\nA\n\u2062\nL\n\u2062\nL\n)\n\u2227\n{\nO\n\u2062\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\nm\n\u2062\na\n\u2062\ni\n\u2062\nn\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nUpg\\in\\{Func\\}_{main}\\land(CALL\\lor SCALL)\\land\\{OFunc\\}_{main}\nitalic_U italic_p italic_g \u2208 { italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_m italic_a italic_i italic_n end_POSTSUBSCRIPT \u2227 ( italic_C italic_A italic_L italic_L \u2228 italic_S italic_C italic_A italic_L italic_L ) \u2227 { italic_O italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_m italic_a italic_i italic_n end_POSTSUBSCRIPT\n\n\n\n\n\n\n\n\nData Separation\n\n\n\n\n\u2005\n \nU\n\u2062\np\n\u2062\ng\n\u2208\n{\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\nd\n\u2062\na\n\u2062\nt\n\u2062\na\n\u2228\nR\n\u2062\nu\n\u2062\nl\n\u2062\ne\ns\n\u2062\nt\n\u2062\nr\n\u2062\na\n\u2062\nt\n\u2062\ne\n\u2062\ng\n\u2062\ny\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nUpg\\in\\{Func\\}_{data}\\lor Rule_{strategy}\nitalic_U italic_p italic_g \u2208 { italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_d italic_a italic_t italic_a end_POSTSUBSCRIPT \u2228 italic_R italic_u italic_l italic_e start_POSTSUBSCRIPT italic_s italic_t italic_r italic_a italic_t italic_e italic_g italic_y end_POSTSUBSCRIPT\n\n\n\n\n\n\n\n\nMix Pattern\n\n\n\n\n\u2005\n \nR\n\u2062\nu\n\u2062\nl\n\u2062\ne\np\n\u2062\nr\n\u2062\no\n\u2062\nx\n\u2062\ny\n\u2227\nR\n\u2062\nu\n\u2062\nl\n\u2062\ne\ns\n\u2062\nt\n\u2062\nr\n\u2062\na\n\u2062\nt\n\u2062\ne\n\u2062\ng\n\u2062\ny\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nRule_{proxy}\\land Rule_{strategy}\nitalic_R italic_u italic_l italic_e start_POSTSUBSCRIPT italic_p italic_r italic_o italic_x italic_y end_POSTSUBSCRIPT \u2227 italic_R italic_u italic_l italic_e start_POSTSUBSCRIPT italic_s italic_t italic_r italic_a italic_t italic_e italic_g italic_y end_POSTSUBSCRIPT\n\n\n\n\n\n\n\n\nMetamorphic Contract\n\n\n\n\n\u2005\n \nS\n\u2062\nD\n\u2062\nE\n\u2062\nS\n\u2227\nC\n\u2062\nR\n\u2062\nE\n\u2062\nA\n\u2062\nT\n\u2062\nE\n\u2062\n2\n\u2208\nC\n\u2062\na\n\u2062\nl\n\u2062\nl\n\u2062\nT\n\u2062\nr\n\u2062\na\n\u2062\nc\n\u2062\ne\nt\n\u2062\nx\n\u2062\n_\n\u2062\nc\n\u2062\nr\n\u2062\ne\n\u2062\na\n\u2062\nt\n\u2062\ne\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n_\n\n\n\n\n\n\nSDES\\land CREATE2\\in CallTrace_{tx\\_create}\nitalic_S italic_D italic_E italic_S \u2227 italic_C italic_R italic_E italic_A italic_T italic_E 2 \u2208 italic_C italic_a italic_l italic_l italic_T italic_r italic_a italic_c italic_e start_POSTSUBSCRIPT italic_t italic_x _ italic_c italic_r italic_e italic_a italic_t italic_e end_POSTSUBSCRIPT\n\n\n\n\n\n\n\n\nContract Migration\n\n\n\n\n\u2005\n \nA\n\u2062\nd\n\u2062\nd\n\u2062\nr\no\n\u2062\nl\n\u2062\nd\n\u2227\nA\n\u2062\nn\n\u2062\nn\n\u2062\no\n\u2062\nu\n\u2062\nn\n\u2062\nc\n\u2062\ne\n\u2062\nm\n\u2062\ne\n\u2062\nn\n\u2062\nt\n\u2227\nA\n\u2062\nd\n\u2062\nd\n\u2062\nr\nn\n\u2062\ne\n\u2062\nw\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n\nAddr_{old}\\land Announcement\\land Addr_{new}\nitalic_A italic_d italic_d italic_r start_POSTSUBSCRIPT italic_o italic_l italic_d end_POSTSUBSCRIPT \u2227 italic_A italic_n italic_n italic_o italic_u italic_n italic_c italic_e italic_m italic_e italic_n italic_t \u2227 italic_A italic_d italic_d italic_r start_POSTSUBSCRIPT italic_n italic_e italic_w end_POSTSUBSCRIPT\n\n\n\n\n\n\n\n\nReport issue for preceding element\n\n\n\n\nI. USCDetector Details\nReport issue for preceding element\n\n\n\n\n\n\nNotations.\n\n\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\nU\n\u2062\np\n\u2062\ng\n\n\n\nUpg\nitalic_U italic_p italic_g\n\n\n\n\n: Upgrade Function.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n{\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\np\n\u2062\nr\n\u2062\no\n\u2062\nx\n\u2062\ny\nsubscript\n\n\n\n\n\n\n\n\n\n\\{Func\\}_{proxy}\n{ italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_p italic_r italic_o italic_x italic_y end_POSTSUBSCRIPT\n\n\n\n\n: A set of functions belong to proxy.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n{\nO\n\u2062\nF\n\u2062\nu\n\u2062\nn\n\u2062\nc\n}\nm\n\u2062\na\n\u2062\ni\n\u2062\nn\nsubscript\n\n\n\n\n\n\n\n\n\n\\{OFunc\\}_{main}\n{ italic_O italic_F italic_u italic_n italic_c } start_POSTSUBSCRIPT italic_m italic_a italic_i italic_n end_POSTSUBSCRIPT\n\n\n\n\n: A set of functions that the main contract calls the logic contract.\nReport issue for preceding element\n\n\n\n\n\n\n\n\nR\n\u2062\nu\n\u2062\nl\n\u2062\ne\ns\n\u2062\nt\n\u2062\nr\n\u2062\na\n\u2062\nt\n\u2062\ne\n\u2062\ng\n\u2062\ny\n\n\n\nsubscript\n\n\n\n\n\n\n\n\n\nRule_{strategy}\nitalic_R italic_u italic_l italic_e start_POSTSUBSCRIPT italic_s italic_t italic_r italic_a italic_t italic_e italic_g italic_y end_POSTSUBSCRIPT\n\n\n\n\n: The rule for detecting strategy pattern.\nReport issue for preceding element\n\n\n\n\n\n\n\n\nC\n\u2062\na\n\u2062\nl\n\u2062\nl\n\u2062\nT\n\u2062\nr\n\u2062\na\n\u2062\nc\n\u2062\ne\nt\n\u2062\nx\n\u2062\n_\n\u2062\nc\n\u2062\nr\n\u2062\ne\n\u2062\na\n\u2062\nt\n\u2062\ne\n\n\n\n\n\n\n\n\nsubscript\n\n\n\n_\n\n\n\n\n\n\nCallTrace_{tx\\_create}\nitalic_C italic_a italic_l italic_l italic_T italic_r italic_a italic_c italic_e start_POSTSUBSCRIPT italic_t italic_x _ italic_c italic_r italic_e italic_a italic_t italic_e end_POSTSUBSCRIPT\n\n\n\n\n: The call traces of the transaction that creates the contract.\nReport issue for preceding element\n\n\n\n\n\n\n\n\nA\n\u2062\nd\n\u2062\nd\n\u2062\nr\no\n\u2062\nl\n\u2062\nd\n\n\n\nsubscript\n\n\n\n\nAddr_{old}\nitalic_A italic_d italic_d italic_r start_POSTSUBSCRIPT italic_o italic_l italic_d end_POSTSUBSCRIPT\n\n\n\n\n: The address of the old contract.\nReport issue for preceding element\n\n\n\n\n\n\n\n\nA\n\u2062\nn\n\u2062\nn\n\u2062\no\n\u2062\nu\n\u2062\nn\n\u2062\nc\n\u2062\ne\n\u2062\nm\n\u2062\ne\n\u2062\nn\n\u2062\nt\n\n\n\n\n\n\n\n\n\n\n\n\nAnnouncement\nitalic_A italic_n italic_n italic_o italic_u italic_n italic_c italic_e italic_m italic_e italic_n italic_t\n\n\n\n\n: The upgrade announcement obtained from Etherscan.\nReport issue for preceding element\n\n\n\n\n\n\n\n\nReport issue for preceding element\n\n\n\n\nRules.\n\n\nReport issue for preceding element\n\n\n\n\n\n\nProxy Pattern Rule\n requires (1) \nDELEGATECALL\n, (2)\nfallback\n function, and (3) the upgrade function must exist either in the proxy or logic contract.\nReport issue for preceding element\n\n\n\n\n\n\nStrategy Pattern Rule \n requires three elements to exist in the main contract at the same time. These elements are the upgrade function, \nCALL\n or \nSTATICCALL\n (or both of them), and the functions that the main calls the logic contract.\nReport issue for preceding element\n\n\n\n\n\n\nData Separation Rule\n requires the upgrade function to exist in the data contract. If the data contract calls functions of other contracts, it then has the same features as the strategy pattern.\nReport issue for preceding element\n\n\n\n\n\n\nMix Pattern Rule \n requires that both the proxy\u2019s rule and strategy\u2019s rule must be satisfied.\nReport issue for preceding element\n\n\n\n\n\n\nMetamorphic Contract Rule\n requires \nSELFDESTRUCT\n to exist in the contract, while the call trace of the transaction that creates the contract must contain \nCREATE2\n.\nReport issue for preceding element\n\n\n\n\n\n\nContract Migration Rule\n requires the address of the old contract, and announcement, and the address of the new contract must exist in the records we obtain from Etherscan at the same time.\nReport issue for preceding element\n\n\n\n\n\n\nII. False Negative Evaluation Using Dataset from\u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\nReport issue for preceding element\n\n\n\n\n\n\nWe evaluate USCDetector using a subset of the dataset from Proxy Hunting \u00a0\n(Bodell\u00a0III et\u00a0al\n.\n, \n2023\n)\n, including 775 smart contracts.\nThe TP, FP, TN, and FN are 673, 1, 94, and 7, respectively.\nParticularly, for 2 out of 7 FNs, our dataset missed the upgrading functions. For the rest 5, the logic contract address is hardcoded in the source code of the proxy contract.\nOur approach cannot obtain it from the RPC and cause the FN.\nIn particular, there are two reasons to only use a subset of their dataset:\n(1) As mentioned in their paper, Proxy Hunting cannot detect USCs if the source code of the logic contract is not available, while our approach relying on bytecode can.\n(2) We find that inconsistency between source code and bytecode exists in some cases. Basically, the source code provided by the developer at an address does not exactly match the bytecode deployed at that address.\nThe reason could be that the developer attempts to provide all relevant source code to verify a smart contract, while the deployed contract is only part of it.\nFor example, the contract \nCoreLibrary\n\u00a0\n(CoreLibrary, \n2021\n)\n is the deployed contract and does not have any upgrading function.\nHowever, the source code provided by the developer at this address also includes the code for \nAdminUpgradeabilityProxy\n (which is a proxy-based USC) and its dependent contracts.\nWe thus excluded these contracts in our evaluation.\n\nReport issue for preceding element\n\n\n\n\n\n\nIII. Additional Listings of Vulnerable Examples\nReport issue for preceding element\n\n\n\n\n\n\nList\u00a0\n1\n presents a simplified version of a Mix Pattern contract that has no restrictive check on contract admin, derived from a real-world DApp LANDProxy\u00a0\n(Decentraland, \n2023\n)\n.\nThere is no admin check on the \nupgrade\n function, and thus anyone can overwrite the logic address (Line 3).\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n1\ncontract\n\u00a0\nProxy\n\u00a0\n{\n\n\n\n\n\n\n2\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nupgrade\n(\nIApplication\n\u00a0\nnewContract\n,\n\u00a0\nbytes\n\u00a0\ndata\n)\n\u00a0\npublic\n\u00a0\n{\n\n\n\n\n\n\n3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\ncurrentContract\n\u00a0\n=\n\u00a0\nnewContract\n;\n\n\n\n\n\n\n4\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nnewContract\n.\ninitialize\n(\ndata\n);\n\n\n\n\n\n\n5\n\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n6\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\n()\n\u00a0\npayable\n\u00a0\npublic\n\u00a0\n{\n\n\n\n\n\n\n7\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrequire\n(\ncurrentContract\n\u00a0\n!=\n\u00a0\n0);\n\n\n\n\n\n\n8\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\ndelegatedFwd\n(\ncurrentContract\n,\n\u00a0\nmsg\n.\ndata\n);\n\n\n\n\n\n\n9\n\u00a0\u00a0\u00a0\u00a0\n}\n\u00a0\n...\n\n\n\n\n\n\n10\n}\n\n\n\n\n\n\nListing\u00a01: \nA simplified version of\nLANDProxy\n\n\nReport issue for preceding element\n\n\n\n\nListing\u00a0\n2\n presents a case I example. It lists the decompiled code of a simplified version of a (unverified) vulnerable UUPS-based logic contract.\nThere is a function \ninitialize\n (Line 8) that can be called directly.\nThis function can declare the owner of the contract (Line 9).\nSince this contract has no state, its ownership can be obtained by calling the \ninitialize\n function.\nAttackers can further call the \ndestruct\n (Line 4) function to destroy this contract, disabling its proxy contract and withdrawing all the ETHs (Line 7).\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n1\ndef\n\u00a0\nstorage\n:\n\n\n\n\n\n\n2\n\u00a0\u00a0\nowner\n\u00a0\nis\n\u00a0\naddress\n\u00a0\nat\n\u00a0\nstorage\n\u00a0\n151\n\n\n\n\n\n\n3\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n4\ndef\n\u00a0\ndestruct\n(\naddress\n\u00a0\nto\n):\n\n\n\n\n\n\n5\n\u00a0\u00a0\nif\n\u00a0\nowner\n\u00a0\n!=\n\u00a0\ncaller\n:\n\n\n\n\n\n\n6\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nrevert\n\u00a0\n\u2019\nnot\n\u00a0\nthe\n\u00a0\nowner\n\u2019\n\n\n\n\n\n\n7\n\u00a0\u00a0\nselfdestruct\n(\nto\n)\n\n\n\n\n\n\n8\ndef\n\u00a0\ninitialize\n():\n\n\n\n\n\n\n9\n\u00a0\u00a0\nowner\n\u00a0\n=\n\u00a0\ncaller\n\n\n\n\n\n\nListing\u00a02: \nDecompiled code of a Logic Contract that Contains SELFDESTRUCT\n\n\nReport issue for preceding element\n\n\n\n\nListing\u00a0\n3\n presents a case II example: a simplified version of a UUPS-based logic contract.\nIt does not contain \nSELFDESTRUCT\n opcode, but can still be destroyed through the function \nupgradeToAndCall\n.\nThe upgrade mechanism is implemented correctly for the proxy: only the owner can perform upgrades (Line 10).\nHowever, the \nupgradeToAndCall\n function can be directly called by the logic contract owner.\nAn attacker can call the function \ninitialize\n (Line 3) to take ownership of the logic contract, and further destroy it by calling the function \nupgradeToAndCall\n (Line 10).\nReport issue for preceding element\n\n\n\n\n\n\nParticularly, the \n_upgradeToAndCallSecure\n function includes a rollback test to validate that the new logic address also has an upgrade function (Line 29).\nHowever, this test can be bypassed by performing twice upgrades: first by resetting the \nrollbackTesting\n value (Line 28) and then by calling \n_upgradeToAndCallSecure\n function to a function containing \nSELFDESTRUCT\n in the upgrading logic contract (Line 26).\nThis would destroy the logic contract and cause the proxy\u2019s \nDELEGATECALL\n to point to a self-destructed logic contract.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n1\ncontract\n\u00a0\nToken\n\u00a0\nis\n\u00a0\n...,\n\u00a0\nUUPSUpgradeable\n{\n\n\n\n\n\n\n2\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n3\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\ninitialize\n(\nstring\n\u00a0\nmemory\n\u00a0\n_name\n,\n\u00a0\nstring\n\u00a0\nmemory\n\u00a0\n_symbol\n)\n\u00a0\ninitializer\n\u00a0\npublic\n\u00a0\n{\n\n\n\n\n\n\n4\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n5\n\u00a0\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n6\n\u00a0\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n7\n}\n\n\n\n\n\n\n8\nabstract\n\u00a0\ncontract\n\u00a0\nUUPSUpgradeable\n\u00a0\nis\n\u00a0\nERC1967UpgradeUpgradeable\n\u00a0\n{\n\n\n\n\n\n\n9\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n10\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\nupgradeToAndCall\n(\naddress\n\u00a0\nnewImplementation\n,\n\u00a0\nbytes\n\u00a0\nmemory\n\u00a0\ndata\n)\n\u00a0\nexternal\n\u00a0\npayable\n\u00a0\nvirtual\n\u00a0\n{\n\n\n\n\n\n\n11\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n_authorizeUpgrade\n(\nnewImplementation\n);\n\n\n\n\n\n\n12\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n_upgradeToAndCallSecure\n(\nnewImplementation\n,\n\u00a0\ndata\n,\n\u00a0\ntrue\n);\n\n\n\n\n\n\n13\n\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n14\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n15\n}\n\n\n\n\n\n\n16\nabstract\n\u00a0\ncontract\n\u00a0\nERC1967UpgradeUpgradeable\n\u00a0\n{\n\n\n\n\n\n\n17\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n18\n\u00a0\u00a0\u00a0\u00a0\nfunction\n\u00a0\n_upgradeToAndCallSecure\n(\n\n\n\n\n\n\n19\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\naddress\n\u00a0\nnewImplementation\n,\n\n\n\n\n\n\n20\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nbytes\n\u00a0\nmemory\n\u00a0\ndata\n,\n\n\n\n\n\n\n21\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nbool\n\u00a0\nforceCall\n\n\n\n\n\n\n22\n\u00a0\u00a0\u00a0\u00a0\n)\n\u00a0\ninternal\n\u00a0\n{\n\n\n\n\n\n\n23\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n24\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n_setImplementation\n(\nnewImplementation\n);\n\n\n\n\n\n\n25\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nif\n\u00a0\n(\ndata\n.\nlength\n\u00a0\n>\n\u00a0\n0\n\u00a0\n||\n\u00a0\nforceCall\n)\n\u00a0\n{\n\n\n\n\n\n\n26\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n_functionDelegateCall\n(\nnewImplementation\n,\n\u00a0\ndata\n);\n\n\n\n\n\n\n27\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n28\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nBooleanSlot\n\u00a0\nstorage\n\u00a0\nrollbackTesting\n\u00a0\n=\n\u00a0\ngetBooleanSlot\n(\n_ROLLBACK_SLOT\n);\n\n\n\n\n\n\n29\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nif\n\u00a0\n(!\nrollbackTesting\n.\nvalue\n)\n\u00a0\n{\n\n\n\n\n\n\n30\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n31\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n_upgradeTo\n(\nnewImplementation\n);\n\n\n\n\n\n\n32\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n33\n\u00a0\u00a0\u00a0\u00a0\n}\n\n\n\n\n\n\n34\n\u00a0\u00a0\u00a0\u00a0\n...\n\n\n\n\n\n\n35\n}\n\n\n\n\n\n\n36\n...\n\n\n\n\n\n\nListing\u00a03: \nDecompiled code of a Logic Contract that Function Setter Can Be Called Directly\n\n\nReport issue for preceding element\n\n\n\n\nIV. Additional Figures of Vulnerable Examples\nReport issue for preceding element\n\n\n\n\n\n\nFigure\u00a0\n5\n presents a real-world example of proxy-based USC. Figure\u00a0\n4(a)\n shows a transaction from a proxy\u2019s admin to \ninitialize\n the proxy contract.\nAs the function \ninitialize \n is supposed to exist in the logic contract, the proxy contract simply delegates the call to the logic contract (Figure\u00a0\n4(b)\n).\nHowever, the logic address is actually an EOA.\nThus, the \ninitialize\n was not executed and eventually has no state change.\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n \n A Transaction Send from Contract\u2019s Admin\n\n\nReport issue for preceding element\n\n\n\n\n\n\n\n\n\n\n(b)\n \nThe Proxy Contract Delegate Call to an EOA \n\n\nReport issue for preceding element\n\n\n\n\n\n\nFigure 5\n. \nUSC Patterns.\n\n\nReport issue for preceding element\n\n\n\n"
    }
}