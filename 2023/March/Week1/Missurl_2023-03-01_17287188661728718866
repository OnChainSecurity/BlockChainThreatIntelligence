{
    "threat_intelligence": {
        "url": "https://pixelplex.io/blog/smart-contract-vulnerabilities/",
        "timestamp": "2023-03-01 00:00:00",
        "original_content": "No matter how perfect your smart contract may look, it can still be vulnerable. But what are the most common smart contract security risks, and how do you guard against them?\nSmart contracts are specialized programs stored on a blockchain and used to automate the execution of an agreement between different parties. Most smart contracts deal with financial assets.\n\n\nDue to the large sums of funds that transfer through them, these programs often become the targets of malicious actors aiming to exploit smart contract vulnerabilities.\n\n\nFor example, in March 2023, Euler Finance lost \n$197 million\n worth of cryptocurrency because of a flash loan attack. In October 2023, DeFi protocol Platypus suffered three attacks, with \n$2.23 million\n taken across the exploits.\n\n\nImportantly, smart contract attacks do not only lead to significant fund losses but also negatively affect the credibility of the protocol and the project team behind it, which may have an even more dramatic effect in the long run.\n\n\nContinue reading to learn about the most common smart contract vulnerabilities, illustrated with real-life examples. We will also discuss \nour approach\n to smart contract security and provide tips for smart contract audits, drawing from our experience with \nreal-life projects, such as Prism and W3A\n.\n\n\nIntroduce yourself to our blockchain development service offerings. Let\u2019s see how we can assist you\n7 most common smart contract vulnerabilities\n\n\nOnce you know about the most widespread blockchain smart contract vulnerabilities, you\u2019ll be more aware of how to prevent potential exploitation. So, let\u2019s take a look at the 7 most common smart contract vulnerabilities, along with real-world instances of smart contract hacks.\n\n\n\n\n1. Reentrancy attack\n\n\nReentrancy is one of the most iconic exploitable smart contract vulnerabilities. It occurs when a smart contract calls another smart contract in its code and, when the new call is finished, continues with execution. This action requires the vulnerable contract to submit an external call.\n\n\nScammers steal these external calls and make a recursive call back to the contract with the help of the callback function. They can create a contract at an external address using malicious code.\n\n\nWhen the smart contract fails to update its state before sending funds, the scammer can continuously call the withdraw function, thus allowing them to drain the contract funds.\n\n\nReentrancy attack real-life example\n\n\nThe most famous example of reentrancy is \nThe DAO attack\n that occurred only three months after its launch. An anonymous hacker managed to drain most of the $150M worth of ETH from the DAO\u2019s smart contract over the course of a few weeks. This resulted in the loss of investors\u2019 trust and struck a significant blow to Ethereum\u2019s credibility.\n\n\nAfter the attack, the Ethereum community voted to return the network to its original state and shutter the DAO.\n\n\n2. Front-running\n\n\nInterestingly, smart contracts and transactions become fully public once you submit them to the network as a pending transaction. These transactions are visible to the entire network in the mempools of Ethereum nodes, enabling block miners to select transactions with the highest gas fees.\n\n\nThere is a significant side effect of this visibility. It allows malicious actors to see the intended outcome of a smart contract before it\u2019s confirmed on the blockchain. Imagine you have a smart contract that, when run, will execute an arbitrage that costs 0,04 ETH to deploy. Knowing this information, fraudsters can copy your smart contract and submit it with a higher gas fee. This way they successfully front-run your smart contract and steal your arbitrage opportunity by submitting their transaction first.\n\n\nUnfortunately, these attacks are difficult to avoid.\u00a0 Even so, there are a variety of cutting-edge practices that can help you secure your contract. These include gas limiting, which presupposes accepting only transactions with a gas price below the appointed threshold, and also using the pre-commit scheme, which implies submitting a hash instead of your data in the first commit and providing details at a later time.\n\n\nFront-running real-life example\n\n\nA noteworthy example of a front-running attack is the \nDODO DEX\n hack. During this hack, an original attacker became the victim of two cryptocurrency trading bots. This decreased the impact of the hack as they frontrunned some of the attacker\u2019s attempts to exploit smart contract vulnerabilities. The owners of both cryptocurrency trading bots agreed to return the stolen funds, which totaled $3.1 million, but $700,000 remained stolen by the original attacker.\n\n\n3. Integer overflow and underflow\n\n\nThis smart contract vulnerability is common to many programming languages, including Solidity. A Solidity smart contract is built using 256 bits as the word size, which equates to 4.3 billion Ether. If you reduce the value of an unsigned integer to zero, it will return to the maximum value.\n\n\nA scammer may exploit the smart contract using a malicious address that is recorded by the smart contract to make a zero balance send 1 unit of Ether. It will force the smart contract\u2019s balance to cycle back to the maximum value allowed (4.3 billion Ether).\n\n\nAs the smart contract believes the address has a balance of 4,3 billion Ether, it may allow withdrawals from that account until the smart contract is drained of funds.\n\n\nBoth underflow and overflow issues cause significant differences between the calculation\u2019s actual outcome and expected results, thus undermining the smart contract\u2019s inherent logic, and leading to the contract\u2019s funds being lost.\n\n\nA simple measure to avoid this hack is to use the 0.8 version of the Solidity compiler, which automatically checks for underflows and overflows.\n\n\nInteger overflow and underflow real-life example\n\n\nA good example of underflow and overflow vulnerabilities would be a cryptocurrency Ponzi scheme: \nProof of Week Hands Coin\n. The project promised a legitimate pyramid scheme, which quickly gained value of over a million dollars. But in just one night it lost $800K due to arithmetic flaws.\n\n\nThe project\u2019s implementation of ERC-20 allowed a person to approve another user to transfer tokens on their behalf. A malicious actor enabled a second account to sell coins from the first account. However, these coins were taken off the second account\u2019s balance. As a result, integer underflow left the second account with an extremely large balance of PoWH Coins.\n\n\nMeet Echo \u2014 a Layer 2 network for building smart contracts and dApps with EVM support developed by PixelPlex\n4. Simple logic error\n\n\nLogic errors tend to be one of the most common types of blockchain smart contract vulnerabilities. These may include typographical errors, misinterpretation of specifications, and the more serious programming errors that decrease the security of smart contracts.\n\n\nThe good news is that these problems can be identified and eliminated during the smart contract audit, which is why it is recommended that you do not ignore this step before deploying your smart contracts to the blockchain.\n\n\nSimple logic error real-life example\n\n\nThe Hegic case\n is an interesting example of how a minor typo can cause financial loss. Hegic is a platform that allows users to insure against price volatility options. The platform was forced to restart its protocol when it spotted a simple typo in the code: instead of the \u201cOptionsIDs\u201d function which unlocks liquidity in expired contracts, it had the non-existent \u201cOptionIDs\u201d command, which omitted the letter \u201cs\u201d.\n\n\nBecause of this error, users\u2019 assets were blocked whenever they didn\u2019t use their options, resulting in no liquidity for expired contracts. Fixing this error and providing the affected users with a refund cost Hedic $48K.\n\n\n5. Block gas limit vulnerability\n\n\nThe block gas limit helps ensure that blocks do not grow too large. If a transaction consumes too much gas, it will not fit the block and, ultimately, will not be executed.\n\n\nThe result is a block gas limit vulnerability: if data is stored in arrays and further accessed through loops over these arrays, the transaction may run out of gas and get a refund. This can lead to a Denial of Service (DoS) attack.\n\n\nBlock gas limit vulnerability real-life example\n\n\nGovernMental\n is yet another failed Ponzi scheme project. To join the project a user was required to send a certain amount of Ether to the contract. At a certain point, the list of project participants grew so long that it would have required more gas to clear the arrays than the maximum amount allowed for a single transaction. From this point onwards, all attempts to clear the arrays have failed.\n\n\n6. Default visibility\n\n\nVisibility defines whether a function can be called internally or externally by users. The default visibility state for functions is public.\n\n\nIt becomes a problem when smart contract developers do not specify the visibility of functions that should be private or only callable within the contract itself.\n\n\nDefault visibility real-life example\n\n\nThe \nParity MultiSig Wallet hack\n occurred as a result of developers accidentally leaving two functions public. The attacker had an opportunity to call these functions and change the ownership to the attacker\u2019s address. This mistake allowed the hacker to steal $31M worth of Ether from three wallets.\n\n\n7. Timestamp dependence\n\n\nIf the smart contract uses the block.timestamp function to display StartTime and EndTime, the malicious miner can manipulate the timestamp for a few seconds and change the output so that it is in their favor. This is why it is not recommended to use the block.timestamp function to get the current time, due to the blockchain\u2019s decentralized nature.\n\n\nIt\u2019s worth mentioning that this vulnerability is serious only if it is used in the critical components of a smart contract. To prevent it, you can either avoid using the block.timestamp function, or allow a range of +900 seconds of error \u2014 so if the timestamp value returned by the node is increased by a value between 1 to 900 seconds it will not have a huge impact on the contract.\n\n\nTimestamp dependence real-life example\n\n\nCheck out the smart contract source code for \nEtherLotto\n \u2014 a lottery game where users are meant to send money to the smart contract function play. The amount of money should be equal to the TICKET_AMOUNT. In any other case, it will fail.\n\n\nThe smart contract retrieves the time when the contract is executed. It goes on to apply a formula to it and stores the value in a random variable as shown in line 14. Afterward, it checks if this value is equal to zero and, in the event that it does, the transaction is named the winner.\n\n\nThe smart contract calls the block.timestamp function to get the actual time. The value of this variable is given by the node, meaning that the malicious user can easily manipulate it until it gets the result of line 14 as zero.\n\n\nThese have been the most common smart contract vulnerabilities that can lead to serious issues. Other potential vulnerabilities that are regularly spotted by smart contract auditors, among them our PixelPlex specialists, include:\n\n\n\n\nIrrelevant code\n\n\nImproper initialization\n\n\nImproper locking\n\n\nUncontrolled resource consumption\n\n\nIncorrect behavior and business logic\n\n\nPoor adherence to coding standards\n\n\nIncorrectly handled exceptions\n\n\nIncorrect work with ERC-20 tokens\n\n\nUsing the blockchain function\n\n\nMissing withdraw functions\n\n\nUsing an obsolete function\n\n\n\n\nNonetheless, you should realize that this list is to all intents and purposes even larger, as hackers are continually searching for novel ways to deceive businesses and users. Therefore, you should take all possible preventative measures to secure your smart contracts and avoid financial loss and reputation damage.\n\n\nNeed assistance with secure smart contract development? Check out our service offering\nHow can your business avoid vulnerabilities in smart contracts? The guide from PixelPlex smart contract auditors\n\n\nOur team has collected a list of working practices that can help you ensure the security of your smart contracts. Let\u2019s take a look at each of them.\n\n\n\n\nConduct a smart contract audit\n\n\nNot surprising, right? It may seem very basic, yet it\u2019s the most critical step you can take. The audit can help you eliminate all vulnerabilities in your contract, ensure its correct functioning, optimize gas consumption, and increase the overall performance of your source code. This is why it should be an integral part of any smart contract development process.\n\n\nSmart contract auditors will not only document your smart contract security vulnerabilities but also advise you on how to fix all these issues and optimize your smart contracts.\n\n\nWhen enhancing the security of smart contracts, it\u2019s important to consider having multiple audits performed by various reputable firms. Take, for example, a recent case with one of our clients, \nPrism\n. They approached our team for a smart contract audit for their NFT marketplace. Our team conducted a thorough analysis of the smart contracts, identified and resolved existing issues, and even rewrote parts of the contract. However, for even stronger security, we also had the project audited by an independent third-party firm.\n\n\nFurthermore, conducting regular audits is crucial for maintaining security over time. This comprehensive approach not only ensures the security of the project but also contributes to delivering an optimal user experience.\n\n\nDocument smart contract vulnerabilities and security practices\n\n\nMost, if not all, mistakes can be turned into learning opportunities. You should document smart contract vulnerabilities and mistakes that others have made so that you can avoid them. Afterward, you can check your smart contract against all known security issues.\n\n\nSimilarly, it would be wise to maintain a list of the most effective smart contract security practices followed by leading organizations. These could include keeping as much code off-chain as you can, writing small functions and splitting the logic through multiple contracts, and creating thorough code documentation.\n\n\nPerform internal security checks\n\n\nSet up an internal security team that will keep a pulse on the security of your \nsmart contracts\n by frequently auditing the source code for bugs and making sure there are no issues that can be exploited by smart contract hackers.\n\n\nUse a bug bounty program\n\n\nAfter you have performed a smart contract security audit, you can also use the bug bounty program to ensure even greater security for your smart contract.\n\n\nBug bounty programs are the platforms where ethical hackers tamper with your code to find smart contract vulnerabilities. In these programs, individuals receive compensation for reporting bugs.\n\n\nLeverage security audit tools\n\n\nThere are plenty of useful security audit tools available on the market. For example, Awesome Buggy ERC20m Tokens, where ERC20 smart contract vulnerabilities are collected, or the SWC registry, which is a library of smart contract weaknesses and vulnerabilities.\n\n\nWe also recommend implementing security tools on your platforms for enhanced user protection. For instance, our team has developed \nW3A\n, a security solution specifically designed for this purpose. W3A meticulously scrutinizes smart contracts that users engage with. It performs static analyses, evaluates the execution logic, and looks for unusual methods or deviations from established standards. Users receive immediate alerts regarding any potential risks, malicious logic, vulnerabilities, or risky permissions.\n\n\nSumming up\n\n\nSo often it\u2019s the minor bugs that give rise to massive smart contract exploitation and consequent loss of money. To avoid this scenario, your goal is to boost your solution security and prevent any potential smart contract vulnerabilities. That is why we recommend you conduct regular security audits of your smart contracts.\n\n\nIf you need assistance with the smart contract audit or advice on how to secure your smart contract, you can confidently place your trust in our \nsmart contract auditors\n and developers.\n\n\nWith our 10 years of experience in blockchain development, including smart contract implementations and audits, you can be assured that you\u2019ll be in safe hands.\n\n"
    }
}