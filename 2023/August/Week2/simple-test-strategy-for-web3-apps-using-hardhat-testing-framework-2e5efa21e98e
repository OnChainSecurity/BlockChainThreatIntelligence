{
    "threat_intelligence": {
        "url": "https://medium.com/@sebas.viquez/simple-test-strategy-for-web3-apps-using-hardhat-testing-framework-2e5efa21e98e",
        "timestamp": "2023-08-13 00:00:00",
        "original_content": "Simple Test Strategy for Web3 Apps using Hardhat Testing Framework.\nSebasViquez\nSebasViquez\n\n\u00b7\nFollow\n\n10 min read\n\u00b7\nAug 13, 2023\n12\n\n\n\n\n\n\n\nhttps://hardhat.org/\nTesting web3 apps is essential to ensure their functionality, security, and reliability. The Hardhat framework, a popular development environment for Ethereum-based projects, provides powerful tools for testing smart contracts and other components of your web3 app.\n\nYou can see Hardhat overview and quick start guidelines from here > https://hardhat.org/hardhat-runner/docs/getting-started\n\nNow, lets create a simple yet solid test strategy to ensure the quality of your web3 app using Hardhat.\n\n1. Unit Testing Smart Contracts:\nObjective: Verify the correctness of individual smart contract functions and methods.\n\nApproach:\n\nWrite unit tests for each function and method in your smart contracts.\nUse Hardhat\u2019s built-in testing framework, which supports the Mocha testing library and Chai assertion library.\nTest different scenarios, including edge cases and different inputs, to ensure comprehensive coverage.\nAssume we have a basic smart contract named SampleContract with the following functions:\n\n// SampleContract.sol\n\npragma solidity ^0.8.21\n\ncontract SampleContract {\n    uint256 public value;\n\n    function setValue(uint256 _newValue) external {\n        value = _newValue;\n    }\n\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\n        return a + b;\n    }\n\n    function subtract(uint256 a, uint256 b) external pure returns (uint256) {\n        require(a >= b, \"Subtraction result must be non-negative\");\n        return a - b;\n    }\n}\nNow, let\u2019s write unit tests for these functions using Hardhat:\n\n// SampleContract.test.js\n\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\n    describe(\"SampleContract\", function () {\n        let sampleContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n        });\n\n        it(\"should set the value\", async function () {\n    const newValue = 42;\n            await sampleContract.setValue(newValue);\n            expect(await sampleContract.value()).to.equal(newValue);\n        });\n\n        it(\"should add two numbers\", async function () {\n    const a = 10;\n    const b = 20;\n    const result = await sampleContract.add(a, b);\n            expect(result).to.equal(a + b);\n        });\n\n        it(\"should subtract two numbers\", async function () {\n    const a = 30;\n    const b = 15;\n    const result = await sampleContract.subtract(a, b);\n            expect(result).to.equal(a - b);\n        });\n\n        it(\"should revert when subtracting with larger second number\", async function () {\n    const a = 10;\n    const b = 20;\n            await expect(sampleContract.subtract(a, b)).to.be.revertedWith(\n                    \"Subtraction result must be non-negative\"\n            );\n        });\n    });\nCode breakdown:\n\nWe import the necessary libraries and define the test suite using describe.\nIn the beforeEach block, we deploy a fresh instance of SampleContract before each test to isolate the tests from one another.\nThe first test (should set the value) checks if the setValue function correctly updates the value state variable.\nThe second test (should add two numbers) verifies that the add function returns the expected sum of two numbers.\nThe third test (should subtract two numbers) checks that the subtract function returns the expected difference of two numbers.\nThe fourth test (should revert when subtracting with larger second number) ensures that the subtract function reverts when trying to subtract a larger number from a smaller one.\nNow, to run these tests, use the following command in your Hardhat project directory terminal:\n\nnpx hardhat test\n2. Integration Testing:\nObjective: Validate the interactions between smart contracts and other components of the app.\n\nApproach:\n\nWrite integration tests to ensure that different parts of your web3 app work together as expected.\nTest scenarios where one smart contract interacts with another, and check if the desired state changes occur.\nEnsure correct handling of events emitted by smart contracts.\nFor this example, we\u2019ll consider two smart contracts, SampleContract and AnotherContract, where AnotherContract interacts with our existing SampleContract\n\n// AnotherContract.sol\n\npragma solidity ^0.8.21;\n\nimport \"./SampleContract.sol\";\n\n    contract AnotherContract {\n        SampleContract public sampleContract;\n\n        constructor(address _sampleContractAddress) {\n            sampleContract = SampleContract(_sampleContractAddress);\n        }\n\n        function updateValue(uint256 _newValue) external {\n            sampleContract.setValue(_newValue);\n        }\n    }\n// IntegrationTest.js\n\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\n    describe(\"Integration Test\", function () {\n        let sampleContract;\n        let anotherContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n\n    const AnotherContract = await ethers.getContractFactory(\"AnotherContract\");\n            anotherContract = await AnotherContract.deploy(sampleContract.address);\n            await anotherContract.deployed();\n        });\n\n        it(\"should update value through AnotherContract\", async function () {\n    const newValue = 100;\n            await anotherContract.updateValue(newValue);\n    const updatedValue = await sampleContract.value();\n            expect(updatedValue).to.equal(newValue);\n        });\n    });\nHere\u2019s what the code does:\n\nWe import the necessary libraries and define the integration test suite using describe.\nIn the beforeEach block, we deploy instances of both SampleContract and AnotherContract. The AnotherContract is initialized with the address of the deployed SampleContract.\nThe integration test (should update value through AnotherContract) verifies that calling the updateValue function in AnotherContract correctly updates the value in the SampleContract.\n3. Security Testing:\nObjective: Identify and mitigate potential vulnerabilities in your smart contracts.\n\nApproach:\n\nUse tools like MythX or Slither to analyze your smart contracts for common security vulnerabilities.\nWrite test cases that target specific security issues like reentrancy attacks, integer overflows, and more.\nRegularly update your tests to incorporate new security findings and best practices.\nFor this example, we\u2019ll focus on the SampleContract and AnotherContract interactions. We'll cover both security test cases for reentrancy and integer overflow vulnerabilities.\n\n// SecurityTest.js\n\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\n    describe(\"Security Test\", function () {\n        let sampleContract;\n        let anotherContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n\n    const AnotherContract = await ethers.getContractFactory(\"AnotherContract\");\n            anotherContract = await AnotherContract.deploy(sampleContract.address);\n            await anotherContract.deployed();\n        });\n\n        it(\"should prevent reentrancy attack\", async function () {\n            // Deploy a malicious contract\n    const MaliciousContract = await ethers.getContractFactory(\"MaliciousContract\");\n    const maliciousContract = await MaliciousContract.deploy(anotherContract.address);\n            await maliciousContract.deployed();\n\n            // Trigger the reentrancy attack\n            await expect(maliciousContract.triggerReentrancyAttack(10)).to.be.revertedWith(\n                    \"Reentrancy attack detected\"\n            );\n\n            // Verify that no funds were stolen\n    const balance = await maliciousContract.getBalance();\n            expect(balance).to.equal(0);\n        });\n\n        it(\"should prevent integer overflow\", async function () {\n            // Set initial value to the maximum possible value\n            await sampleContract.setValue(2**256 - 1);\n\n            // Attempt to overflow by adding a large number\n            await expect(sampleContract.setValue(1)).to.be.revertedWith(\n                    \"SafeMath: addition overflow\"\n            );\n\n            // Verify that the value remains unchanged\n    const value = await sampleContract.value();\n            expect(value).to.equal(2**256 - 1);\n        });\n    });\nCode breakdown:\n\nWe import the necessary libraries and define the security test suite using describe.\nIn the beforeEach block, we deploy instances of SampleContract and AnotherContract.\nThe first test (should prevent reentrancy attack) simulates a reentrancy attack using a malicious contract and ensures that the attack is detected and prevented.\nThe second test (should prevent integer overflow) verifies that the contract's setValue function prevents integer overflow by reverting when an overflow would occur.\n4. End-to-End (E2E) Testing:\nObjective: Validate the functionality of your entire web3 app, including the user interface.\n\nApproach:\n\nIntegrate E2E testing tools like Cypress or Truffle\u2019s \"truffle-assertions\" library.\nWrite tests that simulate user interactions, such as sending transactions and interacting with the user interface.\nEnsure that data flows smoothly between the frontend, smart contracts, and backend services.\nFor this scenario, we\u2019ll use the same SampleContract and AnotherContract setup from previous examples.\n\nAssuming you have a smart contract and a frontend component that interacts with it, here\u2019s how you can write E2E tests using the \"truffle-assertions\" library:\n\n// E2ETest.js\n\nconst { expect } = require(\"chai\");\nconst { ethers, artifacts } = require(\"hardhat\");\nconst truffleAssert = require(\"truffle-assertions\");\n\n    describe(\"E2E Test\", function () {\n        let sampleContract;\n        let anotherContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n\n    const AnotherContract = await ethers.getContractFactory(\"AnotherContract\");\n            anotherContract = await AnotherContract.deploy(sampleContract.address);\n            await anotherContract.deployed();\n        });\n\n        it(\"should simulate user interaction and data flow\", async function () {\n            // Deploy frontend contract\n    const FrontendContract = await ethers.getContractFactory(\"FrontendContract\");\n    const frontendContract = await FrontendContract.deploy(anotherContract.address);\n            await frontendContract.deployed();\n\n            // Simulate user interaction\n    const userAddress = \"0x123...\"; // User's Ethereum address\n    const newValue = 50;\n\n            // Call frontend contract's function to update value through AnotherContract\n    const tx = await frontendContract.updateValue(userAddress, newValue);\n            await tx.wait();\n\n            // Verify that the value was updated correctly\n    const updatedValue = await sampleContract.value();\n            expect(updatedValue).to.equal(newValue);\n\n            // Verify events using truffle-assertions\n            truffleAssert.eventEmitted(tx, \"ValueUpdated\", (event) => {\n            return event.user === userAddress && event.newValue.toNumber() === newValue;\n            });\n        });\n    });\nWe import the necessary libraries and define the E2E test suite using describe.\nIn the beforeEach block, we deploy instances of SampleContract, AnotherContract, and a hypothetical FrontendContract.\nThe E2E test (should simulate user interaction and data flow) simulates user interaction through the frontend contract to update the value using updateValue function.\nAfter the transaction, we verify that the value was updated correctly in the SampleContract.\nWe also use the truffle-assertions library to verify that the expected event was emitted during the transaction.\n5. Blockchain Network Testing:\nObjective: Verify that your web3 app functions correctly on different Ethereum networks.\n\nApproach:\n\nCreate testnet-specific and mainnet-specific test cases to ensure compatibility across different networks.\nUse Hardhat\u2019s network configuration to switch between networks and run tests accordingly.\nFor the above, you can utilize the Hardhat network tags feature. This allows you to conditionally run tests based on the selected network. Let\u2019s extend the previous tests with network-specific cases for the Goerli testnet and Ethereum mainnet.\n\n// E2ETest.js\n\nconst { expect } = require(\"chai\");\nconst { ethers, artifacts } = require(\"hardhat\");\nconst truffleAssert = require(\"truffle-assertions\");\n\n    describe(\"E2E Test\", function () {\n        let sampleContract;\n        let anotherContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n\n    const AnotherContract = await ethers.getContractFactory(\"AnotherContract\");\n            anotherContract = await AnotherContract.deploy(sampleContract.address);\n            await anotherContract.deployed();\n        });\n\n        it(\"should simulate user interaction and data flow on testnet\", async function () {\n            if (network.name === \"goerli\") {\n                // Deploy frontend contract\n      const FrontendContract = await ethers.getContractFactory(\"FrontendContract\");\n      const frontendContract = await FrontendContract.deploy(anotherContract.address);\n                await frontendContract.deployed();\n\n                // Simulate user interaction\n      const userAddress = \"0x123...\"; // User's Ethereum address\n      const newValue = 50;\n\n                // Call frontend contract's function to update value through AnotherContract\n      const tx = await frontendContract.updateValue(userAddress, newValue);\n                await tx.wait();\n\n                // Verify that the value was updated correctly\n      const updatedValue = await sampleContract.value();\n                expect(updatedValue).to.equal(newValue);\n\n                // Verify events using truffle-assertions\n                truffleAssert.eventEmitted(tx, \"ValueUpdated\", (event) => {\n                return event.user === userAddress && event.newValue.toNumber() === newValue;\n      });\n            } else {\n                // Skip the test if not on Goerli\n                this.skip();\n            }\n        });\n\n        it(\"should simulate user interaction and data flow on mainnet\", async function () {\n            if (network.name === \"mainnet\") {\n                // Similar to the test above, adjust for mainnet deployment\n            } else {\n                // Skip the test if not on Mainnet\n                this.skip();\n            }\n        });\n    });\nBreakdown:\n\nWe use if (network.name === ...) conditions to selectively execute the tests based on the current network name (goerli or mainnet).\nFor the \"testnet\" test, we simulate user interaction and data flow using a hypothetical frontend contract, similar to the previous example.\nFor the \"mainnet\" test, you would create similar conditions and adjustments for mainnet-specific deployment and interactions.\nIf the current network is not Goerli or Mainnet, the test is skipped using this.skip().\nTo run the test on a specific network, you can use the --network flag. For example, to run the test on the Goerli testnet:\n\nnpx hardhat test --network goerli\n6. Automated Testing and Continuous Integration (CI):\nObjective: Maintain consistent testing and integration with every code change.\n\nApproach:\n\nIntegrate your test suite with your CI/CD pipeline to automatically run tests whenever new code is pushed.\nUse tools like GitHub Actions or Jenkins to set up automated testing and deployment processes.\nAutomating Testing with GitHub Actions:\nCreate a .github/workflows directory in your project's root directory if it doesn't already exist.\nInside the .github/workflows directory, create a YAML file (e.g., test.yml) to define your workflow. Below is an example GitHub Actions workflow for running tests on push:\nname: Run Tests\n\non: push\n\njobs:\ntest:\nruns-on: ubuntu-latest\n\nsteps:\n  - name: Checkout code\n    uses: actions/checkout@v2\n\n  - name: Set up Node.js\n    uses: actions/setup-node@v2\n    with:\n      node-version: 14\n\n  - name: Install dependencies\n    run: npm install\n\n  - name: Run tests\n    run: npx hardhat test\nWorkflow / reference:\n\nTriggers on every push to your repository.\nSets up a Node.js environment.\nInstalls project dependencies.\nRuns tests using the npx hardhat test command.\nYou can also visit https://docs.github.com/en/actions/quickstart\n\n7. Load and Performance Testing (Optional):\nObjective: Assess the scalability and performance of your web3 app under various loads.\n\nApproach:\n\nUse tools like k6 or Artillery to simulate high user loads and monitor system behavior.\nEnsure that your smart contracts and backend services can handle increased transaction volumes.\nWe\u2019ll create a k6 script to simulate a high number of users interacting with our smart contracts and backend services. In this example, we\u2019ll focus on simulating interactions with the SampleContract and its functions.\n\nInstall k6: If you haven\u2019t already, install k6 by following the installation guide for your operating system: k6 Installation\nCreate a k6 Script: Create a new file named loadtest.js or a name of your choice. Inside this file, you can define your k6 load testing script.\nimport http from 'k6/http';\nimport { sleep, check } from 'k6';\n\n    export let options = {\n        stages: [\n        { duration: '1m', target: 150 }, // Ramp up to 150 virtual users in 1 minute\n        { duration: '3m', target: 150 }, // Stay at 150 virtual users for 3 minutes\n        { duration: '1m', target: 0 }   // Ramp down to 0 virtual users in 1 minute\n  ],\n    };\n\n    export default function () {\n        let res = http.get('http://your-backend-url/api/endpoint'); // Replace with your actual endpoint\n        check(res, { 'status is 200': (r) => r.status === 200 });\n        sleep(1); // Sleep for 1 second between requests\n    }\n8. API Testing\nObjective: API tests involve interactions with the Ethereum blockchain and its smart contracts.\n\nApproach:\n\nAPI tests for Ethereum smart contracts are a bit different from traditional API tests.\nWe can use Hardhat and the ethers library to interact with the smart contracts.\nWe'll use the same SampleContract and AnotherContract setup.\n\n// APITest.js\n\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\n    describe(\"API Test\", function () {\n        let sampleContract;\n        let anotherContract;\n\n        beforeEach(async function () {\n    const SampleContract = await ethers.getContractFactory(\"SampleContract\");\n            sampleContract = await SampleContract.deploy();\n            await sampleContract.deployed();\n\n    const AnotherContract = await ethers.getContractFactory(\"AnotherContract\");\n            anotherContract = await AnotherContract.deploy(sampleContract.address);\n            await anotherContract.deployed();\n        });\n\n        it(\"should interact with SampleContract API\", async function () {\n    const newValue = 75;\n\n            // Interact with SampleContract\n            await sampleContract.connect(owner).setValue(newValue);\n    const updatedValue = await sampleContract.value();\n\n            expect(updatedValue).to.equal(newValue);\n        });\n\n        it(\"should interact with AnotherContract API\", async function () {\n    const newValue = 120;\n\n            // Interact with AnotherContract\n            await anotherContract.connect(owner).updateValue(newValue);\n    const updatedValue = await sampleContract.value();\n\n            expect(updatedValue).to.equal(newValue);\n        });\n    });\n9. Documentation:\nObjective: Document your testing strategy, test cases, and results for future reference and collaboration.\n\nApproach:\n\nCreate a dedicated section in your project\u2019s documentation that outlines the testing strategy.\nDocument how to run tests locally, the purpose of each test suite, and the expected outcomes.\n\"How to Run Tests Locally\"\n\nPrerequisites:\n\nInstall Node.js and npm.\nInstall Hardhat:\nnpm install --save-dev hardhat\nSetting Up Test Environment:\n\nClone the repository from GitHub.\nNavigate to the project directory.\nRun Unit and Integration Tests:\n\nRun npx hardhat test to execute unit and integration tests.\nVerify that all tests pass and check for any unexpected behaviors.\nRun Security Tests:\n\nRun npx hardhat test --network localhostto execute security tests.\nEnsure that vulnerabilities are caught and addressed appropriately.\nRun E2E Tests:\n\nSet up frontend and backend environments according to their documentation.\nRun E2E tests for user interactions using the appropriate tools.\nNetwork-Specific Testing:\n\nUse the--network flag to specify the network for network-specific tests.\nFor example: npx hardhat test --network goerli\n- - Wrapping it\nBy following a simple yet robust test strategy, you can thoroughly test your web3 app using Hardhat. This approach is just a reference, but it covers unit testing, integration testing, security testing, E2E testing, network testing, automation, API, and documentation. Regularly updating your tests and incorporating new findings will help maintain the security and quality of your web3 app as the blockchain landscape continues to evolve."
    }
}