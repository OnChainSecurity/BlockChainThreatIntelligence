{
    "threat_intelligence": {
        "url": "https://dn.institute/attacks/docs/reentrancy/",
        "timestamp": "2023-07-01 00:00:00",
        "original_content": "What is Reentrancy?\n\n#\nReentrancy is a malicious attack that can be used to exploit smart contracts. It occurs when an attacker is able to call back into a function before its previous invocations have completed. This attack exploits the malicious sequence of function calls in smart contracts, enabling an attacker to manipulate the contract\u2019s data in unforeseen ways. It\u2019s particularly problematic for functions that send Ether or any native token of\n\nEVM-compatible chains\n, as it can lead to the theft of funds.\nHow do Reentrancy Attacks Work?\n\n#\nReentrancy attacks exploit the way that certain calls can be made within a contract. A contract\u2019s function may call another contract\u2019s function, and if the latter has a callback, which would switch an execution flow to the calling contract, it can lead to unexpected behavior. This can cause state variables to be unpredictably modified by the malicious contract, leading to a wide variety of potential problems, including theft of funds or corrupted data.\nTypes of Reentrancy Attacks\n\n#\nSingle-Function Reentrancy\n\n\n#\nThis type of reentrancy attack occurs when a contract\u2019s function is exploited to call itself recursively before its execution is complete. This is the most common type of reentrancy attack.\nAttack Example\n\n#\nThe DAO: $60m (June 2016)\n\n#\nVulnerability\n: The DAO (Decentralized Autonomous Organization) had a function that allowed users to split from the DAO and create a \u201cChild DAO.\u201d This function contained a flaw where the external call to send Ether was made before the balance was updated.\nAttack\n: An attacker exploited this by creating a malicious contract that repeatedly called the vulnerable function, draining Ether each time before the balance was updated. As a result, the attacker was able to steal about 3.6 million ETH, which was worth approximately $60 million at the time, leading to a hard fork in the Ethereum network.\nCross-Function Reentrancy\n\n\n#\nThis attack involves the exploitation of two or more functions within the same contract. An attacker may manipulate the control flow of one function to reenter another function, leading to unexpected changes in the contract\u2019s state, like user\u2019s balances, token prices, the share of the depositors, etc.\nAttack Example\n\n#\nLendf.me: $25m (April 2020)\n\n#\nVulnerability\n: A pair of functions, such as borrow and withdraw, within \nMoneyMarket\n contract could be called in a specific order, which would allow the attackers to perform malicious actions.\nAttack\n: The attacker exploited the vulnerability by using one function to alter the state of a liquidity pool and then calling another function to falsely borrow and withdraw funds using the changed state. This sequence of actions was performed repeatedly, thus draining MoneyMarket\u2019s liquidity for $25 million.\nCross-Contract Reentrancy\n\n\n#\nThis type of reentrancy occurs between different contracts. A function from one contract triggers a function from another contract, which then calls back a function from the original contract. If not handled properly, this can lead to malicious manipulation of the contract\u2019s state.\nAttack Example\n\n#\nVulnerability\n: The code of Rari\u2019s Fuse Pools did not follow the check-effect-interaction pattern, leading to an exposure that allowed a cross-contract reentrancy attack.\nAttack\n: An attacker exploited this vulnerability by taking a flash loan and then depositing USDC into a vulnerable contract for loans. The attacker was able to borrow ETH and use the vulnerability to make a re-entrant call to exit the market and withdraw his collateral. The attack was repeated until the flash loan was repaid, and the attacker kept the remaining profit.\nRead-Only Reentrancy\n\n\n#\nThe classical examples of reentrancy typically reenter in a state-modifying function so that an inconsistent state is used to perform malicious writes on the contract\u2019s storage. Typically, contracts guard themselves with reentrancy locks, protecting their state from such malicious actions. In contrast, read-only reentrancy is a reentrancy scenario where a \nview\n function is reentered, which in most cases is unguarded as it does not modify the contract\u2019s state. However, if the state is inconsistent, wrong values could be reported. Other protocols, relying on a return value, can be tricked into reading the wrong state as an extremely low or high price of tokens to perform unwanted actions.\nAttack Example\n\n#\nEraLend: $3.4m (July 2023)\n\n#\nVulnerability\n: LP token burning mechanism contained a read-only reentrancy vulnerability. The reserves were not updated at the correct point, which may have allowed the oracle to use an incorrect reserve value to calculate the price.\nAttack\n: The attacker targeted the USDC pools. By burning and then using a callback before the \nupdate_reserves\n function was called, they manipulated the oracle price. Of the $3.4 million lost from EraLend, the attacker profited around $2.66 million.\nCountermeasures\n\n#\nReentrancy Guard\n: By using a Reentrancy Guard, developers can ensure that a function cannot be re-entered while it is still executing. This can be implemented by using a\n\nmutex\n or similar locking mechanism that prevents calling certain functions in an unintended order by utilizing a variable that shows if the function has already been called or not.\nUpdate State First\n: Updating all state variables before making an external call can prevent reentrancy. If all internal work is done first, a callback won\u2019t be able to interfere with the state of the contract.\nAvoid Low-Level Calls\n: By avoiding low-level calls such as \ncall.value()()\n, which expose the contract to reentrancy risks, and instead using higher-level constructs like \ntransfer\n, the risk of reentrancy can be minimized.\nCheck-Effects-Interaction Pattern\n: Following this pattern ensures that the contract\u2019s state is checked, then effects are applied, and finally, interactions are done with other contracts. This sequence helps prevent reentrancy by enforcing a proper order of operations within a function.\nStatic Analysis Tools\n: There are tools available for analyzing smart contracts that can identify potential reentrancy vulnerabilities. Utilizing these tools in the development process can assist in identifying and fixing issues before deployment."
    }
}