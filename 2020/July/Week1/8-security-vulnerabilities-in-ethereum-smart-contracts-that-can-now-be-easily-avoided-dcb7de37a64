{
    "threat_intelligence": {
        "url": "https://medium.com/coinmonks/8-security-vulnerabilities-in-ethereum-smart-contracts-that-can-now-be-easily-avoided-dcb7de37a64",
        "timestamp": "2020-07-07 00:00:00",
        "original_content": "7 Security Vulnerabilities in Ethereum Smart Contracts that can now be easily avoided!\nApplication Level Security Vulnerabilities avoidable by Solidity updates\nNoama Samreen\nCoinmonks\nNoama Samreen\n\n\u00b7\nFollow\n\nPublished in\nCoinmonks\n\n\u00b7\n9 min read\n\u00b7\nJul 7, 2020\n116\n\n\n1\n\n\n\n\n\n\nAs Ethereum smart contracts find their application mostly in e-commerce applications, we believe these are more commonly vulnerable to attacks. In these smart contracts, we mainly focus on identifying vulnerabilities that programmers and users of smart contracts must avoid. This post aims at explaining these seven application-level security vulnerabilities and their earlier adopted methods of prevention. Our main focus is on the Solidity updates up to the most recent Solidity v0.6.0 that fix some of these vulnerabilities.\n\n1. Reentrancy\nA reentrancy attack can drain a smart contract of its ether, can aid an intrusion into the contract code. When an external call function to another untrusted contract is made and an attacker gains control of this untrusted contract, they can make a recursive call back to the original function, unexpectedly repeating transactions that would have otherwise not run, and eventually consume all the gas.\n\n\nFigure 1. Reentrancy example - Simple DAO Attack\nThe reentrancy vulnerability exploitation in the DAO attack (as shown in Figure 1) was accomplished in four steps,\n\nStep 1: The Attacker initiates a transaction by calling the Withdraw function of the Victim;\nStep 2: The Victim transfers the money and calls the fallback function of the Attacker;\nStep 3: The fallback function recursively calls the withdraw function again, i.e., Reentrancy;\nStep 4: Within an iteration bound, extra ether will be transferred multiple times to the Attacker.\n1. 1 Earlier suggested Best-Practice that avoids this vulnerability\nRe-entrancy vulnerability can be prevented by ensuring that state changing logic is committed before ether is sent out of the contract through an external call. It is also a good coding practice to put any logic that performs external calls to unknown addresses at the last operation in a program\u2019s execution. This is known as the checks-effects-interactions pattern. Another technique is to use a mutex by adding a state variable which locks the contract during code execution, thus preventing re-entrant function calls.\n\n2. Call to the unknown\nWhen a function invocation or an ether transfer unexpectedly invokes the fallback function of the callee/recipient. Some of the primitives of Solidity language that causes this are:\n\ncall used to invoke a function or transfer ether\nsend, used to transfer ether from the running contract to some other contract\ndelegatecall, used to invoke a function or transfer ether in the caller environment\ndirect call (see listing 1)\nIf an invoked function\u2019s signature does not match with any existing function, then the call results in a call to the recipient\u2019s fallback function.\n\n2. 1 Earlier suggested Best-Practice that avoids this vulnerability\nSolidity has provision for implementing library contracts by using the keyword library. These library contracts are stateless and non-self-destructive. Forcing libraries to be stateless mitigates attacks whereby attackers modify the state of the library directly to affect the contracts that depend on the library\u2019s code. Therefore, when using call, DelegateCall, the call-to-the-unknown attack that may change the state of the victim contract can be prevented by building stateless libraries.\n\nSolidity version update that mitigates Reentrancy and Call-to-Unknown vulnerabilities\nSolidity V0.6.0 splits the logic behind the earlier fallback function into two different functions, one with the fallback keyword and a receive ether function defined using the receive keyword. The receive ether function is implicitly payable and is called whenever the call data is empty. Whereas, the new fallback function, now with the fallback keyword, is called when no other function matches. This fallback function may or may not be payable. If it is not payable then transactions not matching any other function which sends value will revert.\n\nThis Solidity update would, therefore, solve the issue of unexpected code getting executed when the fallback function of an external smart contract is called.\n\n3. Mishandled Exceptions\nThere are many situations when an exception can be raised in Solidity but the way these exceptions are handled is not always the same. The exception handling is based on the interaction between contracts. This makes the contracts vulnerable to attacks because programmers will be unaware of any ether that is lost if these exceptions are not handled properly and the transactions are reverted.\n\ncontract Alice { \n    function ping(uint) {\n        returns (uint)}}\ncontract Bob { \n    uint x=0;\n    function pong(Alice c){\n        x=1; \n        c.ping(42); \n        x=2; \n        } }\nIn the above code, the value of the variablex after the execution of the contractBob varies depending on the method of the function call. If the ping function of the contract Alice is called using a direct call, then the value of x will be 0. Whereas, if the same function is called using the in-built function call of Solidity, then the value of x will be 2. Moreover, in the case of exceptions, if no bound is specified then all the available gas is lost.\n\n3. 1 Earlier suggested Best-Practice that avoids this vulnerability\nOne technique to avoid this vulnerability would be to use one method of external call throughout. However, this is not an ideal preventive technique as different variations of an external call can be a necessity. Therefore, this vulnerability requires an update on the Solidity Language to make the consequences of a thrown exception uniform.\n\n4. DoS By An External Call Vulnerability\nWhen the flow of control is transferred to an external contract, the execution of the caller contract can fail accidentally or deliberately, which can cause a DoS state in the caller contract. The caller contract can be in a DoS state when a transaction is reverted due to a failure in an external call, or the callee contract deliberately causes the transaction to be reverted to disrupt the execution of the caller contract.\n\ncontract HYIP {\n    Lenders[] private lender;\n    function sendPayment() {\n        for(uint i = lender.length; i\u2212\u2212 > 0; ) {\n            uint payment=(lenders[i].amount*/1000;\nif(!lenders[i].addr.send(payment)) throw;\n            }\n    }\n}\n contract AttackerContract {\n    bool private attack = true;\n    function() payable {\n        if (attack) throw; // callee fails the caller execution deliberately\n    }\n    function stopAttack() {\n        if(msg.sender == owner) attack = false;\n    }\n }\n4. 1 Earlier suggested Best-Practice that avoids this vulnerability\nThis vulnerability exists because of inadequate exception handling around conditional and iteration statements. Placing any external calls initiated by a callee contract into a separate transaction can help reduce the damage caused by this vulnerability. Isolating statements with the following pattern can help avoid this vulnerability:\n\nan if statement with an external function call in the condition and a throw or revert in the body;\na for or anif statement with an external function call in the condition.\nSolidity version update that mitigates Mishandled Exceptions and Denial of Service vulnerabilities\nSolidity V0.5.3 enables catching of exceptions with the try/catch statement and the following convenience functions:\n\nThe assert function should only be used to test for internal errors, and to check invariants because assert style exceptions consume all gas available to the call.\nThe require function should be used to ensure valid conditions that cannot be detected until execution time.\nThe revert function is another way to trigger exceptions from within other code blocks to flag an error and revert the current call.\n5. Out-of-Gas exception\nThe primitive function send may cause an unexpected out-of-gas exception when transferring ether among contracts. There is a pre-fixed unit of gas available to allow the execution of a limited set of bytecode instructions and the call function will end up in an out-of-gas exception if not enough gas units are available.\n\n\nFigure 2. Out-of-Gas Exception example- King of Ether Attack\n5. 1 Earlier suggested Best-Practice that avoids this vulnerability\nThis vulnerability can be prevented by using the Transfer function instead of Sendas the former will revert the local transactions if the external transaction reverts. However, if Send function is required to be used then the return value of this function needs to be monitored. Another technique is to adopt a withdrawal pattern, wherein, each user is required to call an isolated function that manages ether transactions and does not affect the rest of the contract execution. Therefore, making the transaction management independent of the consequences of failed Send transactions.\n\nSolidity version update that mitigates Out-of-gas vulnerability\nUp until Solidity V0.5.0, if a contract receives Ether, thefallback function gets executed and if it does not have a fallback function, the Ether will be rejected and an exception is thrown. However, during the execution of the fallback function, the contract can only utilize only 2300 gas at that time. This gas limit is not enough to modify storage. This \"gas stipend\" limit answered the out-of-gas issues but was not very efficient.\n\nWith the new Solidity update of V0.6.0, the division of fallback function and recieve function solves the out-of-gas vulnerability to a greater extent as there cannot be any expensive code to be executed in the recieve function, therefore, enabling programmers to analyze the amount of gas they would be spending during a transaction.\n\n6. Typecasts\nThe fact that the Solidity compiler can detect some type errors may cause the programmers to believe that it also checks for the address of the contract being called and the interface declared by the caller function matches callee\u2019s actual interface. The execution of a contract in the presence of such type mismatch errors will not throw exceptions at run-time and the caller is unaware of the error resulting in three different cases at run-time:\n\nIncorrect contract address of callee function, the call returns without executing any code,\nContact address of callee function matches with any other function\u2019s signature, then that function is executed\nThe Contact address of the callee function does not match with any function\u2019s signature, then its fallback is executed.\n6. 1 Earlier Suggested Best-Practice that avoids this vulnerability\nTo prevent typecasting to malicious contracts, the new keyword can be used. This way an instance of the referenced contract cannot be changed without modifying the contract as this is created at deployment time. Another technique is to hard code any external contract address in the contract to avoid malicious contracts getting referenced.\n\nSolidity version update that mitigates Typecasts vulnerability\nFrom Solidity V0.5.3, Contract types do not include address members. Therefore, it has been made necessary to explicitly convert values of contract type to addresses before using an address member. Example: if c is a contract, change c.transfer(...) to address(c).transfer(...), and c.balance to address(c).balance.\n\nAlso, the explicit conversions between unrelated contract types have been disallowed from Solidity V0.5.3. A contract can now be converted only to its base.\n\nThe address type was split into address and address payable, where only address payable provides the transfer function. An address payable can be directly converted to an address, but the other way around is not allowed.\n\n7. Weak Field Modifiers\nFields in smart contracts can be labelled as Public or Private. However, these attributes are not enough to protect a field\u2019s value. This is because the default access modifier of afield in Solidity is public. Whenever a field\u2019s value is changed, this change is published on the BT chain and there is a chance that an attacker would infer the changed value through previous hashes and new transaction hash.\n\n\nFigure 4. Weak Field Modifiers example - Odd/Even Game\n7. 1 Earlier suggested Best-Practice that avoids this vulnerability\nTo avoid this smart contract\u2019s vulnerability, use the internal modifier for functions instead of using the public modifier.\n\nSolidity version update that mitigates Weak Field Modifiers Vulnerability\nThis vulnerability is still a threat to sensitive data contained in a smart contract. However, the solidity version update of V0.5.3 has made the handling of function visibility in a much better way than what it was before. Explicit function visibility has been made mandatory from this version which can be done by adding public to every function and constructor, and external to every fallback or interface function that does not specify its visibility already.\n\nExplicit data location for all variables of struct, array or mapping types has also been made mandatory from this update, which applies to function parameters and return variables. For example, change uint[] x = m_x to uint[] storage x = m_x, and function f(uint[][] x) to function f(uint[][] memory x) where memory is the data location and might be replaced by storage or calldata accordingly. Note that external functions require parameters with a data location of calldata.\n\nConclusion\nThis post provides a brief analysis of the security vulnerabilities of Ethereum smart contracts, with a few real-world exploitation cases of these vulnerabilities and their preventive techniques that was suggested earlier. I targetted seven security vulnerabilities in Ethereum Smart Contracts that are at the level of the application layer. Thus requiring preventive techniques in the form of alterations at the programming level. This highlights the Solidity version updates that are essential to be noted to avoid these vulnerabilities while developing DApps and Smart Contracts."
    }
}