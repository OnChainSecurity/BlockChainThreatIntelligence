{
    "threat_intelligence": {
        "url": "https://www.mdpi.com/2624-800X/2/2/19",
        "timestamp": "2020-08-04 00:00:00",
        "original_content": "Existing security-analysis tools for smart contracts mainly apply static or dynamic analysis. Newly proposed tools incorporate other approaches such as deep learning or focus on certain types of vulnerabilities. In order to answer RQ3, in this section, we study smart-contract security-analysis tools and compare nine recently proposed tools that were released after 2017. Our work complements [\n11\n], which was carried out in 2017. Compared to our study, [\n33\n] covers many more tools. While they consider tools introduced since 2014, we focus on recently proposed tools after 2018 that are specific to Ethereum and are also prevalently used or mentioned in multiple recent studies. Moreover, we did not consider a number of tools that either have no coverage of our set of vulnerabilities or their developers/authors do not report their efficiency or accuracy analysis.\n  5.1. Recent Security-Tools Support\n shows how each tool covers the most ubiquitous vulnerabilities. Many tools have their own set of vulnerabilities and methods to find them (see ). There are overlapping vulnerabilities that many tools try to detect. We consider reported accuracy above 90% as \nhigh\n, below 50% as \nlow\n, and the rest as \nmedium\n. The accuracy works in the realm of each tool\u2019s defined vulnerabilities, so this comparison will give readers an impression of how each tool works for their own set of vulnerabilities.\n\n\nTable 3.\n\n    Tools and vulnerabilities matrix.\n  \n\n\n\n\n\n\n\n\nTable 4.\n\n    A comparison of security-analysis tools. The first two rows were studied before 2018 by Dika in [\n11\n]. Note that the accuracy and efficiency of these tools are not really comparable as they rely on self-defined metrics by their authors. We consider reported accuracy above 90% as high, below 50% as low, and the rest as medium.\n  \n\n\n\n\n\n\nsmartCheck.\n This tool is a static analysis tool that uses ANTLR [\n92\n] (a parser generator) to translate Solidity source code into an XML pare tree [\n93\n] (an XML-based intermediate representation), and checks it against XPath [\n94\n] patterns [\n38\n].\nDefectChecker.\n The defectChecker tool takes bytecodes as input, disassembles them into opcodes, splits the opcodes into several basic blocks and symbolically executes instructions in each block [\n43\n]. Then it generates the control flow graph (CFG) and records all stack events. Using CFG and stack events information, it detects three pre-defined features: money call, loop block and payable function. After feature detection, it applies rules to detect eight vulnerabilities: \ntransaction state dependency\n, \nDoS under external influence\n, \nstrict balance equality\n, \nre-entrancy\n, \nnested call\n, \ngreedy contract\n, \nunchecked external calls\n, and \nblock info dependency\n.\ncontractWard.\n The contractWard applies supervised learning to find vulnerabilities [\n44\n]. It extracts 1619 dimensional bigram features from opcodes using an n-gram algorithm [\n95\n] and forms a feature space. Then it labels contracts in training set with six types of vulnerabilities using Oyente [\n13\n]. The label is stored in a six-dimension vector (e.g., [1 0 1 0 1 1]) where each bit stands for an existing vulnerability. Based on the feature space and labels of the training set, contractWard uses five classification algorithms to detect vulnerabilities.\nNPChecker.\n This tool analyzes the \nnon-determinism\n in the smart-contract execution context and then performs systematic modelling to expose various non-deterministic factors in the contract execution context [\n46\n]. Non-deterministic factors are factors that could impact final results to the end-user and make them unforeseeable. Possible factors discussed in NPChecker are \nblock and transaction state\n, \ntransaction execution scheduling\n, and \nexternal callee\n. The NPChecker disassembles the EVM bytecode and translates them into LLVM intermediate representation (IR) code [\n96\n], recovers the control flow structures and enhances the LLVM IR with function information, identifies state and global variables, and performs information-flow tracking to analyze their influences on the fund\u2019s transfer.\nMadMax.\n The MadMax tool uses the Vandal decompiler [\n42\n] to produce CFG, a three-address code for all operations in the smart contract, and function boundaries [\n41\n]. Then it analyzes the three-address-code representation, recognizes concepts such as loops and induction variables, analyzes memory and dynamic data structures, and infers the concept of gas-focused vulnerabilities. This tool only detects \ngas-focused vulnerabilities\n, such as unbounded mass operations (infinite or nearly infinite loops), external calls that throw out-of-gas exceptions or arithmetic integer overflows, because those vulnerabilities will cause unexpected gas consumption.\nOsiris.\n The Osiris combines symbolic analysis and taint analysis technology to find integer bugs in smart contracts [\n45\n]. It has three components: symbolic analysis, taint analysis and integer error detection. The symbolic analysis component creates CFG and symbolical executions of every path in the CFG. Then, the taint analysis part checks for taints across the stack, memory and storage, and integer error detection looking for possible integer bugs within the executed instruction.\ncontractFuzzer.\n The contractFuzzer tool combines static analysis of ABI and bytecodes and fuzzing technology to explore vulnerabilities of smart contracts [\n49\n]. It creates an Ethereum test net using offline EVM to monitor the execution of the smart contracts and extract information from the execution process. By analyzing the ABIs and bytecodes, contractFuzzer calculates the function selector (first four bytes of the hash of the function\u2019s signature) and maps each ABI function to a set of function selectors used. Then an input generation algorithm is created to fuzz each function based on the information of the previous step. It collects three types of test oracles during the execution of smart contracts: attributes of a contract \nc\na\nl\nl\nc\na\nl\nl\n or \nd\ne\nl\ne\ng\na\nt\ne\nc\na\nl\nl\nd\ne\nl\ne\ng\na\nt\ne\nc\na\nl\nl\n, run-time information about opcodes invoked, and the state of the contract.\nSereum.\n It is a modified Ethereum client based on Geth [\n97\n] that focuses on re-entrancy vulnerabilities [\n54\n]: \ncross-function re-entrancy\n, \ndelegated re-entrancy\n, and \ncreate-based re-entrancy\n. The cross-function re-entrancy is to re-enter another function in the same contract. The delegated re-entrancy is to re-enter a smart contract via \nd\ne\nl\ne\ng\na\nt\ne\nc\na\nl\nl\nd\ne\nl\ne\ng\na\nt\ne\nc\na\nl\nl\n to an unsafe library that may use \na\nd\nd\nr\ne\ns\ns\n.\nc\na\nl\nl\n(\n)\n.\nv\na\nl\nu\ne\n(\n)\na\nd\nd\nr\ne\ns\ns\n.\nc\na\nl\nl\n(\n)\n.\nv\na\nl\nu\ne\n(\n)\n to call back to the original contract. The create-based re-entrancy utilizes the fact that a newly created contract will have its constructor function executed immediately when the contract is deployed. The constructor is deemed safe and trusted, but it could contain external calls to malicious contracts. If the victim contract creates another contract in function \nA\n and calls the attacker\u2019s contract in the newly created contract\u2019s constructor, the attacker\u2019s contract could re-enter the victim contract by calling function \nA\n. Sereum adds two components to the Geth client: taint engine (taints and tracks state variables along with the executions of various functions that detects conditional \nJ\nU\nM\nP\nJ\nU\nM\nP\n instructions influenced by a storage variable), and attack detector (creates locks that prohibit further updates for state variables that influence control flows).\nsFuzz.\n The sFuzz tool is an adaptive fuzzer that combines the strategy in the AFL fuzzer [\n98\n] and other adaptive strategies [\n52\n] built on Aleth [\n99\n] with implementations of three more components: \nrunner\n, \nlibfuzzer\n, and \nliboracles\n. The \nrunner\n sets up the test net environment and options of the other two components. Then the contracts are executed on the test net, where transactions are generated based on the analysis of the contract\u2019s ABI. The \nlibfuzzer\n selectively generates test cases by implementing a feedback-guided adaptive fuzzing strategy. The \nliboracles\n monitors the execution of a test case and the corresponding stack events to check for vulnerabilities.\n  5.2. Comparisons\n summarizes our comparisons and shows that new tools are more static analyzers and are focused on self-defined or widely accepted sub-categories of vulnerabilities. The first two rows are based on [\n11\n] that, prior to 2018, studied Oyente [\n13\n], Securify [\n36\n], a beta version of SmartCheck (that was later published in 2018), and Remix [\n100\n], which now uses Securify for safety assurance. The NPChecker defines non-deterministic factors and works on vulnerabilities raised by those factors. The MadMax, Osiris, and Sereum focus on gas-related, arithmetic, and re-entrancy problems, respectively. We extracted evaluation information from each cited paper for our comparison and report accuracy and efficiency in the . We explain threats to the validity of our comparison in \nSection 6\n.\nAccuracy:\n Based on their own understanding of the smart-contract vulnerabilities and causes, each tool has its own metrics to determine true positives and false positives, and the statistics are strongly related to the covered vulnerabilities. The accuracy numbers for Oyente and Securify are calculated based on [\n13\n] and Figure 8 in [\n11\n], respectively.\nEfficiency:\n The efficiency is evaluated based on each tool\u2019s approach. It is based on the process time of each contract for the static tools, and it is based on the specific mechanism of each dynamic tool. For Oyente and Securify, no efficiency data is reported either in [\n11\n] or in their own proposals. Sereum is a modified Geth [\n97\n] client (a client that interacts with Ethereum blockchain) and replays the execution of each transaction in the blockchain; thus, its efficiency is compared with Geth client running performance. In addition, sFuzz\u2019s efficiency is evaluated on how fast it can generate fuzzing inputs."
    }
}