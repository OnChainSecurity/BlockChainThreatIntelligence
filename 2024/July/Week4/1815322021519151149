{
    "threat_intelligence": {
        "url": "https://x.com/ShieldifySec/status/1815322021519151149",
        "timestamp": "2024-07-22 00:00:00",
        "original_content": "Writing an \u201cUnhackable\u201d Money Market\n? \\- Problem 1: Re-Entrancy\n\\- Problem 2: Input Validation \\- Problem 3: Rounding Errors Now follow the\nthread ? Looks like today\nwe're building us an \"unhackable bank\" on the blockchain. How do we go about\nthis exactly? Pull up a chair, grab a cold one, and let's dive into the good,\nthe bad, and the downright ugly of securing a web3 money market.\n?Problem 1: Re-Entrancy\nPicture this: Jane and Roy are a newly married couple, eager to withdraw some\nfunds from their wedding account. Jane presses the withdraw button, and lo and\nbehold, the balance still shows the same amount even after a withdrawal. Being\nthe curious (and cheeky) lass she is, Jane decides to press it again. And\nagain. Before you know it, Jane's made more withdrawals than their account\nactually holds. That's re-entrancy for you, folks, and it just earned Jane a\ntrip to the courthouse. A malicious contract can call back into the vulnerable\ncontract before the previous function execution completes, allowing multiple\nwithdrawals of funds. Here\u2019s a simple version of how it can go wrong in\nSolidity:\n\n[![Image](https://pbs.twimg.com/media/GTFPHw6WEAEPqsD?format=jpg&name=medium)](/ShieldifySec/status/1815322021519151149/photo/1)\n\nTo fix this, you need to update the state before making external calls or use\na mutex:\n\n[![Image](https://pbs.twimg.com/media/GTFPQ4vXQAAKsrN?format=jpg&name=medium)](/ShieldifySec/status/1815322021519151149/photo/2)\n\n?Problem 2: Input\nValidation Now Roy, enterprising bloke that he is, decides to make a cash\ndeposit for his buddy John, to whom he owes money. John, being a bit clumsy\nwith his phone, gives Roy his account number but accidentally types a few\nextra digits. Even though account numbers at the bank are all 12 digits, John\nends up giving a 15-digit account number. Roy, trusting John\u2019s information,\ntypes it in without a second thought and sends the money to this non-existent\naccount. Without proper input validation, the bank's system fails to notice\nthe mistake and accepts the money. Poof! It\u2019s gone now, to an account that\nnobody can access. A classic case of lost funds due to poor input validation.\nTo avoid such scenarios, input validation is like your best mate who always\ndouble-checks things before you make a fool of yourself. In this case, the\nsystem should give a quick once-over to make sure the account number is\nexactly 12 digits and actually exists before accepting the deposit. These\nsimple checks can prevent such costly errors and keep both Roy and John from\ntearing their hair out and cursing their fat fingers. But even more\nimportantly, you should probably check that the user account exists within the\ndepositors of the bank. Otherwise, you might still send the money into the\nvoid. Here\u2019s how we can do that with Solidity:\n\n[![Image](https://pbs.twimg.com/media/GTFPr_UWUAE_3iH?format=jpg&name=medium)](/ShieldifySec/status/1815322021519151149/photo/3)\n\nIn this code, we validate the deposit by checking if the account number is\nexactly 12 digits and if the account actually exists within the bank's\ndepositors. This way, Roy and John can sleep easy knowing their funds won\u2019t\ndisappear into the void, and everyone can avoid a potential nightmare.\n?"
    }
}