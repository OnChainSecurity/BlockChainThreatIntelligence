{
    "threat_intelligence": {
        "url": "https://www.mdpi.com/2224-2708/13/1/13",
        "timestamp": "2024-10-14 19:29:06",
        "original_content": "In this study, our primary emphasis was on designing and implementing remote healthcare monitoring systems. The research commenced with an analysis of the traditional healthcare information system architecture, and we then delved into the security issues associated with remote healthcare monitoring systems (RHMSs). Our contribution includes the formulation of a security model tailored for RHMSs. Additionally, we put forth a system model and executed a security mechanism that leverages blockchain technology and other integral components to fortify the support structure for RHMSs.\n  3.1. Security Model\nLet \nV\n = {\nv\n1\n, \nv\n2\n, \nv\n3\n, \u2026, \nv\nn\n} represent the set of vital signs that measure the patient, including pulse, heartbeat, temperature, etc. The health number (\nHN\n) is assigned by the HIS, whereas t is the timestamp. Hence, the transaction of the sensing data is represented by Equation (1).\n        \nThe primary objective was to ensure security by preventing unauthorized access and authentication, which is a key requirement in the context of RHMSs. Additionally, traceability is an essential aspect of the RHMS system. Therefore, this paper introduced a security model, represented by Equation (2), to address these critical concerns.\n        \n\n\n\n\nTX\n(\nmsg\n) = \nE\nk\n (\nmsg\n), \nS\nk\n (\nmsg\n),\n      \n\n\n\n\n(2)\n\n\n\n\n\n        where the plain text, \nmsg\n, refers to the plain data that comprises the \nHN\n, a timestamp, and a set of vital signs. The encryption algorithm, denoted as \nE\nk\n(), was applied to secure this information, and a digital signature, \nS\nk\n(), was added to authenticate the method.\nEquation (2) represents the traditional model used to secure plain messages, which necessitates the use of cryptographic keys and their distribution. The proposed RHMS introduced a decentralized paradigm, thereby effectively eliminating the external connections to the HIS network. Consequently, the implementation of a distributed database using blockchain technology served as the solution for this work, with the security model being managed by smart contracts. Additionally, this approach resulted in the automatic implementation of traceability.\n  3.2. Proposed System Architecture\nThe system architecture, as depicted in , signifies the transformation of healthcare through the integration of healthcare monitoring devices, blockchain technology, and decentralized data management. It capitalizes on IoT devices with vital sign sensors and secure blockchain data storage for improved data accuracy and security. This architecture leverages data brokers and health information systems to enhance data collection and management, ultimately optimizing the healthcare ecosystem.\n\n\n\n\n\n\n\n\nFigure 2.\n\n      The proposed system architecture.\n\n\n  \n\n\nHealthcare monitoring devices, which are a subset of the Internet of Medical Things, feature vital sign sensors that can connect via various interfaces and derive power from the MCU board; moreover, they are responsible for power management and data transmission. These MCUs are commonly linked to power sources like adapters and rely on reliable networks such as WiFi or 3G/4G. To ensure seamless operation, these devices support real-time or embedded operating systems like RaspbianOS, especially in Raspberry Pi applications. There are two functions in the healthcare monitoring devices: \nsense_data()\n and \nsend_data().\nThe sense_data() function\nThe \nsense_data()\n function is tasked with capturing vital signs data from the patient. Following this data acquisition, it assesses data reliability by evaluating the precision of each sensor value. This evaluation involves establishing a linear equation, computing the standard error of the data, and determining the vital sign value based on the data\u2019s average.\nTo precise the value of the vital sign, let \n\n\n\u00af\n\u2208\n\nv\ni\n\u00af\n\u2208\nV\n be such that \nV\n is the set of vital signs. In addition, \n\n\n\u00af\nv\ni\n\u00af\n is calculated from the set of sensing data under the following conditions: (1) the sensing data are in the linear equation, \n\n\n=\n\n\n\n+\n\n\nv\ni\n=\n\u03b1\ni\nx\n+\n\u03b5\ni\n, with the coefficient \n\u03b1\ni\n; and (2) the precise vital sign is \n\n\n\n\n\n=\n\n\n\u2248\n0\nd\nv\ni\nd\nx\n=\n\u03b1\ni\n\u2248\n0\n. The \nsense_data()\n function is shown in Algorithm 1.\n        \nAlgorithm 1\n\u00a0 \nsense_data():\n sense precise vital signs\nround\n \u2190 \ntrial\nwhile\n\u00a0\n\u03b1\ni\n \u2248 0 and \nround\n \u2260 0 \ndo\nt\n0\n \u2190 0\nS\n \u2190 \n\u03d5\nwhile\n \nt\n \u2212 \nt\n0\n \u2264 \u2206\nt\n \ndo\ni\n \u2190 \nsense()\nS\n \u2190 \nS\n \u222a \ni\nt\n \u2190 \ntimestamp()\nend while\n\u03b1\ni\n \n\u2190 \nLinearRegression()\n \n round\n \u2190 \nround\n \u2212 1\nend while\nif\n \nround\n = 0 \nthen\nreturn\n \nS. average()\nelse\nreturn error\nAlgorithm 1 illustrates the sensing and refining actions that are performed on the sensor data. The medical device collects data from the vital sensor for a duration of \u2206\nt\n. The sampling rate is determined by the sensor specifications provided in its datasheet. Subsequently, the algorithm computes a linear regression model and provides the coefficient \n\u03b1\ni\n. The algorithm returns the average of the sensing data when \n\u03b1\ni\n is close to zero or within an acceptable range. The complexity of the algorithm is proven in Theorem 1.\nTheorem\n\u00a0\n1.\n \nThe sense_data() is the O(r\u00b7k) complexity.\nProof\u00a0of\u00a0Theorem\n\u00a0\n1.\n \nThe outer loop runs until either \n\u03b1\ni\n is not approximately equal to 0 or the number of rounds (\nround\n) is not equal to 0. In each iteration of the outer loop, there is an inner loop that continues until the time difference (\nt\n \u2212 \nt\n0\n) exceeds a threshold \u2206\nt\n. In each inner loop iteration, the algorithm performs a constant number of operations as follows: sensing (\ni\n), updating a set (\nS\n), and obtaining a timestamp (\nt\n).\nLet us denote the number of rounds as \nr\n and the maximum number of inner loop iterations as \nk\n. The time complexity of the inner loop is \nO\n(\nk\n) since it depends on the threshold \u2206\nt\n. The outer loop runs until \n\u03b1\ni\n is not approximately equal to 0, and the worst-case scenario is that it runs \nr\n times.\n        \n\n\t\t\nThe send_data() function\nThe \nsend_data()\n function is responsible for transmitting encrypted data to the blockchain platform. The input data for this function are based on Equation (1), and these include the health number (\nHN\n) and unique wallet address that is assigned by the HIS for simple authentication, along with a set of vital sign data, which is denoted as \nV\n, as well as the automatically collected timestamp \nt\n from healthcare monitoring devices. The process of the healthcare monitoring device is shown in .\n\n\n\n\n\n\n\n\nFigure 3.\n\n      The process state machine of healthcare monitoring devices.\n\n\n  \n\n\nThe process state machine illustrates the healthcare monitoring device\u2019s operation in . This device is controlled using two buttons: \u201c\nnext\n\u201d and \u201c\nback\n\u201d. The \u201c\nnext\n\u201d button confirms actions and progresses to the next state, while the \u201c\nback\n\u201d button is used to cancel. Additionally, the device requires an LCD or OLED screen to display its state and sensing values.\nIn the initial state, the user inputs their health number (HN) and blockchain wallet information, and then \u201c\nnext\n\u201d is selected to transition to the sense state. In the sense state, the device invokes the \u201c\nsense_data()\n\u201d function to gather vital signs. This state repeats until all vital signs have been sensed. Afterward, it displays the sensing data and awaits a transition to the next state, which is triggered by the selection of \u201c\nnext\n\u201d.\nThe medical device attempts to establish a network connection in the connected state. This process halts when the device cannot connect to the network. When the network connection is successful, the medical device generates a transmission message based on Equation (2). This message is encrypted and signed with a signature using the blockchain library and its associated smart contract. Finally, the message is secured by the blockchain library and sent to the distributed database on the blockchain platform.\n  3.2.1. Blockchain Architecture Design\nIn the decentralized paradigm, the data reside in a distributed database and are encrypted, signed, and securely transferred through channels. Smart contracts within the blockchain platform oversee business processes and security policy management, and the platform provides secure APIs for data access, thus ensuring authorized data retrieval.\nSmart contracts play a crucial role in safeguarding vital sign data. These contracts are built upon a data structure, which is outlined in Equation (1) and comprises essential elements such as the healthcare number, timestamp, and a set of vital signs. For a detailed view of the data structure and the function prototype of the smart contract, refer to .\n\n\n\n\n\n\n\n\nFigure 4.\n\n      The smart contract of S3RH.\n\n\n  \n\n\n encompasses two distinct data structures along with their associated functions. The \u201cPatient\u201d structure serves as a container for storing the healthcare number and wallet address, which serve as a unique identifier for the user. In contrast, the \u201cVitalsign\u201d structure is specifically created to store both timestamp and vital sign information in a textual format. The vital sign data are stored in textual structures like CSV, JSON, XML, etc. To illustrate, consider the following three sensor data points (all of which include a corresponding timestamp): temperature, heart rate, and SPO3. The \u201cPatients\u201d and \u201cVitalSign\u201d structures are equipped with a set of get functions. These data structures are organized within a sequential list. Adding the data involves pushing new information into the list, while the \u201cget\u201d method allows for constant and efficient access to the stored data.\n  3.2.2. Web APIs with an MQTT Data Broker\n illustrates the comprehensive network flow within the proposed system. The remote healthcare monitoring system (RHMS) initiates the transmission of vital signs to the blockchain network utilizing the \nsend_data()\n function. The transmission of sensitive data occurs through a secure channel, which ensures its confidentiality during transit over the Internet.\n\n\n\n\n\n\n\n\nFigure 5.\n\n      Network flows of the proposed architecture.\n\n\n  \n\n\nUpon the retrieval of data from the blockchain network, the hospital\u2019s web API service issues a request API, which incorporates an authentication message (comprising the hospital number, HN, and wallet ID) as a concealed secret key. This transaction transpires over a secure network. Subsequently, the API service disseminates the response message to the \u201cS3RH\u201d topic on the MQTT broker. Notably, the message queuing telemetry transport (MQTT) protocol is employed as a lightweight protocol for the publish/subscribe mechanism. Moreover, the MQTT protocol incorporates support for a transport layer security (TLS) secure channel, which is used to augment the overall security of the system.\nIn the context of our proposed system, the MQTT broker assumes a pivotal role by facilitating secure and efficient machine-to-machine communication. It empowers web agents to retrieve patient records seamlessly from hospital information systems, thereby ensuring the timely and secure handling of data. The integration of patient medical data into a blockchain-based storage system further enhances security and decentralizes access, thereby safeguarding patient information. Consequently, the MQTT broker emerged as a critical component within the healthcare architecture.\nThe operational flow of the MQTT protocol in our framework is depicted in . Subsequently, the web API orchestrated the publication of acquired sensor data to the MQTT broker. Conversely, the hospital information system (HIS) functions as a client and assumes the role of a subscriber within the MQTT paradigm. It systematically collects data from the MQTT broker via its authorization parameters, thereby further enhancing the interoperability and efficiency of our proposed healthcare system.\n  3.2.3. HIS Software Agent\nThe healthcare number (HN) serves as the primary key for accessing patient records across the various hospitals that patients have visited. Our system is strictly read-only, and it does not make any updates to the hospital information system (HIS). Each HIS is equipped with a dedicated query module, which is developed to retrieve and format the patient information requested through the web agents or web API. This process is read-only and does not involve any alterations to the patient\u2019s data in the HIS. Web agents receive the HN through the MQTT protocol and use it to request patient information. The query module mentioned earlier retrieves and returns the data to the web agent. These web agents are software processes developed in any programming language. They can either be embedded within the hospital\u2019s system or can be run on a Raspberry Pi computer-on-a-board system, whereby it serves as a front end connected to the hospital\u2019s server machine via their local area network (LAN). The installation and maintenance of this hardware and software are managed by our development team. One of the tasks performed by each agent is to format and restructure the patient information extracted from the HIS into an electronic health record (EHR). Subsequently, the data are encrypted before being transmitted to the central server, which is then ready to be analyzed by the doctor in the next step."
    }
}